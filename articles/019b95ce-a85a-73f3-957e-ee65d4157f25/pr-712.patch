PR #712: fix: Replace local theme directories with symlinks for hot reload support
https://github.com/vivliostyle/vivliostyle-cli/pull/712

Usage:
  $ cd <project-root>
  $ patch --strip=2 --directory=node_modules/@vivliostyle/cli < pr-712.patch

diff --recursive --unified --new-file a/package/dist/chunk-37OLZSNI.js b/package/dist/chunk-37OLZSNI.js
--- a/package/dist/chunk-37OLZSNI.js	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/chunk-37OLZSNI.js	1970-01-01 09:00:00.000000000 +0900
@@ -1,87 +0,0 @@
-import {
-  resolveViteConfig
-} from "./chunk-XMCTTVR7.js";
-import {
-  createViteServer,
-  getViewerFullUrl,
-  loadVivliostyleConfig,
-  mergeConfig,
-  mergeInlineConfig,
-  resolveTaskConfig,
-  warnDeprecatedConfig
-} from "./chunk-BR2V7MHE.js";
-import {
-  Logger,
-  isUnicodeSupported,
-  randomBookSymbol,
-  setupConfigFromFlags
-} from "./chunk-T2VWLU2I.js";
-import {
-  cliVersion
-} from "./chunk-ZEBXHUJX.js";
-import {
-  __callDispose,
-  __using
-} from "./chunk-I7BWSAN6.js";
-
-// src/core/preview.ts
-import terminalLink from "terminal-link";
-import { blueBright, cyan, dim } from "yoctocolors";
-async function preview(inlineConfig) {
-  Logger.setLogOptions(inlineConfig);
-  Logger.debug("preview > inlineConfig %O", inlineConfig);
-  let vivliostyleConfig = await loadVivliostyleConfig(inlineConfig) ?? setupConfigFromFlags(inlineConfig);
-  warnDeprecatedConfig(vivliostyleConfig);
-  vivliostyleConfig = mergeInlineConfig(vivliostyleConfig, inlineConfig);
-  const { tasks, inlineOptions } = vivliostyleConfig;
-  Logger.debug("preview > vivliostyleConfig %O", vivliostyleConfig);
-  let config = resolveTaskConfig(tasks[0], inlineOptions);
-  Logger.debug("preview > config %O", config);
-  let server;
-  let url;
-  {
-    var _stack = [];
-    try {
-      const _2 = __using(_stack, Logger.startLogging("Start preview"));
-      const viteConfig = await resolveViteConfig({
-        ...config,
-        mode: "preview"
-      });
-      server = await createViteServer({
-        config,
-        viteConfig,
-        inlineConfig,
-        mode: "preview"
-      });
-      if (server.httpServer) {
-        await server.listen();
-        vivliostyleConfig = mergeConfig(vivliostyleConfig, {
-          temporaryFilePrefix: config.temporaryFilePrefix,
-          server: server.config.server
-        });
-        config = resolveTaskConfig(
-          vivliostyleConfig.tasks[0],
-          vivliostyleConfig.inlineOptions
-        );
-      }
-      url = await getViewerFullUrl(config);
-    } catch (_) {
-      var _error = _, _hasError = true;
-    } finally {
-      __callDispose(_stack, _error, _hasError);
-    }
-  }
-  if (server.httpServer) {
-    Logger.log(`
-${cyan(`Vivliostyle CLI v${cliVersion}`)}
-${blueBright("\u2551")} ${isUnicodeSupported ? `${randomBookSymbol} ` : ""}Up and running (press Ctrl+C to quit)
-${blueBright("\u2559\u2500")} ${dim(`Preview URL: ${terminalLink(url, url, { fallback: () => url })}`)}
-`);
-  }
-  return server;
-}
-
-export {
-  preview
-};
-//# sourceMappingURL=chunk-37OLZSNI.js.map
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-37OLZSNI.js.map b/package/dist/chunk-37OLZSNI.js.map
--- a/package/dist/chunk-37OLZSNI.js.map	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/chunk-37OLZSNI.js.map	1970-01-01 09:00:00.000000000 +0900
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/core/preview.ts"],"sourcesContent":["import terminalLink from 'terminal-link';\nimport type { ViteDevServer } from 'vite';\nimport { blueBright, cyan, dim } from 'yoctocolors';\nimport { setupConfigFromFlags } from '../commands/cli-flags.js';\nimport { loadVivliostyleConfig, warnDeprecatedConfig } from '../config/load.js';\nimport { mergeConfig, mergeInlineConfig } from '../config/merge.js';\nimport { resolveTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { resolveViteConfig } from '../config/vite.js';\nimport { cliVersion } from '../const.js';\nimport { isUnicodeSupported, Logger, randomBookSymbol } from '../logger.js';\nimport { createViteServer, getViewerFullUrl } from '../server.js';\n\nexport async function preview(inlineConfig: ParsedVivliostyleInlineConfig) {\n  Logger.setLogOptions(inlineConfig);\n  Logger.debug('preview > inlineConfig %O', inlineConfig);\n\n  let vivliostyleConfig =\n    (await loadVivliostyleConfig(inlineConfig)) ??\n    setupConfigFromFlags(inlineConfig);\n  warnDeprecatedConfig(vivliostyleConfig);\n  vivliostyleConfig = mergeInlineConfig(vivliostyleConfig, inlineConfig);\n  const { tasks, inlineOptions } = vivliostyleConfig;\n  Logger.debug('preview > vivliostyleConfig %O', vivliostyleConfig);\n\n  // Only show preview of first entry\n  let config = resolveTaskConfig(tasks[0], inlineOptions);\n  Logger.debug('preview > config %O', config);\n\n  let server: ViteDevServer;\n  let url: string;\n  {\n    using _ = Logger.startLogging('Start preview');\n    const viteConfig = await resolveViteConfig({\n      ...config,\n      mode: 'preview',\n    });\n    server = await createViteServer({\n      config,\n      viteConfig,\n      inlineConfig,\n      mode: 'preview',\n    });\n    if (server.httpServer) {\n      await server.listen();\n      vivliostyleConfig = mergeConfig(vivliostyleConfig, {\n        temporaryFilePrefix: config.temporaryFilePrefix,\n        server: server.config.server,\n      });\n      config = resolveTaskConfig(\n        vivliostyleConfig.tasks[0],\n        vivliostyleConfig.inlineOptions,\n      );\n    }\n    url = await getViewerFullUrl(config);\n  }\n\n  if (server.httpServer) {\n    Logger.log(`\n${cyan(`Vivliostyle CLI v${cliVersion}`)}\n${blueBright('â•‘')} ${isUnicodeSupported ? `${randomBookSymbol} ` : ''}Up and running (press Ctrl+C to quit)\n${blueBright('â•™â”€')} ${dim(`Preview URL: ${terminalLink(url, url, { fallback: () => url })}`)}\n`);\n  }\n  return server;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,kBAAkB;AAEzB,SAAS,YAAY,MAAM,WAAW;AAWtC,eAAsB,QAAQ,cAA6C;AACzE,SAAO,cAAc,YAAY;AACjC,SAAO,MAAM,6BAA6B,YAAY;AAEtD,MAAI,oBACD,MAAM,sBAAsB,YAAY,KACzC,qBAAqB,YAAY;AACnC,uBAAqB,iBAAiB;AACtC,sBAAoB,kBAAkB,mBAAmB,YAAY;AACrE,QAAM,EAAE,OAAO,cAAc,IAAI;AACjC,SAAO,MAAM,kCAAkC,iBAAiB;AAGhE,MAAI,SAAS,kBAAkB,MAAM,CAAC,GAAG,aAAa;AACtD,SAAO,MAAM,uBAAuB,MAAM;AAE1C,MAAI;AACJ,MAAI;AACJ;AACE;AAAA;AAAA,YAAMA,KAAI,uBAAO,aAAa,eAAe;AAC7C,YAAM,aAAa,MAAM,kBAAkB;AAAA,QACzC,GAAG;AAAA,QACH,MAAM;AAAA,MACR,CAAC;AACD,eAAS,MAAM,iBAAiB;AAAA,QAC9B;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM;AAAA,MACR,CAAC;AACD,UAAI,OAAO,YAAY;AACrB,cAAM,OAAO,OAAO;AACpB,4BAAoB,YAAY,mBAAmB;AAAA,UACjD,qBAAqB,OAAO;AAAA,UAC5B,QAAQ,OAAO,OAAO;AAAA,QACxB,CAAC;AACD,iBAAS;AAAA,UACP,kBAAkB,MAAM,CAAC;AAAA,UACzB,kBAAkB;AAAA,QACpB;AAAA,MACF;AACA,YAAM,MAAM,iBAAiB,MAAM;AAAA,aAtBnC;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBF;AAEA,MAAI,OAAO,YAAY;AACrB,WAAO,IAAI;AAAA,EACb,KAAK,oBAAoB,UAAU,EAAE,CAAC;AAAA,EACtC,WAAW,QAAG,CAAC,IAAI,qBAAqB,GAAG,gBAAgB,MAAM,EAAE;AAAA,EACnE,WAAW,cAAI,CAAC,IAAI,IAAI,gBAAgB,aAAa,KAAK,KAAK,EAAE,UAAU,MAAM,IAAI,CAAC,CAAC,EAAE,CAAC;AAAA,CAC3F;AAAA,EACC;AACA,SAAO;AACT;","names":["_"]}
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-5JTKT7VK.js b/package/dist/chunk-5JTKT7VK.js
--- a/package/dist/chunk-5JTKT7VK.js	1970-01-01 09:00:00.000000000 +0900
+++ b/package/dist/chunk-5JTKT7VK.js	1985-10-26 17:15:00.000000000 +0900
@@ -0,0 +1,757 @@
+import {
+  resolveViteConfig
+} from "./chunk-XMCTTVR7.js";
+import {
+  buildWebPublication,
+  cleanupWorkspace,
+  compile,
+  createViteServer,
+  getSourceUrl,
+  getViewerFullUrl,
+  isWebPubConfig,
+  launchPreview,
+  loadVivliostyleConfig,
+  mergeConfig,
+  mergeInlineConfig,
+  prepareThemeDirectory,
+  resolveTaskConfig,
+  warnDeprecatedConfig
+} from "./chunk-BYT766IR.js";
+import {
+  importNodeModule
+} from "./chunk-E6QVHS6D.js";
+import {
+  Logger,
+  copyAssets,
+  cwd,
+  exec,
+  isInContainer,
+  isUnicodeSupported,
+  isValidUri,
+  pathEquals,
+  randomBookSymbol,
+  runExitHandlers,
+  setupConfigFromFlags
+} from "./chunk-T2VWLU2I.js";
+import {
+  CONTAINER_LOCAL_HOSTNAME,
+  CONTAINER_ROOT_DIR,
+  coreVersion
+} from "./chunk-ZEBXHUJX.js";
+import {
+  __callDispose,
+  __using
+} from "./chunk-I7BWSAN6.js";
+
+// src/core/build.ts
+import { pathToFileURL as pathToFileURL2 } from "node:url";
+import terminalLink2 from "terminal-link";
+import upath4 from "upath";
+import { build as viteBuild } from "vite";
+import { cyan as cyan2, gray as gray2 } from "yoctocolors";
+
+// src/container.ts
+import process2 from "node:process";
+import { fileURLToPath, pathToFileURL } from "node:url";
+import { x } from "tinyexec";
+import upath from "upath";
+function toContainerPath(urlOrAbsPath) {
+  if (isValidUri(urlOrAbsPath)) {
+    if (urlOrAbsPath.toLowerCase().startsWith("file")) {
+      return pathToFileURL(
+        upath.posix.join(
+          CONTAINER_ROOT_DIR,
+          upath.toUnix(fileURLToPath(urlOrAbsPath)).replace(/^\w:/, "")
+        )
+      ).href;
+    } else {
+      return urlOrAbsPath;
+    }
+  }
+  return upath.posix.join(
+    CONTAINER_ROOT_DIR,
+    upath.toUnix(urlOrAbsPath).replace(/^\w:/, "")
+  );
+}
+function collectVolumeArgs(mountPoints) {
+  return mountPoints.filter((p, i, array) => {
+    if (i !== array.indexOf(p)) {
+      return false;
+    }
+    let parent = p;
+    while (!pathEquals(parent, upath.dirname(parent))) {
+      parent = upath.dirname(parent);
+      if (array.includes(parent)) {
+        return false;
+      }
+    }
+    return true;
+  }).map((p) => `${p}:${toContainerPath(p)}`);
+}
+async function runContainer({
+  image,
+  userVolumeArgs,
+  commandArgs,
+  entrypoint,
+  env,
+  workdir
+}) {
+  const { default: commandExists } = await importNodeModule("command-exists");
+  if (!await commandExists("docker")) {
+    throw new Error(
+      `Docker isn't be installed. To use this feature, you'll need to install Docker.`
+    );
+  }
+  const version = (await exec("docker", ["version", "--format", "{{.Server.Version}}"])).stdout;
+  const [major, minor] = version.split(".").map(Number);
+  if (major < 20 || major === 20 && minor < 10) {
+    throw new Error(
+      `Docker version ${version} is not supported. Please upgrade to Docker 20.10.0 or later.`
+    );
+  }
+  try {
+    var _stack = [];
+    try {
+      const _2 = __using(_stack, Logger.suspendLogging("Launching docker container"));
+      const args = [
+        "run",
+        ...Logger.isInteractive ? ["-it"] : [],
+        "--rm",
+        ...entrypoint ? ["--entrypoint", entrypoint] : [],
+        ...env ? env.flatMap(([k, v]) => ["-e", `${k}=${v}`]) : [],
+        ...process2.env.DEBUG ? ["-e", `DEBUG=${process2.env.DEBUG}`] : [],
+        ...userVolumeArgs.flatMap((arg) => ["-v", arg]),
+        ...workdir ? ["-w", workdir] : [],
+        image,
+        ...commandArgs
+      ];
+      Logger.debug(`docker ${args.join(" ")}`);
+      const proc = x("docker", args, {
+        throwOnError: true,
+        nodeOptions: {
+          stdio: Logger.isInteractive ? "inherit" : void 0
+        }
+      });
+      if (Logger.isInteractive) {
+        await proc;
+      } else {
+        for await (const line of proc) {
+          Logger.log(line);
+        }
+      }
+    } catch (_) {
+      var _error = _, _hasError = true;
+    } finally {
+      __callDispose(_stack, _error, _hasError);
+    }
+  } catch (error) {
+    throw new Error(
+      "An error occurred on the running container. Please see logs above."
+    );
+  }
+}
+async function buildPDFWithContainer({
+  target,
+  config,
+  inlineConfig
+}) {
+  const sourceUrl = new URL(await getSourceUrl(config));
+  if (sourceUrl.origin === config.rootUrl) {
+    sourceUrl.hostname = CONTAINER_LOCAL_HOSTNAME;
+  }
+  const bypassedOption = {
+    ...inlineConfig,
+    input: {
+      format: "webbook",
+      entry: sourceUrl.href
+    },
+    output: [
+      {
+        ...target,
+        path: toContainerPath(target.path)
+      }
+    ],
+    host: CONTAINER_LOCAL_HOSTNAME
+  };
+  await runContainer({
+    image: config.image,
+    userVolumeArgs: collectVolumeArgs([
+      ...typeof config.serverRootDir === "string" ? [config.serverRootDir] : [],
+      upath.dirname(target.path)
+    ]),
+    env: [["VS_CLI_BUILD_PDF_OPTIONS", JSON.stringify(bypassedOption)]],
+    commandArgs: ["build"],
+    workdir: typeof config.serverRootDir === "string" ? toContainerPath(config.serverRootDir) : void 0
+  });
+  return target.path;
+}
+
+// src/output/pdf.ts
+import fs2 from "node:fs";
+import { URL as URL2 } from "node:url";
+import terminalLink from "terminal-link";
+import upath3 from "upath";
+import { cyan, gray, green, red } from "yoctocolors";
+
+// src/output/pdf-postprocess.ts
+import decamelize from "decamelize";
+import fs from "node:fs";
+import os from "node:os";
+import upath2 from "upath";
+import { v1 as uuid } from "uuid";
+var prefixes = {
+  dcterms: "http://purl.org/dc/terms/",
+  meta: "http://idpf.org/epub/vocab/package/meta/#"
+};
+var metaTerms = {
+  title: `${prefixes.dcterms}title`,
+  creator: `${prefixes.dcterms}creator`,
+  description: `${prefixes.dcterms}description`,
+  subject: `${prefixes.dcterms}subject`,
+  contributor: `${prefixes.dcterms}contributor`,
+  language: `${prefixes.dcterms}language`,
+  role: `${prefixes.meta}role`,
+  created: `${prefixes.meta}created`,
+  date: `${prefixes.meta}date`
+};
+async function pressReadyWithContainer({
+  input,
+  output,
+  preflightOption,
+  image
+}) {
+  await runContainer({
+    image,
+    entrypoint: "press-ready",
+    userVolumeArgs: collectVolumeArgs([
+      upath2.dirname(input),
+      upath2.dirname(output)
+    ]),
+    commandArgs: [
+      "build",
+      "-i",
+      toContainerPath(input),
+      "-o",
+      toContainerPath(output),
+      ...preflightOption.map((opt) => `--${decamelize(opt, { separator: "-" })}`).filter((str) => /^[\w-]+/.test(str))
+    ]
+  });
+}
+var PostProcess = class _PostProcess {
+  document;
+  static async load(pdf) {
+    const { PDFDocument } = await importNodeModule("pdf-lib");
+    const document2 = await PDFDocument.load(pdf, { updateMetadata: false });
+    return new _PostProcess(document2);
+  }
+  constructor(document2) {
+    this.document = document2;
+  }
+  async save(output, { preflight, preflightOption, image }) {
+    const input = preflight ? upath2.join(os.tmpdir(), `vivliostyle-cli-${uuid()}.pdf`) : output;
+    const pdf = await this.document.save();
+    await fs.promises.writeFile(input, pdf);
+    if (preflight === "press-ready-local" || preflight === "press-ready" && isInContainer()) {
+      var _stack = [];
+      try {
+        const _3 = __using(_stack, Logger.suspendLogging("Running press-ready"));
+        const { build: build2 } = await importNodeModule("press-ready");
+        await build2({
+          ...preflightOption.reduce((acc, opt) => {
+            const optName = decamelize(opt, { separator: "-" });
+            return optName.startsWith("no-") ? {
+              ...acc,
+              [optName.slice(3)]: false
+            } : {
+              ...acc,
+              [optName]: true
+            };
+          }, {}),
+          input,
+          output
+        });
+      } catch (_) {
+        var _error = _, _hasError = true;
+      } finally {
+        __callDispose(_stack, _error, _hasError);
+      }
+    } else if (preflight === "press-ready") {
+      var _stack2 = [];
+      try {
+        const _3 = __using(_stack2, Logger.suspendLogging("Running press-ready"));
+        await pressReadyWithContainer({
+          input,
+          output,
+          preflightOption,
+          image
+        });
+      } catch (_2) {
+        var _error2 = _2, _hasError2 = true;
+      } finally {
+        __callDispose(_stack2, _error2, _hasError2);
+      }
+    }
+  }
+  async metadata(tree, {
+    pageProgression,
+    browserVersion,
+    viewerCoreVersion,
+    disableCreatorOption
+  } = {}) {
+    const { ReadingDirection } = await importNodeModule("pdf-lib");
+    const title = tree[metaTerms.title]?.[0].v;
+    if (title) {
+      this.document.setTitle(title);
+    }
+    const author = tree[metaTerms.creator]?.map((item) => item.v)?.join("; ");
+    if (author) {
+      this.document.setAuthor(author);
+    }
+    const subject = tree[metaTerms.description]?.[0].v;
+    if (subject) {
+      this.document.setSubject(subject);
+    }
+    const keywords = tree[metaTerms.subject]?.map((item) => item.v);
+    if (keywords) {
+      this.document.setKeywords(keywords);
+    }
+    let creatorOpt = `Vivliostyle.js ${viewerCoreVersion ?? coreVersion}`;
+    if (browserVersion) {
+      creatorOpt += `; ${browserVersion}`;
+    }
+    this.document.setCreator(
+      disableCreatorOption ? "Vivliostyle" : `Vivliostyle (${creatorOpt})`
+    );
+    const language = tree[metaTerms.language]?.[0].v;
+    if (language) {
+      this.document.setLanguage(language);
+    }
+    const creation = (tree[metaTerms.created] || tree[metaTerms.date])?.[0].v;
+    const creationDate = creation && new Date(creation);
+    if (creationDate) {
+      this.document.setCreationDate(creationDate);
+    }
+    if (pageProgression === "rtl") {
+      const viewerPrefs = this.document.catalog.getOrCreateViewerPreferences();
+      viewerPrefs.setReadingDirection(ReadingDirection.R2L);
+    }
+  }
+  async toc(items) {
+    const { PDFDict, PDFHexString, PDFName, PDFNumber } = await importNodeModule("pdf-lib");
+    if (!items || !items.length) {
+      return;
+    }
+    const addRefs = (items2, parentRef) => items2.map((item) => {
+      const ref = this.document.context.nextRef();
+      return {
+        ...item,
+        parentRef,
+        ref,
+        children: addRefs(item.children, ref)
+      };
+    });
+    const countAll = (items2) => items2.reduce((sum, item) => sum + countAll(item.children), items2.length);
+    const addObjectsToPDF = (items2) => {
+      for (const [i, item] of items2.entries()) {
+        const child = PDFDict.withContext(this.document.context);
+        child.set(PDFName.of("Title"), PDFHexString.fromText(item.title));
+        child.set(PDFName.of("Dest"), PDFName.of(item.id));
+        child.set(PDFName.of("Parent"), item.parentRef);
+        const prev = items2[i - 1];
+        if (prev) {
+          child.set(PDFName.of("Prev"), prev.ref);
+        }
+        const next = items2[i + 1];
+        if (next) {
+          child.set(PDFName.of("Next"), next.ref);
+        }
+        if (item.children.length) {
+          child.set(PDFName.of("First"), item.children[0].ref);
+          child.set(
+            PDFName.of("Last"),
+            item.children[item.children.length - 1].ref
+          );
+          child.set(PDFName.of("Count"), PDFNumber.of(countAll(item.children)));
+        }
+        this.document.context.assign(item.ref, child);
+        addObjectsToPDF(item.children);
+      }
+    };
+    const outlineRef = this.document.context.nextRef();
+    const itemsWithRefs = addRefs(items, outlineRef);
+    addObjectsToPDF(itemsWithRefs);
+    const outline = PDFDict.withContext(this.document.context);
+    outline.set(PDFName.of("First"), itemsWithRefs[0].ref);
+    outline.set(
+      PDFName.of("Last"),
+      itemsWithRefs[itemsWithRefs.length - 1].ref
+    );
+    outline.set(PDFName.of("Count"), PDFNumber.of(countAll(itemsWithRefs)));
+    this.document.context.assign(outlineRef, outline);
+    this.document.catalog.set(PDFName.of("Outlines"), outlineRef);
+  }
+  async setPageBoxes(pageSizeData) {
+    if (pageSizeData.length + 1 === this.document.getPageCount()) {
+      this.document.removePage(pageSizeData.length);
+    }
+    if (pageSizeData.length !== this.document.getPageCount()) {
+      return;
+    }
+    for (let i = 0; i < pageSizeData.length; i++) {
+      const page = this.document.getPage(i);
+      const sizeData = pageSizeData[i];
+      if (!sizeData.mediaWidth || !sizeData.mediaHeight || isNaN(sizeData.bleedOffset) || isNaN(sizeData.bleedSize)) {
+        continue;
+      }
+      const yOffset = page.getHeight() - sizeData.mediaHeight;
+      page.setMediaBox(0, yOffset, sizeData.mediaWidth, sizeData.mediaHeight);
+      if (!sizeData.bleedOffset && !sizeData.bleedSize) {
+        continue;
+      }
+      page.setBleedBox(
+        sizeData.bleedOffset,
+        yOffset + sizeData.bleedOffset,
+        sizeData.mediaWidth - sizeData.bleedOffset * 2,
+        sizeData.mediaHeight - sizeData.bleedOffset * 2
+      );
+      const trimOffset = sizeData.bleedOffset + sizeData.bleedSize;
+      page.setTrimBox(
+        trimOffset,
+        yOffset + trimOffset,
+        sizeData.mediaWidth - trimOffset * 2,
+        sizeData.mediaHeight - trimOffset * 2
+      );
+    }
+  }
+};
+
+// src/output/pdf.ts
+async function buildPDF({
+  target,
+  config
+}) {
+  Logger.logUpdate(`Launching PDF build environment`);
+  const viewerFullUrl = await getViewerFullUrl(config);
+  Logger.debug("viewerFullUrl", viewerFullUrl);
+  let lastEntry;
+  function stringifyEntry(entry) {
+    const formattedSourcePath = cyan(
+      entry.source.type === "file" ? upath3.relative(config.entryContextDir, entry.source.pathname) : entry.source.href
+    );
+    return `${terminalLink(
+      formattedSourcePath,
+      entry.source.type === "file" ? `file://${entry.source.pathname}` : entry.source.href,
+      {
+        fallback: () => formattedSourcePath
+      }
+    )} ${entry.title ? gray(entry.title) : ""}`;
+  }
+  function handleEntry(response) {
+    const entry = config.entries.find((entry2) => {
+      if (!("source" in entry2)) {
+        return false;
+      }
+      const url = new URL2(response.url());
+      return url.protocol === "file:" ? pathEquals(entry2.target, url.pathname) : pathEquals(
+        upath3.relative(config.workspaceDir, entry2.target),
+        url.pathname.substring(1)
+      );
+    });
+    if (entry) {
+      if (!lastEntry) {
+        lastEntry = entry;
+        Logger.logUpdate(stringifyEntry(entry));
+        return;
+      }
+      Logger.logSuccess(stringifyEntry(lastEntry));
+      Logger.startLogging(stringifyEntry(entry));
+      lastEntry = entry;
+    }
+  }
+  const { browser, page } = await launchPreview({
+    mode: "build",
+    url: viewerFullUrl,
+    config,
+    onBrowserOpen: () => {
+      Logger.logUpdate("Building pages");
+    },
+    onPageOpen: async (page2) => {
+      page2.on("pageerror", (error) => {
+        Logger.logError(red(error.message));
+      });
+      page2.on("console", (msg) => {
+        switch (msg.type()) {
+          case "error":
+            if (/\/vivliostyle-viewer\.js$/.test(msg.location().url ?? "")) {
+              Logger.logError(msg.text());
+              throw msg.text();
+            }
+            return;
+          case "debug":
+            if (/time slice/.test(msg.text())) {
+              return;
+            }
+            break;
+        }
+        if (msg.type() === "error") {
+          Logger.logVerbose(red("console.error()"), msg.text());
+        } else {
+          Logger.logVerbose(gray(`console.${msg.type()}()`), msg.text());
+        }
+      });
+      page2.on("response", (response) => {
+        Logger.debug(
+          gray("viewer:response"),
+          green(response.status().toString()),
+          response.url()
+        );
+        handleEntry(response);
+        if (300 > response.status() && 200 <= response.status()) return;
+        if (response.url().startsWith("file://") && response.ok()) return;
+        Logger.logError(red(`${response.status()}`), response.url());
+      });
+      await page2.setDefaultTimeout(config.timeout);
+    }
+  });
+  const browserVersion = await browser.version();
+  Logger.debug(green("success"), `browserVersion=${browserVersion}`);
+  let remainTime = config.timeout;
+  const startTime = Date.now();
+  await page.waitForNetworkIdle();
+  await page.waitForFunction(() => !!window.coreViewer);
+  const { protocol } = browser;
+  if (protocol === "cdp") {
+    await page.emulateMediaType("print");
+  }
+  await page.waitForFunction(
+    /* v8 ignore next */
+    () => window.coreViewer.readyState === "complete",
+    { polling: 1e3 }
+  );
+  if (lastEntry) {
+    Logger.logSuccess(stringifyEntry(lastEntry));
+  }
+  const pageProgression = await page.evaluate(
+    () => (
+      /* v8 ignore next 5 */
+      document.querySelector("#vivliostyle-viewer-viewport")?.getAttribute("data-vivliostyle-page-progression") === "rtl" ? "rtl" : "ltr"
+    )
+  );
+  const viewerCoreVersion = await page.evaluate(
+    () => (
+      /* v8 ignore next 3 */
+      document.querySelector("#vivliostyle-menu_settings .version")?.textContent?.replace(/^.*?: (\d[-+.\w]+).*$/, "$1")
+    )
+  );
+  const metadata = await loadMetadata(page);
+  const toc = await loadTOC(page);
+  const pageSizeData = await loadPageSizeData(page);
+  remainTime -= Date.now() - startTime;
+  if (remainTime <= 0) {
+    throw new Error("Typesetting process timed out");
+  }
+  Logger.debug("Remaining timeout:", remainTime);
+  Logger.logUpdate("Building PDF");
+  const dimensionSizeForWebDriverBiDi = parseInt(process.env.VS_CLI_PDF_BUILD_PDF_PAGE_SIZE || "", 10) || 3780;
+  const pdf = await page.pdf({
+    margin: {
+      top: 0,
+      bottom: 0,
+      right: 0,
+      left: 0
+    },
+    printBackground: true,
+    tagged: true,
+    // timeout: remainTime,
+    ...protocol === "webDriverBiDi" ? {
+      width: dimensionSizeForWebDriverBiDi,
+      height: dimensionSizeForWebDriverBiDi
+    } : {
+      preferCSSPageSize: true
+    }
+  });
+  await browser.close();
+  Logger.logUpdate("Processing PDF");
+  fs2.mkdirSync(upath3.dirname(target.path), { recursive: true });
+  const post = await PostProcess.load(pdf);
+  await post.metadata(metadata, {
+    pageProgression,
+    browserVersion,
+    viewerCoreVersion,
+    // If custom viewer is set and its version info is not available,
+    // there is no guarantee that the default creator option is correct.
+    disableCreatorOption: !!config.viewer && !viewerCoreVersion
+  });
+  await post.toc(toc);
+  await post.setPageBoxes(pageSizeData);
+  await post.save(target.path, {
+    preflight: target.preflight,
+    preflightOption: target.preflightOption,
+    image: config.image
+  });
+  return target.path;
+}
+async function loadMetadata(page) {
+  return page.evaluate(() => window.coreViewer.getMetadata());
+}
+async function loadTOC(page) {
+  return page.evaluate(
+    () => new Promise((resolve) => {
+      function listener(payload) {
+        if (payload.a !== "toc") {
+          return;
+        }
+        window.coreViewer.removeListener("done", listener);
+        window.coreViewer.showTOC(false);
+        resolve(window.coreViewer.getTOC());
+      }
+      window.coreViewer.addListener("done", listener);
+      window.coreViewer.showTOC(true);
+    })
+  );
+}
+async function loadPageSizeData(page) {
+  return page.evaluate(() => {
+    const sizeData = [];
+    const pageContainers = document.querySelectorAll(
+      "#vivliostyle-viewer-viewport > div > div > div[data-vivliostyle-page-container]"
+    );
+    for (const pageContainer of pageContainers) {
+      const bleedBox = pageContainer.querySelector(
+        "div[data-vivliostyle-bleed-box]"
+      );
+      sizeData.push({
+        mediaWidth: parseFloat(pageContainer.style.width) * 0.75,
+        mediaHeight: parseFloat(pageContainer.style.height) * 0.75,
+        bleedOffset: parseFloat(bleedBox?.style.left) * 0.75,
+        bleedSize: parseFloat(bleedBox?.style.paddingLeft) * 0.75
+      });
+    }
+    return sizeData;
+  });
+}
+
+// src/core/build.ts
+async function build(inlineConfig, { containerForkMode = false } = {}) {
+  Logger.setLogOptions(inlineConfig);
+  if (containerForkMode) {
+    Logger.setLogPrefix(gray2("[Docker]"));
+  }
+  Logger.debug("build > inlineConfig %O", inlineConfig);
+  let vivliostyleConfig = await loadVivliostyleConfig(inlineConfig) ?? setupConfigFromFlags(inlineConfig);
+  warnDeprecatedConfig(vivliostyleConfig);
+  vivliostyleConfig = mergeInlineConfig(vivliostyleConfig, {
+    ...inlineConfig,
+    quick: false
+  });
+  const { inlineOptions } = vivliostyleConfig;
+  Logger.debug("build > vivliostyleConfig %O", vivliostyleConfig);
+  for (let [i, task] of vivliostyleConfig.tasks.entries()) {
+    var _stack2 = [];
+    try {
+      const _3 = __using(_stack2, Logger.startLogging("Start building"));
+      let config = resolveTaskConfig(task, inlineOptions);
+      Logger.debug("build > config %O", config);
+      const viteConfig = await resolveViteConfig({
+        ...config,
+        mode: "build"
+      });
+      let server;
+      if (!containerForkMode) {
+        Logger.debug("build > viteConfig.configFile %s", viteConfig.configFile);
+        if (viteConfig.configFile && typeof config.serverRootDir === "string") {
+          var _stack = [];
+          try {
+            const _4 = __using(_stack, Logger.suspendLogging("Building Vite project"));
+            await viteBuild({
+              configFile: viteConfig.configFile,
+              root: config.serverRootDir
+            });
+          } catch (_) {
+            var _error = _, _hasError = true;
+          } finally {
+            __callDispose(_stack, _error, _hasError);
+          }
+        }
+        if (!inlineConfig.disableServerStartup) {
+          server = await createViteServer({
+            config,
+            viteConfig,
+            inlineConfig,
+            mode: "build"
+          });
+          if (server.httpServer) {
+            const addressInfo = server.httpServer.address();
+            if (addressInfo && typeof addressInfo !== "string") {
+              const actualPort = addressInfo.port;
+              vivliostyleConfig = mergeConfig(vivliostyleConfig, {
+                temporaryFilePrefix: config.temporaryFilePrefix,
+                server: {
+                  ...server.config.preview,
+                  port: actualPort
+                }
+              });
+              config = resolveTaskConfig(
+                vivliostyleConfig.tasks[i],
+                vivliostyleConfig.inlineOptions
+              );
+            }
+          }
+        }
+        if (isWebPubConfig(config)) {
+          await cleanupWorkspace(config);
+          await prepareThemeDirectory(config);
+          await compile(config);
+          await copyAssets(config);
+        }
+      }
+      for (const target of config.outputs) {
+        let output = null;
+        const { format } = target;
+        if (format === "pdf") {
+          if (!containerForkMode && target.renderMode === "docker") {
+            output = await buildPDFWithContainer({
+              target,
+              config,
+              inlineConfig
+            });
+          } else {
+            output = await buildPDF({ target, config });
+          }
+        } else if (format === "webpub" || format === "epub") {
+          output = await buildWebPublication({ target, config });
+        }
+        if (output && !containerForkMode) {
+          const formattedOutput = cyan2(
+            upath4.relative(inlineConfig.cwd ?? cwd, output)
+          );
+          Logger.logSuccess(
+            `Finished building ${terminalLink2(
+              formattedOutput,
+              pathToFileURL2(output).href,
+              {
+                fallback: () => formattedOutput
+              }
+            )}`
+          );
+        }
+      }
+      await server?.close();
+    } catch (_2) {
+      var _error2 = _2, _hasError2 = true;
+    } finally {
+      __callDispose(_stack2, _error2, _hasError2);
+    }
+  }
+  runExitHandlers();
+  if (!containerForkMode) {
+    const num = vivliostyleConfig.tasks.flatMap((t) => t.output ?? []).length;
+    const symbol = isUnicodeSupported ? `${num > 1 ? "\u{1F4DA}" : randomBookSymbol} ` : "";
+    Logger.log(`${symbol}Built successfully!`);
+  }
+}
+
+export {
+  build
+};
+//# sourceMappingURL=chunk-5JTKT7VK.js.map
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-5JTKT7VK.js.map b/package/dist/chunk-5JTKT7VK.js.map
--- a/package/dist/chunk-5JTKT7VK.js.map	1970-01-01 09:00:00.000000000 +0900
+++ b/package/dist/chunk-5JTKT7VK.js.map	1985-10-26 17:15:00.000000000 +0900
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/core/build.ts","../src/container.ts","../src/output/pdf.ts","../src/output/pdf-postprocess.ts"],"sourcesContent":["import { pathToFileURL } from 'node:url';\nimport terminalLink from 'terminal-link';\nimport upath from 'upath';\nimport { type PreviewServer, build as viteBuild } from 'vite';\nimport { cyan, gray } from 'yoctocolors';\nimport { setupConfigFromFlags } from '../commands/cli-flags.js';\nimport { loadVivliostyleConfig, warnDeprecatedConfig } from '../config/load.js';\nimport { mergeConfig, mergeInlineConfig } from '../config/merge.js';\nimport { isWebPubConfig, resolveTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { resolveViteConfig } from '../config/vite.js';\nimport { buildPDFWithContainer } from '../container.js';\nimport { isUnicodeSupported, Logger, randomBookSymbol } from '../logger.js';\nimport { buildPDF } from '../output/pdf.js';\nimport { buildWebPublication } from '../output/webbook.js';\nimport { copyAssets } from '../processor/asset.js';\nimport {\n  cleanupWorkspace,\n  compile,\n  prepareThemeDirectory,\n} from '../processor/compile.js';\nimport { createViteServer } from '../server.js';\nimport { cwd, runExitHandlers } from '../util.js';\n\nexport async function build(\n  inlineConfig: ParsedVivliostyleInlineConfig,\n  { containerForkMode = false }: { containerForkMode?: boolean } = {},\n) {\n  Logger.setLogOptions(inlineConfig);\n  if (containerForkMode) {\n    Logger.setLogPrefix(gray('[Docker]'));\n  }\n  Logger.debug('build > inlineConfig %O', inlineConfig);\n\n  let vivliostyleConfig =\n    (await loadVivliostyleConfig(inlineConfig)) ??\n    setupConfigFromFlags(inlineConfig);\n  warnDeprecatedConfig(vivliostyleConfig);\n  vivliostyleConfig = mergeInlineConfig(vivliostyleConfig, {\n    ...inlineConfig,\n    quick: false,\n  });\n  const { inlineOptions } = vivliostyleConfig;\n  Logger.debug('build > vivliostyleConfig %O', vivliostyleConfig);\n\n  for (let [i, task] of vivliostyleConfig.tasks.entries()) {\n    using _ = Logger.startLogging('Start building');\n\n    let config = resolveTaskConfig(task, inlineOptions);\n    Logger.debug('build > config %O', config);\n    const viteConfig = await resolveViteConfig({\n      ...config,\n      mode: 'build',\n    });\n\n    let server: PreviewServer | undefined;\n    if (!containerForkMode) {\n      // build dependents first\n      Logger.debug('build > viteConfig.configFile %s', viteConfig.configFile);\n      if (viteConfig.configFile && typeof config.serverRootDir === 'string') {\n        using _ = Logger.suspendLogging('Building Vite project');\n        await viteBuild({\n          configFile: viteConfig.configFile,\n          root: config.serverRootDir,\n        });\n      }\n\n      if (!inlineConfig.disableServerStartup) {\n        server = await createViteServer({\n          config,\n          viteConfig,\n          inlineConfig,\n          mode: 'build',\n        });\n\n        if (server.httpServer) {\n          const addressInfo = server.httpServer.address();\n          if (addressInfo && typeof addressInfo !== 'string') {\n            const actualPort = addressInfo.port;\n            vivliostyleConfig = mergeConfig(vivliostyleConfig, {\n              temporaryFilePrefix: config.temporaryFilePrefix,\n              server: {\n                ...server.config.preview,\n                port: actualPort,\n              },\n            });\n            config = resolveTaskConfig(\n              vivliostyleConfig.tasks[i],\n              vivliostyleConfig.inlineOptions,\n            );\n          }\n        }\n      }\n\n      // build artifacts\n      if (isWebPubConfig(config)) {\n        await cleanupWorkspace(config);\n        await prepareThemeDirectory(config);\n        await compile(config);\n        await copyAssets(config);\n      }\n    }\n\n    // generate files\n    for (const target of config.outputs) {\n      let output: string | null = null;\n      const { format } = target;\n      if (format === 'pdf') {\n        if (!containerForkMode && target.renderMode === 'docker') {\n          output = await buildPDFWithContainer({\n            target,\n            config,\n            inlineConfig,\n          });\n        } else {\n          output = await buildPDF({ target, config });\n        }\n      } else if (format === 'webpub' || format === 'epub') {\n        output = await buildWebPublication({ target, config });\n      }\n      if (output && !containerForkMode) {\n        const formattedOutput = cyan(\n          upath.relative(inlineConfig.cwd ?? cwd, output),\n        );\n        Logger.logSuccess(\n          `Finished building ${terminalLink(\n            formattedOutput,\n            pathToFileURL(output).href,\n            {\n              fallback: () => formattedOutput,\n            },\n          )}`,\n        );\n      }\n    }\n\n    await server?.close();\n  }\n\n  runExitHandlers();\n  if (!containerForkMode) {\n    const num = vivliostyleConfig.tasks.flatMap((t) => t.output ?? []).length;\n    const symbol = isUnicodeSupported\n      ? `${num > 1 ? 'ðŸ“š' : randomBookSymbol} `\n      : '';\n    Logger.log(`${symbol}Built successfully!`);\n  }\n}\n","import process from 'node:process';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport { x } from 'tinyexec';\nimport upath from 'upath';\nimport type { PdfOutput, ResolvedTaskConfig } from './config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from './config/schema.js';\nimport { CONTAINER_LOCAL_HOSTNAME, CONTAINER_ROOT_DIR } from './const.js';\nimport { Logger } from './logger.js';\nimport { importNodeModule } from './node-modules.js';\nimport { getSourceUrl } from './server.js';\nimport { exec, isValidUri, pathEquals } from './util.js';\n\nexport function toContainerPath(urlOrAbsPath: string): string {\n  if (isValidUri(urlOrAbsPath)) {\n    if (urlOrAbsPath.toLowerCase().startsWith('file')) {\n      return pathToFileURL(\n        upath.posix.join(\n          CONTAINER_ROOT_DIR,\n          upath.toUnix(fileURLToPath(urlOrAbsPath)).replace(/^\\w:/, ''),\n        ),\n      ).href;\n    } else {\n      return urlOrAbsPath;\n    }\n  }\n  return upath.posix.join(\n    CONTAINER_ROOT_DIR,\n    upath.toUnix(urlOrAbsPath).replace(/^\\w:/, ''),\n  );\n}\n\nexport function collectVolumeArgs(mountPoints: string[]): string[] {\n  return mountPoints\n    .filter((p, i, array) => {\n      if (i !== array.indexOf(p)) {\n        // duplicated path\n        return false;\n      }\n      let parent = p;\n      while (!pathEquals(parent, upath.dirname(parent))) {\n        parent = upath.dirname(parent);\n        if (array.includes(parent)) {\n          // other mount point contains its directory\n          return false;\n        }\n      }\n      return true;\n    })\n    .map((p) => `${p}:${toContainerPath(p)}`);\n}\n\nexport async function runContainer({\n  image,\n  userVolumeArgs,\n  commandArgs,\n  entrypoint,\n  env,\n  workdir,\n}: {\n  image: string;\n  userVolumeArgs: string[];\n  commandArgs: string[];\n  entrypoint?: string;\n  env?: [string, string][];\n  workdir?: string;\n}) {\n  const { default: commandExists } = await importNodeModule('command-exists');\n  if (!(await commandExists('docker'))) {\n    throw new Error(\n      `Docker isn't be installed. To use this feature, you'll need to install Docker.`,\n    );\n  }\n  const version = (\n    await exec('docker', ['version', '--format', '{{.Server.Version}}'])\n  ).stdout;\n  const [major, minor] = version.split('.').map(Number);\n  if (major < 20 || (major === 20 && minor < 10)) {\n    throw new Error(\n      `Docker version ${version} is not supported. Please upgrade to Docker 20.10.0 or later.`,\n    );\n  }\n\n  try {\n    using _ = Logger.suspendLogging('Launching docker container');\n    const args = [\n      'run',\n      ...(Logger.isInteractive ? ['-it'] : []),\n      '--rm',\n      ...(entrypoint ? ['--entrypoint', entrypoint] : []),\n      ...(env ? env.flatMap(([k, v]) => ['-e', `${k}=${v}`]) : []),\n      ...(process.env.DEBUG\n        ? ['-e', `DEBUG=${process.env.DEBUG}`] // escape seems to work well\n        : []),\n      ...userVolumeArgs.flatMap((arg) => ['-v', arg]),\n      ...(workdir ? ['-w', workdir] : []),\n      image,\n      ...commandArgs,\n    ];\n    Logger.debug(`docker ${args.join(' ')}`);\n    const proc = x('docker', args, {\n      throwOnError: true,\n      nodeOptions: {\n        stdio: Logger.isInteractive ? 'inherit' : undefined,\n      },\n    });\n    if (Logger.isInteractive) {\n      await proc;\n    } else {\n      for await (const line of proc) {\n        Logger.log(line);\n      }\n    }\n  } catch (error) {\n    throw new Error(\n      'An error occurred on the running container. Please see logs above.',\n    );\n  }\n}\n\nexport async function buildPDFWithContainer({\n  target,\n  config,\n  inlineConfig,\n}: {\n  target: PdfOutput;\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): Promise<string | null> {\n  const sourceUrl = new URL(await getSourceUrl(config));\n  if (sourceUrl.origin === config.rootUrl) {\n    sourceUrl.hostname = CONTAINER_LOCAL_HOSTNAME;\n  }\n  const bypassedOption = {\n    ...inlineConfig,\n    input: {\n      format: 'webbook',\n      entry: sourceUrl.href,\n    },\n    output: [\n      {\n        ...target,\n        path: toContainerPath(target.path),\n      },\n    ],\n    host: CONTAINER_LOCAL_HOSTNAME,\n  } satisfies ParsedVivliostyleInlineConfig;\n\n  await runContainer({\n    image: config.image,\n    userVolumeArgs: collectVolumeArgs([\n      ...(typeof config.serverRootDir === 'string'\n        ? [config.serverRootDir]\n        : []),\n      upath.dirname(target.path),\n    ]),\n    env: [['VS_CLI_BUILD_PDF_OPTIONS', JSON.stringify(bypassedOption)]],\n    commandArgs: ['build'],\n    workdir:\n      typeof config.serverRootDir === 'string'\n        ? toContainerPath(config.serverRootDir)\n        : undefined,\n  });\n\n  return target.path;\n}\n","import fs from 'node:fs';\nimport { URL } from 'node:url';\nimport type { Browser, Page } from 'puppeteer-core';\nimport terminalLink from 'terminal-link';\nimport upath from 'upath';\nimport { cyan, gray, green, red } from 'yoctocolors';\nimport { launchPreview } from '../browser.js';\nimport type {\n  ManuscriptEntry,\n  PdfOutput,\n  ResolvedTaskConfig,\n} from '../config/resolve.js';\nimport type { Meta, Payload, TOCItem } from '../global-viewer.js';\nimport { Logger } from '../logger.js';\nimport { getViewerFullUrl } from '../server.js';\nimport { pathEquals } from '../util.js';\nimport { type PageSizeData, PostProcess } from './pdf-postprocess.js';\n\nexport async function buildPDF({\n  target,\n  config,\n}: {\n  target: PdfOutput;\n  config: ResolvedTaskConfig;\n}): Promise<string | null> {\n  Logger.logUpdate(`Launching PDF build environment`);\n\n  const viewerFullUrl = await getViewerFullUrl(config);\n  Logger.debug('viewerFullUrl', viewerFullUrl);\n\n  let lastEntry: ManuscriptEntry | undefined;\n\n  function stringifyEntry(entry: ManuscriptEntry) {\n    const formattedSourcePath = cyan(\n      entry.source.type === 'file'\n        ? upath.relative(config.entryContextDir, entry.source.pathname)\n        : entry.source.href,\n    );\n    return `${terminalLink(\n      formattedSourcePath,\n      entry.source.type === 'file'\n        ? `file://${entry.source.pathname}`\n        : entry.source.href,\n      {\n        fallback: () => formattedSourcePath,\n      },\n    )} ${entry.title ? gray(entry.title) : ''}`;\n  }\n\n  function handleEntry(response: any) {\n    const entry = config.entries.find((entry): entry is ManuscriptEntry => {\n      if (!('source' in entry)) {\n        return false;\n      }\n      const url = new URL(response.url());\n      return url.protocol === 'file:'\n        ? pathEquals(entry.target, url.pathname)\n        : pathEquals(\n            upath.relative(config.workspaceDir, entry.target),\n            url.pathname.substring(1),\n          );\n    });\n    if (entry) {\n      if (!lastEntry) {\n        lastEntry = entry;\n        Logger.logUpdate(stringifyEntry(entry));\n        return;\n      }\n      Logger.logSuccess(stringifyEntry(lastEntry));\n      Logger.startLogging(stringifyEntry(entry));\n      lastEntry = entry;\n    }\n  }\n\n  const { browser, page } = await launchPreview({\n    mode: 'build',\n    url: viewerFullUrl,\n    config,\n    onBrowserOpen: () => {\n      Logger.logUpdate('Building pages');\n    },\n    onPageOpen: async (page) => {\n      page.on('pageerror', (error) => {\n        Logger.logError(red((error as Error).message));\n      });\n\n      page.on('console', (msg) => {\n        switch (msg.type()) {\n          case 'error':\n            if (/\\/vivliostyle-viewer\\.js$/.test(msg.location().url ?? '')) {\n              Logger.logError(msg.text());\n              throw msg.text();\n            }\n            return;\n          case 'debug':\n            if (/time slice/.test(msg.text())) {\n              return;\n            }\n            break;\n        }\n        if (msg.type() === 'error') {\n          Logger.logVerbose(red('console.error()'), msg.text());\n        } else {\n          Logger.logVerbose(gray(`console.${msg.type()}()`), msg.text());\n        }\n      });\n\n      page.on('response', (response) => {\n        Logger.debug(\n          gray('viewer:response'),\n          green(response.status().toString()),\n          response.url(),\n        );\n\n        handleEntry(response);\n\n        if (300 > response.status() && 200 <= response.status()) return;\n        // file protocol doesn't have status code\n        if (response.url().startsWith('file://') && response.ok()) return;\n\n        Logger.logError(red(`${response.status()}`), response.url());\n      });\n\n      await page.setDefaultTimeout(config.timeout);\n    },\n  });\n\n  const browserVersion = await browser.version();\n  Logger.debug(green('success'), `browserVersion=${browserVersion}`);\n\n  let remainTime = config.timeout;\n  const startTime = Date.now();\n\n  await page.waitForNetworkIdle();\n  await page.waitForFunction(() => !!window.coreViewer);\n\n  const { protocol } = browser as Browser & {\n    protocol: 'cdp' | 'webDriverBiDi';\n  };\n  // Only CDP supports emulateMediaType\n  if (protocol === 'cdp') {\n    await page.emulateMediaType('print');\n  }\n  await page.waitForFunction(\n    /* v8 ignore next */\n    () => window.coreViewer.readyState === 'complete',\n    { polling: 1000 },\n  );\n\n  if (lastEntry) {\n    Logger.logSuccess(stringifyEntry(lastEntry));\n  }\n\n  const pageProgression = await page.evaluate(() =>\n    /* v8 ignore next 5 */\n    document\n      .querySelector('#vivliostyle-viewer-viewport')\n      ?.getAttribute('data-vivliostyle-page-progression') === 'rtl'\n      ? 'rtl'\n      : 'ltr',\n  );\n  const viewerCoreVersion = await page.evaluate(() =>\n    /* v8 ignore next 3 */\n    document\n      .querySelector('#vivliostyle-menu_settings .version')\n      ?.textContent?.replace(/^.*?: (\\d[-+.\\w]+).*$/, '$1'),\n  );\n  const metadata = await loadMetadata(page);\n  const toc = await loadTOC(page);\n  const pageSizeData = await loadPageSizeData(page);\n\n  remainTime -= Date.now() - startTime;\n  if (remainTime <= 0) {\n    throw new Error('Typesetting process timed out');\n  }\n  Logger.debug('Remaining timeout:', remainTime);\n\n  Logger.logUpdate('Building PDF');\n\n  // For Firefox WebDriver BiDi, explicitly set width and height\n  // because page.pdf() doesn't support for the preferCSSPageSize option.\n  // Use a sufficiently large value to accommodate user-defined page sizes.\n  const dimensionSizeForWebDriverBiDi =\n    parseInt(process.env.VS_CLI_PDF_BUILD_PDF_PAGE_SIZE || '', 10) || 3780; // 1000mm\n  const pdf = await page.pdf({\n    margin: {\n      top: 0,\n      bottom: 0,\n      right: 0,\n      left: 0,\n    },\n    printBackground: true,\n    tagged: true,\n    // timeout: remainTime,\n    ...(protocol === 'webDriverBiDi'\n      ? {\n          width: dimensionSizeForWebDriverBiDi,\n          height: dimensionSizeForWebDriverBiDi,\n        }\n      : {\n          preferCSSPageSize: true,\n        }),\n  });\n\n  await browser.close();\n\n  Logger.logUpdate('Processing PDF');\n  fs.mkdirSync(upath.dirname(target.path), { recursive: true });\n\n  const post = await PostProcess.load(pdf);\n  await post.metadata(metadata, {\n    pageProgression,\n    browserVersion,\n    viewerCoreVersion,\n    // If custom viewer is set and its version info is not available,\n    // there is no guarantee that the default creator option is correct.\n    disableCreatorOption: !!config.viewer && !viewerCoreVersion,\n  });\n  await post.toc(toc);\n  await post.setPageBoxes(pageSizeData);\n  await post.save(target.path, {\n    preflight: target.preflight,\n    preflightOption: target.preflightOption,\n    image: config.image,\n  });\n\n  return target.path;\n}\n\nasync function loadMetadata(page: Page): Promise<Meta> {\n  return page.evaluate(() => window.coreViewer.getMetadata());\n}\n\n// Show and hide the TOC in order to read its contents.\n// Chromium needs to see the TOC links in the DOM to add\n// the PDF destinations used during postprocessing.\nasync function loadTOC(page: Page): Promise<TOCItem[]> {\n  /* v8 ignore start */\n  return page.evaluate(\n    () =>\n      new Promise<TOCItem[]>((resolve) => {\n        function listener(payload: Payload) {\n          if (payload.a !== 'toc') {\n            return;\n          }\n          window.coreViewer.removeListener('done', listener);\n          window.coreViewer.showTOC(false);\n          resolve(window.coreViewer.getTOC());\n        }\n        window.coreViewer.addListener('done', listener);\n        window.coreViewer.showTOC(true);\n      }),\n  );\n  /* v8 ignore stop */\n}\n\nasync function loadPageSizeData(page: Page): Promise<PageSizeData[]> {\n  /* v8 ignore start */\n  return page.evaluate(() => {\n    const sizeData: PageSizeData[] = [];\n    const pageContainers = document.querySelectorAll(\n      '#vivliostyle-viewer-viewport > div > div > div[data-vivliostyle-page-container]',\n    ) as NodeListOf<HTMLElement>;\n\n    for (const pageContainer of pageContainers) {\n      const bleedBox = pageContainer.querySelector(\n        'div[data-vivliostyle-bleed-box]',\n      ) as HTMLElement;\n      sizeData.push({\n        mediaWidth: parseFloat(pageContainer.style.width) * 0.75,\n        mediaHeight: parseFloat(pageContainer.style.height) * 0.75,\n        bleedOffset: parseFloat(bleedBox?.style.left) * 0.75,\n        bleedSize: parseFloat(bleedBox?.style.paddingLeft) * 0.75,\n      });\n    }\n    return sizeData;\n  });\n  /* v8 ignore stop */\n}\n","import decamelize from 'decamelize';\nimport fs from 'node:fs';\nimport os from 'node:os';\nimport type { PDFDocument, PDFRef } from 'pdf-lib';\nimport upath from 'upath';\nimport { v1 as uuid } from 'uuid';\nimport type { PdfOutput, ResolvedTaskConfig } from '../config/resolve.js';\nimport { coreVersion } from '../const.js';\nimport {\n  collectVolumeArgs,\n  runContainer,\n  toContainerPath,\n} from '../container.js';\nimport type { Meta, TOCItem } from '../global-viewer.js';\nimport { Logger } from '../logger.js';\nimport { importNodeModule } from '../node-modules.js';\nimport { isInContainer } from '../util.js';\n\nexport type SaveOption = Pick<PdfOutput, 'preflight' | 'preflightOption'> &\n  Pick<ResolvedTaskConfig, 'image'>;\n\nconst prefixes = {\n  dcterms: 'http://purl.org/dc/terms/',\n  meta: 'http://idpf.org/epub/vocab/package/meta/#',\n};\n\nconst metaTerms = {\n  title: `${prefixes.dcterms}title`,\n  creator: `${prefixes.dcterms}creator`,\n  description: `${prefixes.dcterms}description`,\n  subject: `${prefixes.dcterms}subject`,\n  contributor: `${prefixes.dcterms}contributor`,\n  language: `${prefixes.dcterms}language`,\n  role: `${prefixes.meta}role`,\n  created: `${prefixes.meta}created`,\n  date: `${prefixes.meta}date`,\n};\n\ninterface PDFTocItem extends TOCItem {\n  children: PDFTocItem[];\n  ref: PDFRef;\n  parentRef: PDFRef;\n}\n\nexport interface PageSizeData {\n  mediaWidth: number;\n  mediaHeight: number;\n  bleedOffset: number;\n  bleedSize: number;\n}\n\nexport async function pressReadyWithContainer({\n  input,\n  output,\n  preflightOption,\n  image,\n}: {\n  input: string;\n  output: string;\n  preflightOption: string[];\n  image: string;\n}) {\n  await runContainer({\n    image,\n    entrypoint: 'press-ready',\n    userVolumeArgs: collectVolumeArgs([\n      upath.dirname(input),\n      upath.dirname(output),\n    ]),\n    commandArgs: [\n      'build',\n      '-i',\n      toContainerPath(input),\n      '-o',\n      toContainerPath(output),\n      ...preflightOption\n        .map((opt) => `--${decamelize(opt, { separator: '-' })}`)\n        .filter((str) => /^[\\w-]+/.test(str)),\n    ],\n  });\n}\n\nexport class PostProcess {\n  protected readonly document: PDFDocument;\n\n  static async load(pdf: Uint8Array): Promise<PostProcess> {\n    const { PDFDocument } = await importNodeModule('pdf-lib');\n    const document = await PDFDocument.load(pdf, { updateMetadata: false });\n    return new PostProcess(document);\n  }\n\n  protected constructor(document: PDFDocument) {\n    this.document = document;\n  }\n\n  async save(\n    output: string,\n    { preflight, preflightOption, image }: SaveOption,\n  ) {\n    const input = preflight\n      ? upath.join(os.tmpdir(), `vivliostyle-cli-${uuid()}.pdf`)\n      : output;\n\n    const pdf = await this.document.save();\n    await fs.promises.writeFile(input, pdf);\n\n    if (\n      preflight === 'press-ready-local' ||\n      (preflight === 'press-ready' && isInContainer())\n    ) {\n      using _ = Logger.suspendLogging('Running press-ready');\n      const { build } = await importNodeModule('press-ready');\n      await build({\n        ...preflightOption.reduce((acc, opt) => {\n          const optName = decamelize(opt, { separator: '-' });\n          return optName.startsWith('no-')\n            ? {\n                ...acc,\n                [optName.slice(3)]: false,\n              }\n            : {\n                ...acc,\n                [optName]: true,\n              };\n        }, {}),\n        input,\n        output,\n      });\n    } else if (preflight === 'press-ready') {\n      using _ = Logger.suspendLogging('Running press-ready');\n      await pressReadyWithContainer({\n        input,\n        output,\n        preflightOption,\n        image,\n      });\n    }\n  }\n\n  async metadata(\n    tree: Meta,\n    {\n      pageProgression,\n      browserVersion,\n      viewerCoreVersion,\n      disableCreatorOption,\n    }: {\n      pageProgression?: 'ltr' | 'rtl';\n      browserVersion?: string;\n      viewerCoreVersion?: string;\n      disableCreatorOption?: boolean;\n    } = {},\n  ) {\n    const { ReadingDirection } = await importNodeModule('pdf-lib');\n    const title = tree[metaTerms.title]?.[0].v;\n    if (title) {\n      this.document.setTitle(title);\n    }\n\n    const author = tree[metaTerms.creator]?.map((item) => item.v)?.join('; ');\n    if (author) {\n      this.document.setAuthor(author);\n    }\n\n    const subject = tree[metaTerms.description]?.[0].v;\n    if (subject) {\n      this.document.setSubject(subject);\n    }\n\n    const keywords = tree[metaTerms.subject]?.map((item) => item.v);\n    if (keywords) {\n      this.document.setKeywords(keywords);\n    }\n\n    let creatorOpt = `Vivliostyle.js ${viewerCoreVersion ?? coreVersion}`;\n    if (browserVersion) {\n      creatorOpt += `; ${browserVersion}`;\n    }\n    this.document.setCreator(\n      disableCreatorOption ? 'Vivliostyle' : `Vivliostyle (${creatorOpt})`,\n    );\n\n    const language = tree[metaTerms.language]?.[0].v;\n    if (language) {\n      this.document.setLanguage(language);\n    }\n\n    const creation = (tree[metaTerms.created] || tree[metaTerms.date])?.[0].v;\n    const creationDate = creation && new Date(creation);\n    if (creationDate) {\n      this.document.setCreationDate(creationDate);\n    }\n    if (pageProgression === 'rtl') {\n      const viewerPrefs = this.document.catalog.getOrCreateViewerPreferences();\n      viewerPrefs.setReadingDirection(ReadingDirection.R2L);\n    }\n  }\n\n  async toc(items: TOCItem[]) {\n    const { PDFDict, PDFHexString, PDFName, PDFNumber } =\n      await importNodeModule('pdf-lib');\n    if (!items || !items.length) {\n      return;\n    }\n\n    const addRefs = (items: TOCItem[], parentRef: PDFRef): PDFTocItem[] =>\n      items.map((item) => {\n        const ref = this.document.context.nextRef();\n        return {\n          ...item,\n          parentRef,\n          ref,\n          children: addRefs(item.children, ref),\n        };\n      });\n    const countAll = (items: PDFTocItem[]): number =>\n      items.reduce((sum, item) => sum + countAll(item.children), items.length);\n    const addObjectsToPDF = (items: PDFTocItem[]) => {\n      for (const [i, item] of items.entries()) {\n        const child = PDFDict.withContext(this.document.context);\n        child.set(PDFName.of('Title'), PDFHexString.fromText(item.title));\n        child.set(PDFName.of('Dest'), PDFName.of(item.id));\n        child.set(PDFName.of('Parent'), item.parentRef);\n        const prev = items[i - 1];\n        if (prev) {\n          child.set(PDFName.of('Prev'), prev.ref);\n        }\n        const next = items[i + 1];\n        if (next) {\n          child.set(PDFName.of('Next'), next.ref);\n        }\n        if (item.children.length) {\n          child.set(PDFName.of('First'), item.children[0].ref);\n          child.set(\n            PDFName.of('Last'),\n            item.children[item.children.length - 1].ref,\n          );\n          child.set(PDFName.of('Count'), PDFNumber.of(countAll(item.children)));\n        }\n        this.document.context.assign(item.ref, child);\n        addObjectsToPDF(item.children);\n      }\n    };\n\n    const outlineRef = this.document.context.nextRef();\n    const itemsWithRefs = addRefs(items, outlineRef);\n    addObjectsToPDF(itemsWithRefs);\n\n    const outline = PDFDict.withContext(this.document.context);\n    outline.set(PDFName.of('First'), itemsWithRefs[0].ref);\n    outline.set(\n      PDFName.of('Last'),\n      itemsWithRefs[itemsWithRefs.length - 1].ref,\n    );\n    outline.set(PDFName.of('Count'), PDFNumber.of(countAll(itemsWithRefs)));\n    this.document.context.assign(outlineRef, outline);\n    this.document.catalog.set(PDFName.of('Outlines'), outlineRef);\n  }\n\n  async setPageBoxes(pageSizeData: PageSizeData[]) {\n    if (pageSizeData.length + 1 === this.document.getPageCount()) {\n      // fix issue #312: Chromium LayoutNGPrinting adds unnecessary blank page\n      this.document.removePage(pageSizeData.length);\n    }\n    if (pageSizeData.length !== this.document.getPageCount()) {\n      return;\n    }\n    for (let i = 0; i < pageSizeData.length; i++) {\n      const page = this.document.getPage(i);\n      const sizeData = pageSizeData[i];\n      if (\n        !sizeData.mediaWidth ||\n        !sizeData.mediaHeight ||\n        isNaN(sizeData.bleedOffset) ||\n        isNaN(sizeData.bleedSize)\n      ) {\n        continue;\n      }\n      const yOffset = page.getHeight() - sizeData.mediaHeight;\n      page.setMediaBox(0, yOffset, sizeData.mediaWidth, sizeData.mediaHeight);\n      if (!sizeData.bleedOffset && !sizeData.bleedSize) {\n        continue;\n      }\n      page.setBleedBox(\n        sizeData.bleedOffset,\n        yOffset + sizeData.bleedOffset,\n        sizeData.mediaWidth - sizeData.bleedOffset * 2,\n        sizeData.mediaHeight - sizeData.bleedOffset * 2,\n      );\n      const trimOffset = sizeData.bleedOffset + sizeData.bleedSize;\n      page.setTrimBox(\n        trimOffset,\n        yOffset + trimOffset,\n        sizeData.mediaWidth - trimOffset * 2,\n        sizeData.mediaHeight - trimOffset * 2,\n      );\n    }\n  }\n}\n"],"mappings":"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","names":["pathToFileURL","terminalLink","upath","cyan","gray","process","_","process","fs","URL","upath","upath","upath","document","_","build","_stack","_error","_hasError","items","upath","entry","URL","page","fs","gray","_stack","_","cyan","upath","terminalLink","pathToFileURL","_error","_hasError"]}
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-5MEUINC4.js b/package/dist/chunk-5MEUINC4.js
--- a/package/dist/chunk-5MEUINC4.js	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/chunk-5MEUINC4.js	1970-01-01 09:00:00.000000000 +0900
@@ -1,757 +0,0 @@
-import {
-  resolveViteConfig
-} from "./chunk-XMCTTVR7.js";
-import {
-  buildWebPublication,
-  cleanupWorkspace,
-  compile,
-  createViteServer,
-  getSourceUrl,
-  getViewerFullUrl,
-  isWebPubConfig,
-  launchPreview,
-  loadVivliostyleConfig,
-  mergeConfig,
-  mergeInlineConfig,
-  prepareThemeDirectory,
-  resolveTaskConfig,
-  warnDeprecatedConfig
-} from "./chunk-BR2V7MHE.js";
-import {
-  importNodeModule
-} from "./chunk-E6QVHS6D.js";
-import {
-  Logger,
-  copyAssets,
-  cwd,
-  exec,
-  isInContainer,
-  isUnicodeSupported,
-  isValidUri,
-  pathEquals,
-  randomBookSymbol,
-  runExitHandlers,
-  setupConfigFromFlags
-} from "./chunk-T2VWLU2I.js";
-import {
-  CONTAINER_LOCAL_HOSTNAME,
-  CONTAINER_ROOT_DIR,
-  coreVersion
-} from "./chunk-ZEBXHUJX.js";
-import {
-  __callDispose,
-  __using
-} from "./chunk-I7BWSAN6.js";
-
-// src/core/build.ts
-import { pathToFileURL as pathToFileURL2 } from "node:url";
-import terminalLink2 from "terminal-link";
-import upath4 from "upath";
-import { build as viteBuild } from "vite";
-import { cyan as cyan2, gray as gray2 } from "yoctocolors";
-
-// src/container.ts
-import process2 from "node:process";
-import { fileURLToPath, pathToFileURL } from "node:url";
-import { x } from "tinyexec";
-import upath from "upath";
-function toContainerPath(urlOrAbsPath) {
-  if (isValidUri(urlOrAbsPath)) {
-    if (urlOrAbsPath.toLowerCase().startsWith("file")) {
-      return pathToFileURL(
-        upath.posix.join(
-          CONTAINER_ROOT_DIR,
-          upath.toUnix(fileURLToPath(urlOrAbsPath)).replace(/^\w:/, "")
-        )
-      ).href;
-    } else {
-      return urlOrAbsPath;
-    }
-  }
-  return upath.posix.join(
-    CONTAINER_ROOT_DIR,
-    upath.toUnix(urlOrAbsPath).replace(/^\w:/, "")
-  );
-}
-function collectVolumeArgs(mountPoints) {
-  return mountPoints.filter((p, i, array) => {
-    if (i !== array.indexOf(p)) {
-      return false;
-    }
-    let parent = p;
-    while (!pathEquals(parent, upath.dirname(parent))) {
-      parent = upath.dirname(parent);
-      if (array.includes(parent)) {
-        return false;
-      }
-    }
-    return true;
-  }).map((p) => `${p}:${toContainerPath(p)}`);
-}
-async function runContainer({
-  image,
-  userVolumeArgs,
-  commandArgs,
-  entrypoint,
-  env,
-  workdir
-}) {
-  const { default: commandExists } = await importNodeModule("command-exists");
-  if (!await commandExists("docker")) {
-    throw new Error(
-      `Docker isn't be installed. To use this feature, you'll need to install Docker.`
-    );
-  }
-  const version = (await exec("docker", ["version", "--format", "{{.Server.Version}}"])).stdout;
-  const [major, minor] = version.split(".").map(Number);
-  if (major < 20 || major === 20 && minor < 10) {
-    throw new Error(
-      `Docker version ${version} is not supported. Please upgrade to Docker 20.10.0 or later.`
-    );
-  }
-  try {
-    var _stack = [];
-    try {
-      const _2 = __using(_stack, Logger.suspendLogging("Launching docker container"));
-      const args = [
-        "run",
-        ...Logger.isInteractive ? ["-it"] : [],
-        "--rm",
-        ...entrypoint ? ["--entrypoint", entrypoint] : [],
-        ...env ? env.flatMap(([k, v]) => ["-e", `${k}=${v}`]) : [],
-        ...process2.env.DEBUG ? ["-e", `DEBUG=${process2.env.DEBUG}`] : [],
-        ...userVolumeArgs.flatMap((arg) => ["-v", arg]),
-        ...workdir ? ["-w", workdir] : [],
-        image,
-        ...commandArgs
-      ];
-      Logger.debug(`docker ${args.join(" ")}`);
-      const proc = x("docker", args, {
-        throwOnError: true,
-        nodeOptions: {
-          stdio: Logger.isInteractive ? "inherit" : void 0
-        }
-      });
-      if (Logger.isInteractive) {
-        await proc;
-      } else {
-        for await (const line of proc) {
-          Logger.log(line);
-        }
-      }
-    } catch (_) {
-      var _error = _, _hasError = true;
-    } finally {
-      __callDispose(_stack, _error, _hasError);
-    }
-  } catch (error) {
-    throw new Error(
-      "An error occurred on the running container. Please see logs above."
-    );
-  }
-}
-async function buildPDFWithContainer({
-  target,
-  config,
-  inlineConfig
-}) {
-  const sourceUrl = new URL(await getSourceUrl(config));
-  if (sourceUrl.origin === config.rootUrl) {
-    sourceUrl.hostname = CONTAINER_LOCAL_HOSTNAME;
-  }
-  const bypassedOption = {
-    ...inlineConfig,
-    input: {
-      format: "webbook",
-      entry: sourceUrl.href
-    },
-    output: [
-      {
-        ...target,
-        path: toContainerPath(target.path)
-      }
-    ],
-    host: CONTAINER_LOCAL_HOSTNAME
-  };
-  await runContainer({
-    image: config.image,
-    userVolumeArgs: collectVolumeArgs([
-      ...typeof config.serverRootDir === "string" ? [config.serverRootDir] : [],
-      upath.dirname(target.path)
-    ]),
-    env: [["VS_CLI_BUILD_PDF_OPTIONS", JSON.stringify(bypassedOption)]],
-    commandArgs: ["build"],
-    workdir: typeof config.serverRootDir === "string" ? toContainerPath(config.serverRootDir) : void 0
-  });
-  return target.path;
-}
-
-// src/output/pdf.ts
-import fs2 from "node:fs";
-import { URL as URL2 } from "node:url";
-import terminalLink from "terminal-link";
-import upath3 from "upath";
-import { cyan, gray, green, red } from "yoctocolors";
-
-// src/output/pdf-postprocess.ts
-import decamelize from "decamelize";
-import fs from "node:fs";
-import os from "node:os";
-import upath2 from "upath";
-import { v1 as uuid } from "uuid";
-var prefixes = {
-  dcterms: "http://purl.org/dc/terms/",
-  meta: "http://idpf.org/epub/vocab/package/meta/#"
-};
-var metaTerms = {
-  title: `${prefixes.dcterms}title`,
-  creator: `${prefixes.dcterms}creator`,
-  description: `${prefixes.dcterms}description`,
-  subject: `${prefixes.dcterms}subject`,
-  contributor: `${prefixes.dcterms}contributor`,
-  language: `${prefixes.dcterms}language`,
-  role: `${prefixes.meta}role`,
-  created: `${prefixes.meta}created`,
-  date: `${prefixes.meta}date`
-};
-async function pressReadyWithContainer({
-  input,
-  output,
-  preflightOption,
-  image
-}) {
-  await runContainer({
-    image,
-    entrypoint: "press-ready",
-    userVolumeArgs: collectVolumeArgs([
-      upath2.dirname(input),
-      upath2.dirname(output)
-    ]),
-    commandArgs: [
-      "build",
-      "-i",
-      toContainerPath(input),
-      "-o",
-      toContainerPath(output),
-      ...preflightOption.map((opt) => `--${decamelize(opt, { separator: "-" })}`).filter((str) => /^[\w-]+/.test(str))
-    ]
-  });
-}
-var PostProcess = class _PostProcess {
-  document;
-  static async load(pdf) {
-    const { PDFDocument } = await importNodeModule("pdf-lib");
-    const document2 = await PDFDocument.load(pdf, { updateMetadata: false });
-    return new _PostProcess(document2);
-  }
-  constructor(document2) {
-    this.document = document2;
-  }
-  async save(output, { preflight, preflightOption, image }) {
-    const input = preflight ? upath2.join(os.tmpdir(), `vivliostyle-cli-${uuid()}.pdf`) : output;
-    const pdf = await this.document.save();
-    await fs.promises.writeFile(input, pdf);
-    if (preflight === "press-ready-local" || preflight === "press-ready" && isInContainer()) {
-      var _stack = [];
-      try {
-        const _3 = __using(_stack, Logger.suspendLogging("Running press-ready"));
-        const { build: build2 } = await importNodeModule("press-ready");
-        await build2({
-          ...preflightOption.reduce((acc, opt) => {
-            const optName = decamelize(opt, { separator: "-" });
-            return optName.startsWith("no-") ? {
-              ...acc,
-              [optName.slice(3)]: false
-            } : {
-              ...acc,
-              [optName]: true
-            };
-          }, {}),
-          input,
-          output
-        });
-      } catch (_) {
-        var _error = _, _hasError = true;
-      } finally {
-        __callDispose(_stack, _error, _hasError);
-      }
-    } else if (preflight === "press-ready") {
-      var _stack2 = [];
-      try {
-        const _3 = __using(_stack2, Logger.suspendLogging("Running press-ready"));
-        await pressReadyWithContainer({
-          input,
-          output,
-          preflightOption,
-          image
-        });
-      } catch (_2) {
-        var _error2 = _2, _hasError2 = true;
-      } finally {
-        __callDispose(_stack2, _error2, _hasError2);
-      }
-    }
-  }
-  async metadata(tree, {
-    pageProgression,
-    browserVersion,
-    viewerCoreVersion,
-    disableCreatorOption
-  } = {}) {
-    const { ReadingDirection } = await importNodeModule("pdf-lib");
-    const title = tree[metaTerms.title]?.[0].v;
-    if (title) {
-      this.document.setTitle(title);
-    }
-    const author = tree[metaTerms.creator]?.map((item) => item.v)?.join("; ");
-    if (author) {
-      this.document.setAuthor(author);
-    }
-    const subject = tree[metaTerms.description]?.[0].v;
-    if (subject) {
-      this.document.setSubject(subject);
-    }
-    const keywords = tree[metaTerms.subject]?.map((item) => item.v);
-    if (keywords) {
-      this.document.setKeywords(keywords);
-    }
-    let creatorOpt = `Vivliostyle.js ${viewerCoreVersion ?? coreVersion}`;
-    if (browserVersion) {
-      creatorOpt += `; ${browserVersion}`;
-    }
-    this.document.setCreator(
-      disableCreatorOption ? "Vivliostyle" : `Vivliostyle (${creatorOpt})`
-    );
-    const language = tree[metaTerms.language]?.[0].v;
-    if (language) {
-      this.document.setLanguage(language);
-    }
-    const creation = (tree[metaTerms.created] || tree[metaTerms.date])?.[0].v;
-    const creationDate = creation && new Date(creation);
-    if (creationDate) {
-      this.document.setCreationDate(creationDate);
-    }
-    if (pageProgression === "rtl") {
-      const viewerPrefs = this.document.catalog.getOrCreateViewerPreferences();
-      viewerPrefs.setReadingDirection(ReadingDirection.R2L);
-    }
-  }
-  async toc(items) {
-    const { PDFDict, PDFHexString, PDFName, PDFNumber } = await importNodeModule("pdf-lib");
-    if (!items || !items.length) {
-      return;
-    }
-    const addRefs = (items2, parentRef) => items2.map((item) => {
-      const ref = this.document.context.nextRef();
-      return {
-        ...item,
-        parentRef,
-        ref,
-        children: addRefs(item.children, ref)
-      };
-    });
-    const countAll = (items2) => items2.reduce((sum, item) => sum + countAll(item.children), items2.length);
-    const addObjectsToPDF = (items2) => {
-      for (const [i, item] of items2.entries()) {
-        const child = PDFDict.withContext(this.document.context);
-        child.set(PDFName.of("Title"), PDFHexString.fromText(item.title));
-        child.set(PDFName.of("Dest"), PDFName.of(item.id));
-        child.set(PDFName.of("Parent"), item.parentRef);
-        const prev = items2[i - 1];
-        if (prev) {
-          child.set(PDFName.of("Prev"), prev.ref);
-        }
-        const next = items2[i + 1];
-        if (next) {
-          child.set(PDFName.of("Next"), next.ref);
-        }
-        if (item.children.length) {
-          child.set(PDFName.of("First"), item.children[0].ref);
-          child.set(
-            PDFName.of("Last"),
-            item.children[item.children.length - 1].ref
-          );
-          child.set(PDFName.of("Count"), PDFNumber.of(countAll(item.children)));
-        }
-        this.document.context.assign(item.ref, child);
-        addObjectsToPDF(item.children);
-      }
-    };
-    const outlineRef = this.document.context.nextRef();
-    const itemsWithRefs = addRefs(items, outlineRef);
-    addObjectsToPDF(itemsWithRefs);
-    const outline = PDFDict.withContext(this.document.context);
-    outline.set(PDFName.of("First"), itemsWithRefs[0].ref);
-    outline.set(
-      PDFName.of("Last"),
-      itemsWithRefs[itemsWithRefs.length - 1].ref
-    );
-    outline.set(PDFName.of("Count"), PDFNumber.of(countAll(itemsWithRefs)));
-    this.document.context.assign(outlineRef, outline);
-    this.document.catalog.set(PDFName.of("Outlines"), outlineRef);
-  }
-  async setPageBoxes(pageSizeData) {
-    if (pageSizeData.length + 1 === this.document.getPageCount()) {
-      this.document.removePage(pageSizeData.length);
-    }
-    if (pageSizeData.length !== this.document.getPageCount()) {
-      return;
-    }
-    for (let i = 0; i < pageSizeData.length; i++) {
-      const page = this.document.getPage(i);
-      const sizeData = pageSizeData[i];
-      if (!sizeData.mediaWidth || !sizeData.mediaHeight || isNaN(sizeData.bleedOffset) || isNaN(sizeData.bleedSize)) {
-        continue;
-      }
-      const yOffset = page.getHeight() - sizeData.mediaHeight;
-      page.setMediaBox(0, yOffset, sizeData.mediaWidth, sizeData.mediaHeight);
-      if (!sizeData.bleedOffset && !sizeData.bleedSize) {
-        continue;
-      }
-      page.setBleedBox(
-        sizeData.bleedOffset,
-        yOffset + sizeData.bleedOffset,
-        sizeData.mediaWidth - sizeData.bleedOffset * 2,
-        sizeData.mediaHeight - sizeData.bleedOffset * 2
-      );
-      const trimOffset = sizeData.bleedOffset + sizeData.bleedSize;
-      page.setTrimBox(
-        trimOffset,
-        yOffset + trimOffset,
-        sizeData.mediaWidth - trimOffset * 2,
-        sizeData.mediaHeight - trimOffset * 2
-      );
-    }
-  }
-};
-
-// src/output/pdf.ts
-async function buildPDF({
-  target,
-  config
-}) {
-  Logger.logUpdate(`Launching PDF build environment`);
-  const viewerFullUrl = await getViewerFullUrl(config);
-  Logger.debug("viewerFullUrl", viewerFullUrl);
-  let lastEntry;
-  function stringifyEntry(entry) {
-    const formattedSourcePath = cyan(
-      entry.source.type === "file" ? upath3.relative(config.entryContextDir, entry.source.pathname) : entry.source.href
-    );
-    return `${terminalLink(
-      formattedSourcePath,
-      entry.source.type === "file" ? `file://${entry.source.pathname}` : entry.source.href,
-      {
-        fallback: () => formattedSourcePath
-      }
-    )} ${entry.title ? gray(entry.title) : ""}`;
-  }
-  function handleEntry(response) {
-    const entry = config.entries.find((entry2) => {
-      if (!("source" in entry2)) {
-        return false;
-      }
-      const url = new URL2(response.url());
-      return url.protocol === "file:" ? pathEquals(entry2.target, url.pathname) : pathEquals(
-        upath3.relative(config.workspaceDir, entry2.target),
-        url.pathname.substring(1)
-      );
-    });
-    if (entry) {
-      if (!lastEntry) {
-        lastEntry = entry;
-        Logger.logUpdate(stringifyEntry(entry));
-        return;
-      }
-      Logger.logSuccess(stringifyEntry(lastEntry));
-      Logger.startLogging(stringifyEntry(entry));
-      lastEntry = entry;
-    }
-  }
-  const { browser, page } = await launchPreview({
-    mode: "build",
-    url: viewerFullUrl,
-    config,
-    onBrowserOpen: () => {
-      Logger.logUpdate("Building pages");
-    },
-    onPageOpen: async (page2) => {
-      page2.on("pageerror", (error) => {
-        Logger.logError(red(error.message));
-      });
-      page2.on("console", (msg) => {
-        switch (msg.type()) {
-          case "error":
-            if (/\/vivliostyle-viewer\.js$/.test(msg.location().url ?? "")) {
-              Logger.logError(msg.text());
-              throw msg.text();
-            }
-            return;
-          case "debug":
-            if (/time slice/.test(msg.text())) {
-              return;
-            }
-            break;
-        }
-        if (msg.type() === "error") {
-          Logger.logVerbose(red("console.error()"), msg.text());
-        } else {
-          Logger.logVerbose(gray(`console.${msg.type()}()`), msg.text());
-        }
-      });
-      page2.on("response", (response) => {
-        Logger.debug(
-          gray("viewer:response"),
-          green(response.status().toString()),
-          response.url()
-        );
-        handleEntry(response);
-        if (300 > response.status() && 200 <= response.status()) return;
-        if (response.url().startsWith("file://") && response.ok()) return;
-        Logger.logError(red(`${response.status()}`), response.url());
-      });
-      await page2.setDefaultTimeout(config.timeout);
-    }
-  });
-  const browserVersion = await browser.version();
-  Logger.debug(green("success"), `browserVersion=${browserVersion}`);
-  let remainTime = config.timeout;
-  const startTime = Date.now();
-  await page.waitForNetworkIdle();
-  await page.waitForFunction(() => !!window.coreViewer);
-  const { protocol } = browser;
-  if (protocol === "cdp") {
-    await page.emulateMediaType("print");
-  }
-  await page.waitForFunction(
-    /* v8 ignore next */
-    () => window.coreViewer.readyState === "complete",
-    { polling: 1e3 }
-  );
-  if (lastEntry) {
-    Logger.logSuccess(stringifyEntry(lastEntry));
-  }
-  const pageProgression = await page.evaluate(
-    () => (
-      /* v8 ignore next 5 */
-      document.querySelector("#vivliostyle-viewer-viewport")?.getAttribute("data-vivliostyle-page-progression") === "rtl" ? "rtl" : "ltr"
-    )
-  );
-  const viewerCoreVersion = await page.evaluate(
-    () => (
-      /* v8 ignore next 3 */
-      document.querySelector("#vivliostyle-menu_settings .version")?.textContent?.replace(/^.*?: (\d[-+.\w]+).*$/, "$1")
-    )
-  );
-  const metadata = await loadMetadata(page);
-  const toc = await loadTOC(page);
-  const pageSizeData = await loadPageSizeData(page);
-  remainTime -= Date.now() - startTime;
-  if (remainTime <= 0) {
-    throw new Error("Typesetting process timed out");
-  }
-  Logger.debug("Remaining timeout:", remainTime);
-  Logger.logUpdate("Building PDF");
-  const dimensionSizeForWebDriverBiDi = parseInt(process.env.VS_CLI_PDF_BUILD_PDF_PAGE_SIZE || "", 10) || 3780;
-  const pdf = await page.pdf({
-    margin: {
-      top: 0,
-      bottom: 0,
-      right: 0,
-      left: 0
-    },
-    printBackground: true,
-    tagged: true,
-    // timeout: remainTime,
-    ...protocol === "webDriverBiDi" ? {
-      width: dimensionSizeForWebDriverBiDi,
-      height: dimensionSizeForWebDriverBiDi
-    } : {
-      preferCSSPageSize: true
-    }
-  });
-  await browser.close();
-  Logger.logUpdate("Processing PDF");
-  fs2.mkdirSync(upath3.dirname(target.path), { recursive: true });
-  const post = await PostProcess.load(pdf);
-  await post.metadata(metadata, {
-    pageProgression,
-    browserVersion,
-    viewerCoreVersion,
-    // If custom viewer is set and its version info is not available,
-    // there is no guarantee that the default creator option is correct.
-    disableCreatorOption: !!config.viewer && !viewerCoreVersion
-  });
-  await post.toc(toc);
-  await post.setPageBoxes(pageSizeData);
-  await post.save(target.path, {
-    preflight: target.preflight,
-    preflightOption: target.preflightOption,
-    image: config.image
-  });
-  return target.path;
-}
-async function loadMetadata(page) {
-  return page.evaluate(() => window.coreViewer.getMetadata());
-}
-async function loadTOC(page) {
-  return page.evaluate(
-    () => new Promise((resolve) => {
-      function listener(payload) {
-        if (payload.a !== "toc") {
-          return;
-        }
-        window.coreViewer.removeListener("done", listener);
-        window.coreViewer.showTOC(false);
-        resolve(window.coreViewer.getTOC());
-      }
-      window.coreViewer.addListener("done", listener);
-      window.coreViewer.showTOC(true);
-    })
-  );
-}
-async function loadPageSizeData(page) {
-  return page.evaluate(() => {
-    const sizeData = [];
-    const pageContainers = document.querySelectorAll(
-      "#vivliostyle-viewer-viewport > div > div > div[data-vivliostyle-page-container]"
-    );
-    for (const pageContainer of pageContainers) {
-      const bleedBox = pageContainer.querySelector(
-        "div[data-vivliostyle-bleed-box]"
-      );
-      sizeData.push({
-        mediaWidth: parseFloat(pageContainer.style.width) * 0.75,
-        mediaHeight: parseFloat(pageContainer.style.height) * 0.75,
-        bleedOffset: parseFloat(bleedBox?.style.left) * 0.75,
-        bleedSize: parseFloat(bleedBox?.style.paddingLeft) * 0.75
-      });
-    }
-    return sizeData;
-  });
-}
-
-// src/core/build.ts
-async function build(inlineConfig, { containerForkMode = false } = {}) {
-  Logger.setLogOptions(inlineConfig);
-  if (containerForkMode) {
-    Logger.setLogPrefix(gray2("[Docker]"));
-  }
-  Logger.debug("build > inlineConfig %O", inlineConfig);
-  let vivliostyleConfig = await loadVivliostyleConfig(inlineConfig) ?? setupConfigFromFlags(inlineConfig);
-  warnDeprecatedConfig(vivliostyleConfig);
-  vivliostyleConfig = mergeInlineConfig(vivliostyleConfig, {
-    ...inlineConfig,
-    quick: false
-  });
-  const { inlineOptions } = vivliostyleConfig;
-  Logger.debug("build > vivliostyleConfig %O", vivliostyleConfig);
-  for (let [i, task] of vivliostyleConfig.tasks.entries()) {
-    var _stack2 = [];
-    try {
-      const _3 = __using(_stack2, Logger.startLogging("Start building"));
-      let config = resolveTaskConfig(task, inlineOptions);
-      Logger.debug("build > config %O", config);
-      const viteConfig = await resolveViteConfig({
-        ...config,
-        mode: "build"
-      });
-      let server;
-      if (!containerForkMode) {
-        Logger.debug("build > viteConfig.configFile %s", viteConfig.configFile);
-        if (viteConfig.configFile && typeof config.serverRootDir === "string") {
-          var _stack = [];
-          try {
-            const _4 = __using(_stack, Logger.suspendLogging("Building Vite project"));
-            await viteBuild({
-              configFile: viteConfig.configFile,
-              root: config.serverRootDir
-            });
-          } catch (_) {
-            var _error = _, _hasError = true;
-          } finally {
-            __callDispose(_stack, _error, _hasError);
-          }
-        }
-        if (!inlineConfig.disableServerStartup) {
-          server = await createViteServer({
-            config,
-            viteConfig,
-            inlineConfig,
-            mode: "build"
-          });
-          if (server.httpServer) {
-            const addressInfo = server.httpServer.address();
-            if (addressInfo && typeof addressInfo !== "string") {
-              const actualPort = addressInfo.port;
-              vivliostyleConfig = mergeConfig(vivliostyleConfig, {
-                temporaryFilePrefix: config.temporaryFilePrefix,
-                server: {
-                  ...server.config.preview,
-                  port: actualPort
-                }
-              });
-              config = resolveTaskConfig(
-                vivliostyleConfig.tasks[i],
-                vivliostyleConfig.inlineOptions
-              );
-            }
-          }
-        }
-        if (isWebPubConfig(config)) {
-          await cleanupWorkspace(config);
-          await prepareThemeDirectory(config);
-          await compile(config);
-          await copyAssets(config);
-        }
-      }
-      for (const target of config.outputs) {
-        let output = null;
-        const { format } = target;
-        if (format === "pdf") {
-          if (!containerForkMode && target.renderMode === "docker") {
-            output = await buildPDFWithContainer({
-              target,
-              config,
-              inlineConfig
-            });
-          } else {
-            output = await buildPDF({ target, config });
-          }
-        } else if (format === "webpub" || format === "epub") {
-          output = await buildWebPublication({ target, config });
-        }
-        if (output && !containerForkMode) {
-          const formattedOutput = cyan2(
-            upath4.relative(inlineConfig.cwd ?? cwd, output)
-          );
-          Logger.logSuccess(
-            `Finished building ${terminalLink2(
-              formattedOutput,
-              pathToFileURL2(output).href,
-              {
-                fallback: () => formattedOutput
-              }
-            )}`
-          );
-        }
-      }
-      await server?.close();
-    } catch (_2) {
-      var _error2 = _2, _hasError2 = true;
-    } finally {
-      __callDispose(_stack2, _error2, _hasError2);
-    }
-  }
-  runExitHandlers();
-  if (!containerForkMode) {
-    const num = vivliostyleConfig.tasks.flatMap((t) => t.output ?? []).length;
-    const symbol = isUnicodeSupported ? `${num > 1 ? "\u{1F4DA}" : randomBookSymbol} ` : "";
-    Logger.log(`${symbol}Built successfully!`);
-  }
-}
-
-export {
-  build
-};
-//# sourceMappingURL=chunk-5MEUINC4.js.map
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-5MEUINC4.js.map b/package/dist/chunk-5MEUINC4.js.map
--- a/package/dist/chunk-5MEUINC4.js.map	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/chunk-5MEUINC4.js.map	1970-01-01 09:00:00.000000000 +0900
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/core/build.ts","../src/container.ts","../src/output/pdf.ts","../src/output/pdf-postprocess.ts"],"sourcesContent":["import { pathToFileURL } from 'node:url';\nimport terminalLink from 'terminal-link';\nimport upath from 'upath';\nimport { type PreviewServer, build as viteBuild } from 'vite';\nimport { cyan, gray } from 'yoctocolors';\nimport { setupConfigFromFlags } from '../commands/cli-flags.js';\nimport { loadVivliostyleConfig, warnDeprecatedConfig } from '../config/load.js';\nimport { mergeConfig, mergeInlineConfig } from '../config/merge.js';\nimport { isWebPubConfig, resolveTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { resolveViteConfig } from '../config/vite.js';\nimport { buildPDFWithContainer } from '../container.js';\nimport { isUnicodeSupported, Logger, randomBookSymbol } from '../logger.js';\nimport { buildPDF } from '../output/pdf.js';\nimport { buildWebPublication } from '../output/webbook.js';\nimport { copyAssets } from '../processor/asset.js';\nimport {\n  cleanupWorkspace,\n  compile,\n  prepareThemeDirectory,\n} from '../processor/compile.js';\nimport { createViteServer } from '../server.js';\nimport { cwd, runExitHandlers } from '../util.js';\n\nexport async function build(\n  inlineConfig: ParsedVivliostyleInlineConfig,\n  { containerForkMode = false }: { containerForkMode?: boolean } = {},\n) {\n  Logger.setLogOptions(inlineConfig);\n  if (containerForkMode) {\n    Logger.setLogPrefix(gray('[Docker]'));\n  }\n  Logger.debug('build > inlineConfig %O', inlineConfig);\n\n  let vivliostyleConfig =\n    (await loadVivliostyleConfig(inlineConfig)) ??\n    setupConfigFromFlags(inlineConfig);\n  warnDeprecatedConfig(vivliostyleConfig);\n  vivliostyleConfig = mergeInlineConfig(vivliostyleConfig, {\n    ...inlineConfig,\n    quick: false,\n  });\n  const { inlineOptions } = vivliostyleConfig;\n  Logger.debug('build > vivliostyleConfig %O', vivliostyleConfig);\n\n  for (let [i, task] of vivliostyleConfig.tasks.entries()) {\n    using _ = Logger.startLogging('Start building');\n\n    let config = resolveTaskConfig(task, inlineOptions);\n    Logger.debug('build > config %O', config);\n    const viteConfig = await resolveViteConfig({\n      ...config,\n      mode: 'build',\n    });\n\n    let server: PreviewServer | undefined;\n    if (!containerForkMode) {\n      // build dependents first\n      Logger.debug('build > viteConfig.configFile %s', viteConfig.configFile);\n      if (viteConfig.configFile && typeof config.serverRootDir === 'string') {\n        using _ = Logger.suspendLogging('Building Vite project');\n        await viteBuild({\n          configFile: viteConfig.configFile,\n          root: config.serverRootDir,\n        });\n      }\n\n      if (!inlineConfig.disableServerStartup) {\n        server = await createViteServer({\n          config,\n          viteConfig,\n          inlineConfig,\n          mode: 'build',\n        });\n\n        if (server.httpServer) {\n          const addressInfo = server.httpServer.address();\n          if (addressInfo && typeof addressInfo !== 'string') {\n            const actualPort = addressInfo.port;\n            vivliostyleConfig = mergeConfig(vivliostyleConfig, {\n              temporaryFilePrefix: config.temporaryFilePrefix,\n              server: {\n                ...server.config.preview,\n                port: actualPort,\n              },\n            });\n            config = resolveTaskConfig(\n              vivliostyleConfig.tasks[i],\n              vivliostyleConfig.inlineOptions,\n            );\n          }\n        }\n      }\n\n      // build artifacts\n      if (isWebPubConfig(config)) {\n        await cleanupWorkspace(config);\n        await prepareThemeDirectory(config);\n        await compile(config);\n        await copyAssets(config);\n      }\n    }\n\n    // generate files\n    for (const target of config.outputs) {\n      let output: string | null = null;\n      const { format } = target;\n      if (format === 'pdf') {\n        if (!containerForkMode && target.renderMode === 'docker') {\n          output = await buildPDFWithContainer({\n            target,\n            config,\n            inlineConfig,\n          });\n        } else {\n          output = await buildPDF({ target, config });\n        }\n      } else if (format === 'webpub' || format === 'epub') {\n        output = await buildWebPublication({ target, config });\n      }\n      if (output && !containerForkMode) {\n        const formattedOutput = cyan(\n          upath.relative(inlineConfig.cwd ?? cwd, output),\n        );\n        Logger.logSuccess(\n          `Finished building ${terminalLink(\n            formattedOutput,\n            pathToFileURL(output).href,\n            {\n              fallback: () => formattedOutput,\n            },\n          )}`,\n        );\n      }\n    }\n\n    await server?.close();\n  }\n\n  runExitHandlers();\n  if (!containerForkMode) {\n    const num = vivliostyleConfig.tasks.flatMap((t) => t.output ?? []).length;\n    const symbol = isUnicodeSupported\n      ? `${num > 1 ? 'ðŸ“š' : randomBookSymbol} `\n      : '';\n    Logger.log(`${symbol}Built successfully!`);\n  }\n}\n","import process from 'node:process';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport { x } from 'tinyexec';\nimport upath from 'upath';\nimport type { PdfOutput, ResolvedTaskConfig } from './config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from './config/schema.js';\nimport { CONTAINER_LOCAL_HOSTNAME, CONTAINER_ROOT_DIR } from './const.js';\nimport { Logger } from './logger.js';\nimport { importNodeModule } from './node-modules.js';\nimport { getSourceUrl } from './server.js';\nimport { exec, isValidUri, pathEquals } from './util.js';\n\nexport function toContainerPath(urlOrAbsPath: string): string {\n  if (isValidUri(urlOrAbsPath)) {\n    if (urlOrAbsPath.toLowerCase().startsWith('file')) {\n      return pathToFileURL(\n        upath.posix.join(\n          CONTAINER_ROOT_DIR,\n          upath.toUnix(fileURLToPath(urlOrAbsPath)).replace(/^\\w:/, ''),\n        ),\n      ).href;\n    } else {\n      return urlOrAbsPath;\n    }\n  }\n  return upath.posix.join(\n    CONTAINER_ROOT_DIR,\n    upath.toUnix(urlOrAbsPath).replace(/^\\w:/, ''),\n  );\n}\n\nexport function collectVolumeArgs(mountPoints: string[]): string[] {\n  return mountPoints\n    .filter((p, i, array) => {\n      if (i !== array.indexOf(p)) {\n        // duplicated path\n        return false;\n      }\n      let parent = p;\n      while (!pathEquals(parent, upath.dirname(parent))) {\n        parent = upath.dirname(parent);\n        if (array.includes(parent)) {\n          // other mount point contains its directory\n          return false;\n        }\n      }\n      return true;\n    })\n    .map((p) => `${p}:${toContainerPath(p)}`);\n}\n\nexport async function runContainer({\n  image,\n  userVolumeArgs,\n  commandArgs,\n  entrypoint,\n  env,\n  workdir,\n}: {\n  image: string;\n  userVolumeArgs: string[];\n  commandArgs: string[];\n  entrypoint?: string;\n  env?: [string, string][];\n  workdir?: string;\n}) {\n  const { default: commandExists } = await importNodeModule('command-exists');\n  if (!(await commandExists('docker'))) {\n    throw new Error(\n      `Docker isn't be installed. To use this feature, you'll need to install Docker.`,\n    );\n  }\n  const version = (\n    await exec('docker', ['version', '--format', '{{.Server.Version}}'])\n  ).stdout;\n  const [major, minor] = version.split('.').map(Number);\n  if (major < 20 || (major === 20 && minor < 10)) {\n    throw new Error(\n      `Docker version ${version} is not supported. Please upgrade to Docker 20.10.0 or later.`,\n    );\n  }\n\n  try {\n    using _ = Logger.suspendLogging('Launching docker container');\n    const args = [\n      'run',\n      ...(Logger.isInteractive ? ['-it'] : []),\n      '--rm',\n      ...(entrypoint ? ['--entrypoint', entrypoint] : []),\n      ...(env ? env.flatMap(([k, v]) => ['-e', `${k}=${v}`]) : []),\n      ...(process.env.DEBUG\n        ? ['-e', `DEBUG=${process.env.DEBUG}`] // escape seems to work well\n        : []),\n      ...userVolumeArgs.flatMap((arg) => ['-v', arg]),\n      ...(workdir ? ['-w', workdir] : []),\n      image,\n      ...commandArgs,\n    ];\n    Logger.debug(`docker ${args.join(' ')}`);\n    const proc = x('docker', args, {\n      throwOnError: true,\n      nodeOptions: {\n        stdio: Logger.isInteractive ? 'inherit' : undefined,\n      },\n    });\n    if (Logger.isInteractive) {\n      await proc;\n    } else {\n      for await (const line of proc) {\n        Logger.log(line);\n      }\n    }\n  } catch (error) {\n    throw new Error(\n      'An error occurred on the running container. Please see logs above.',\n    );\n  }\n}\n\nexport async function buildPDFWithContainer({\n  target,\n  config,\n  inlineConfig,\n}: {\n  target: PdfOutput;\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): Promise<string | null> {\n  const sourceUrl = new URL(await getSourceUrl(config));\n  if (sourceUrl.origin === config.rootUrl) {\n    sourceUrl.hostname = CONTAINER_LOCAL_HOSTNAME;\n  }\n  const bypassedOption = {\n    ...inlineConfig,\n    input: {\n      format: 'webbook',\n      entry: sourceUrl.href,\n    },\n    output: [\n      {\n        ...target,\n        path: toContainerPath(target.path),\n      },\n    ],\n    host: CONTAINER_LOCAL_HOSTNAME,\n  } satisfies ParsedVivliostyleInlineConfig;\n\n  await runContainer({\n    image: config.image,\n    userVolumeArgs: collectVolumeArgs([\n      ...(typeof config.serverRootDir === 'string'\n        ? [config.serverRootDir]\n        : []),\n      upath.dirname(target.path),\n    ]),\n    env: [['VS_CLI_BUILD_PDF_OPTIONS', JSON.stringify(bypassedOption)]],\n    commandArgs: ['build'],\n    workdir:\n      typeof config.serverRootDir === 'string'\n        ? toContainerPath(config.serverRootDir)\n        : undefined,\n  });\n\n  return target.path;\n}\n","import fs from 'node:fs';\nimport { URL } from 'node:url';\nimport type { Browser, Page } from 'puppeteer-core';\nimport terminalLink from 'terminal-link';\nimport upath from 'upath';\nimport { cyan, gray, green, red } from 'yoctocolors';\nimport { launchPreview } from '../browser.js';\nimport type {\n  ManuscriptEntry,\n  PdfOutput,\n  ResolvedTaskConfig,\n} from '../config/resolve.js';\nimport type { Meta, Payload, TOCItem } from '../global-viewer.js';\nimport { Logger } from '../logger.js';\nimport { getViewerFullUrl } from '../server.js';\nimport { pathEquals } from '../util.js';\nimport { type PageSizeData, PostProcess } from './pdf-postprocess.js';\n\nexport async function buildPDF({\n  target,\n  config,\n}: {\n  target: PdfOutput;\n  config: ResolvedTaskConfig;\n}): Promise<string | null> {\n  Logger.logUpdate(`Launching PDF build environment`);\n\n  const viewerFullUrl = await getViewerFullUrl(config);\n  Logger.debug('viewerFullUrl', viewerFullUrl);\n\n  let lastEntry: ManuscriptEntry | undefined;\n\n  function stringifyEntry(entry: ManuscriptEntry) {\n    const formattedSourcePath = cyan(\n      entry.source.type === 'file'\n        ? upath.relative(config.entryContextDir, entry.source.pathname)\n        : entry.source.href,\n    );\n    return `${terminalLink(\n      formattedSourcePath,\n      entry.source.type === 'file'\n        ? `file://${entry.source.pathname}`\n        : entry.source.href,\n      {\n        fallback: () => formattedSourcePath,\n      },\n    )} ${entry.title ? gray(entry.title) : ''}`;\n  }\n\n  function handleEntry(response: any) {\n    const entry = config.entries.find((entry): entry is ManuscriptEntry => {\n      if (!('source' in entry)) {\n        return false;\n      }\n      const url = new URL(response.url());\n      return url.protocol === 'file:'\n        ? pathEquals(entry.target, url.pathname)\n        : pathEquals(\n            upath.relative(config.workspaceDir, entry.target),\n            url.pathname.substring(1),\n          );\n    });\n    if (entry) {\n      if (!lastEntry) {\n        lastEntry = entry;\n        Logger.logUpdate(stringifyEntry(entry));\n        return;\n      }\n      Logger.logSuccess(stringifyEntry(lastEntry));\n      Logger.startLogging(stringifyEntry(entry));\n      lastEntry = entry;\n    }\n  }\n\n  const { browser, page } = await launchPreview({\n    mode: 'build',\n    url: viewerFullUrl,\n    config,\n    onBrowserOpen: () => {\n      Logger.logUpdate('Building pages');\n    },\n    onPageOpen: async (page) => {\n      page.on('pageerror', (error) => {\n        Logger.logError(red((error as Error).message));\n      });\n\n      page.on('console', (msg) => {\n        switch (msg.type()) {\n          case 'error':\n            if (/\\/vivliostyle-viewer\\.js$/.test(msg.location().url ?? '')) {\n              Logger.logError(msg.text());\n              throw msg.text();\n            }\n            return;\n          case 'debug':\n            if (/time slice/.test(msg.text())) {\n              return;\n            }\n            break;\n        }\n        if (msg.type() === 'error') {\n          Logger.logVerbose(red('console.error()'), msg.text());\n        } else {\n          Logger.logVerbose(gray(`console.${msg.type()}()`), msg.text());\n        }\n      });\n\n      page.on('response', (response) => {\n        Logger.debug(\n          gray('viewer:response'),\n          green(response.status().toString()),\n          response.url(),\n        );\n\n        handleEntry(response);\n\n        if (300 > response.status() && 200 <= response.status()) return;\n        // file protocol doesn't have status code\n        if (response.url().startsWith('file://') && response.ok()) return;\n\n        Logger.logError(red(`${response.status()}`), response.url());\n      });\n\n      await page.setDefaultTimeout(config.timeout);\n    },\n  });\n\n  const browserVersion = await browser.version();\n  Logger.debug(green('success'), `browserVersion=${browserVersion}`);\n\n  let remainTime = config.timeout;\n  const startTime = Date.now();\n\n  await page.waitForNetworkIdle();\n  await page.waitForFunction(() => !!window.coreViewer);\n\n  const { protocol } = browser as Browser & {\n    protocol: 'cdp' | 'webDriverBiDi';\n  };\n  // Only CDP supports emulateMediaType\n  if (protocol === 'cdp') {\n    await page.emulateMediaType('print');\n  }\n  await page.waitForFunction(\n    /* v8 ignore next */\n    () => window.coreViewer.readyState === 'complete',\n    { polling: 1000 },\n  );\n\n  if (lastEntry) {\n    Logger.logSuccess(stringifyEntry(lastEntry));\n  }\n\n  const pageProgression = await page.evaluate(() =>\n    /* v8 ignore next 5 */\n    document\n      .querySelector('#vivliostyle-viewer-viewport')\n      ?.getAttribute('data-vivliostyle-page-progression') === 'rtl'\n      ? 'rtl'\n      : 'ltr',\n  );\n  const viewerCoreVersion = await page.evaluate(() =>\n    /* v8 ignore next 3 */\n    document\n      .querySelector('#vivliostyle-menu_settings .version')\n      ?.textContent?.replace(/^.*?: (\\d[-+.\\w]+).*$/, '$1'),\n  );\n  const metadata = await loadMetadata(page);\n  const toc = await loadTOC(page);\n  const pageSizeData = await loadPageSizeData(page);\n\n  remainTime -= Date.now() - startTime;\n  if (remainTime <= 0) {\n    throw new Error('Typesetting process timed out');\n  }\n  Logger.debug('Remaining timeout:', remainTime);\n\n  Logger.logUpdate('Building PDF');\n\n  // For Firefox WebDriver BiDi, explicitly set width and height\n  // because page.pdf() doesn't support for the preferCSSPageSize option.\n  // Use a sufficiently large value to accommodate user-defined page sizes.\n  const dimensionSizeForWebDriverBiDi =\n    parseInt(process.env.VS_CLI_PDF_BUILD_PDF_PAGE_SIZE || '', 10) || 3780; // 1000mm\n  const pdf = await page.pdf({\n    margin: {\n      top: 0,\n      bottom: 0,\n      right: 0,\n      left: 0,\n    },\n    printBackground: true,\n    tagged: true,\n    // timeout: remainTime,\n    ...(protocol === 'webDriverBiDi'\n      ? {\n          width: dimensionSizeForWebDriverBiDi,\n          height: dimensionSizeForWebDriverBiDi,\n        }\n      : {\n          preferCSSPageSize: true,\n        }),\n  });\n\n  await browser.close();\n\n  Logger.logUpdate('Processing PDF');\n  fs.mkdirSync(upath.dirname(target.path), { recursive: true });\n\n  const post = await PostProcess.load(pdf);\n  await post.metadata(metadata, {\n    pageProgression,\n    browserVersion,\n    viewerCoreVersion,\n    // If custom viewer is set and its version info is not available,\n    // there is no guarantee that the default creator option is correct.\n    disableCreatorOption: !!config.viewer && !viewerCoreVersion,\n  });\n  await post.toc(toc);\n  await post.setPageBoxes(pageSizeData);\n  await post.save(target.path, {\n    preflight: target.preflight,\n    preflightOption: target.preflightOption,\n    image: config.image,\n  });\n\n  return target.path;\n}\n\nasync function loadMetadata(page: Page): Promise<Meta> {\n  return page.evaluate(() => window.coreViewer.getMetadata());\n}\n\n// Show and hide the TOC in order to read its contents.\n// Chromium needs to see the TOC links in the DOM to add\n// the PDF destinations used during postprocessing.\nasync function loadTOC(page: Page): Promise<TOCItem[]> {\n  /* v8 ignore start */\n  return page.evaluate(\n    () =>\n      new Promise<TOCItem[]>((resolve) => {\n        function listener(payload: Payload) {\n          if (payload.a !== 'toc') {\n            return;\n          }\n          window.coreViewer.removeListener('done', listener);\n          window.coreViewer.showTOC(false);\n          resolve(window.coreViewer.getTOC());\n        }\n        window.coreViewer.addListener('done', listener);\n        window.coreViewer.showTOC(true);\n      }),\n  );\n  /* v8 ignore stop */\n}\n\nasync function loadPageSizeData(page: Page): Promise<PageSizeData[]> {\n  /* v8 ignore start */\n  return page.evaluate(() => {\n    const sizeData: PageSizeData[] = [];\n    const pageContainers = document.querySelectorAll(\n      '#vivliostyle-viewer-viewport > div > div > div[data-vivliostyle-page-container]',\n    ) as NodeListOf<HTMLElement>;\n\n    for (const pageContainer of pageContainers) {\n      const bleedBox = pageContainer.querySelector(\n        'div[data-vivliostyle-bleed-box]',\n      ) as HTMLElement;\n      sizeData.push({\n        mediaWidth: parseFloat(pageContainer.style.width) * 0.75,\n        mediaHeight: parseFloat(pageContainer.style.height) * 0.75,\n        bleedOffset: parseFloat(bleedBox?.style.left) * 0.75,\n        bleedSize: parseFloat(bleedBox?.style.paddingLeft) * 0.75,\n      });\n    }\n    return sizeData;\n  });\n  /* v8 ignore stop */\n}\n","import decamelize from 'decamelize';\nimport fs from 'node:fs';\nimport os from 'node:os';\nimport type { PDFDocument, PDFRef } from 'pdf-lib';\nimport upath from 'upath';\nimport { v1 as uuid } from 'uuid';\nimport type { PdfOutput, ResolvedTaskConfig } from '../config/resolve.js';\nimport { coreVersion } from '../const.js';\nimport {\n  collectVolumeArgs,\n  runContainer,\n  toContainerPath,\n} from '../container.js';\nimport type { Meta, TOCItem } from '../global-viewer.js';\nimport { Logger } from '../logger.js';\nimport { importNodeModule } from '../node-modules.js';\nimport { isInContainer } from '../util.js';\n\nexport type SaveOption = Pick<PdfOutput, 'preflight' | 'preflightOption'> &\n  Pick<ResolvedTaskConfig, 'image'>;\n\nconst prefixes = {\n  dcterms: 'http://purl.org/dc/terms/',\n  meta: 'http://idpf.org/epub/vocab/package/meta/#',\n};\n\nconst metaTerms = {\n  title: `${prefixes.dcterms}title`,\n  creator: `${prefixes.dcterms}creator`,\n  description: `${prefixes.dcterms}description`,\n  subject: `${prefixes.dcterms}subject`,\n  contributor: `${prefixes.dcterms}contributor`,\n  language: `${prefixes.dcterms}language`,\n  role: `${prefixes.meta}role`,\n  created: `${prefixes.meta}created`,\n  date: `${prefixes.meta}date`,\n};\n\ninterface PDFTocItem extends TOCItem {\n  children: PDFTocItem[];\n  ref: PDFRef;\n  parentRef: PDFRef;\n}\n\nexport interface PageSizeData {\n  mediaWidth: number;\n  mediaHeight: number;\n  bleedOffset: number;\n  bleedSize: number;\n}\n\nexport async function pressReadyWithContainer({\n  input,\n  output,\n  preflightOption,\n  image,\n}: {\n  input: string;\n  output: string;\n  preflightOption: string[];\n  image: string;\n}) {\n  await runContainer({\n    image,\n    entrypoint: 'press-ready',\n    userVolumeArgs: collectVolumeArgs([\n      upath.dirname(input),\n      upath.dirname(output),\n    ]),\n    commandArgs: [\n      'build',\n      '-i',\n      toContainerPath(input),\n      '-o',\n      toContainerPath(output),\n      ...preflightOption\n        .map((opt) => `--${decamelize(opt, { separator: '-' })}`)\n        .filter((str) => /^[\\w-]+/.test(str)),\n    ],\n  });\n}\n\nexport class PostProcess {\n  protected readonly document: PDFDocument;\n\n  static async load(pdf: Uint8Array): Promise<PostProcess> {\n    const { PDFDocument } = await importNodeModule('pdf-lib');\n    const document = await PDFDocument.load(pdf, { updateMetadata: false });\n    return new PostProcess(document);\n  }\n\n  protected constructor(document: PDFDocument) {\n    this.document = document;\n  }\n\n  async save(\n    output: string,\n    { preflight, preflightOption, image }: SaveOption,\n  ) {\n    const input = preflight\n      ? upath.join(os.tmpdir(), `vivliostyle-cli-${uuid()}.pdf`)\n      : output;\n\n    const pdf = await this.document.save();\n    await fs.promises.writeFile(input, pdf);\n\n    if (\n      preflight === 'press-ready-local' ||\n      (preflight === 'press-ready' && isInContainer())\n    ) {\n      using _ = Logger.suspendLogging('Running press-ready');\n      const { build } = await importNodeModule('press-ready');\n      await build({\n        ...preflightOption.reduce((acc, opt) => {\n          const optName = decamelize(opt, { separator: '-' });\n          return optName.startsWith('no-')\n            ? {\n                ...acc,\n                [optName.slice(3)]: false,\n              }\n            : {\n                ...acc,\n                [optName]: true,\n              };\n        }, {}),\n        input,\n        output,\n      });\n    } else if (preflight === 'press-ready') {\n      using _ = Logger.suspendLogging('Running press-ready');\n      await pressReadyWithContainer({\n        input,\n        output,\n        preflightOption,\n        image,\n      });\n    }\n  }\n\n  async metadata(\n    tree: Meta,\n    {\n      pageProgression,\n      browserVersion,\n      viewerCoreVersion,\n      disableCreatorOption,\n    }: {\n      pageProgression?: 'ltr' | 'rtl';\n      browserVersion?: string;\n      viewerCoreVersion?: string;\n      disableCreatorOption?: boolean;\n    } = {},\n  ) {\n    const { ReadingDirection } = await importNodeModule('pdf-lib');\n    const title = tree[metaTerms.title]?.[0].v;\n    if (title) {\n      this.document.setTitle(title);\n    }\n\n    const author = tree[metaTerms.creator]?.map((item) => item.v)?.join('; ');\n    if (author) {\n      this.document.setAuthor(author);\n    }\n\n    const subject = tree[metaTerms.description]?.[0].v;\n    if (subject) {\n      this.document.setSubject(subject);\n    }\n\n    const keywords = tree[metaTerms.subject]?.map((item) => item.v);\n    if (keywords) {\n      this.document.setKeywords(keywords);\n    }\n\n    let creatorOpt = `Vivliostyle.js ${viewerCoreVersion ?? coreVersion}`;\n    if (browserVersion) {\n      creatorOpt += `; ${browserVersion}`;\n    }\n    this.document.setCreator(\n      disableCreatorOption ? 'Vivliostyle' : `Vivliostyle (${creatorOpt})`,\n    );\n\n    const language = tree[metaTerms.language]?.[0].v;\n    if (language) {\n      this.document.setLanguage(language);\n    }\n\n    const creation = (tree[metaTerms.created] || tree[metaTerms.date])?.[0].v;\n    const creationDate = creation && new Date(creation);\n    if (creationDate) {\n      this.document.setCreationDate(creationDate);\n    }\n    if (pageProgression === 'rtl') {\n      const viewerPrefs = this.document.catalog.getOrCreateViewerPreferences();\n      viewerPrefs.setReadingDirection(ReadingDirection.R2L);\n    }\n  }\n\n  async toc(items: TOCItem[]) {\n    const { PDFDict, PDFHexString, PDFName, PDFNumber } =\n      await importNodeModule('pdf-lib');\n    if (!items || !items.length) {\n      return;\n    }\n\n    const addRefs = (items: TOCItem[], parentRef: PDFRef): PDFTocItem[] =>\n      items.map((item) => {\n        const ref = this.document.context.nextRef();\n        return {\n          ...item,\n          parentRef,\n          ref,\n          children: addRefs(item.children, ref),\n        };\n      });\n    const countAll = (items: PDFTocItem[]): number =>\n      items.reduce((sum, item) => sum + countAll(item.children), items.length);\n    const addObjectsToPDF = (items: PDFTocItem[]) => {\n      for (const [i, item] of items.entries()) {\n        const child = PDFDict.withContext(this.document.context);\n        child.set(PDFName.of('Title'), PDFHexString.fromText(item.title));\n        child.set(PDFName.of('Dest'), PDFName.of(item.id));\n        child.set(PDFName.of('Parent'), item.parentRef);\n        const prev = items[i - 1];\n        if (prev) {\n          child.set(PDFName.of('Prev'), prev.ref);\n        }\n        const next = items[i + 1];\n        if (next) {\n          child.set(PDFName.of('Next'), next.ref);\n        }\n        if (item.children.length) {\n          child.set(PDFName.of('First'), item.children[0].ref);\n          child.set(\n            PDFName.of('Last'),\n            item.children[item.children.length - 1].ref,\n          );\n          child.set(PDFName.of('Count'), PDFNumber.of(countAll(item.children)));\n        }\n        this.document.context.assign(item.ref, child);\n        addObjectsToPDF(item.children);\n      }\n    };\n\n    const outlineRef = this.document.context.nextRef();\n    const itemsWithRefs = addRefs(items, outlineRef);\n    addObjectsToPDF(itemsWithRefs);\n\n    const outline = PDFDict.withContext(this.document.context);\n    outline.set(PDFName.of('First'), itemsWithRefs[0].ref);\n    outline.set(\n      PDFName.of('Last'),\n      itemsWithRefs[itemsWithRefs.length - 1].ref,\n    );\n    outline.set(PDFName.of('Count'), PDFNumber.of(countAll(itemsWithRefs)));\n    this.document.context.assign(outlineRef, outline);\n    this.document.catalog.set(PDFName.of('Outlines'), outlineRef);\n  }\n\n  async setPageBoxes(pageSizeData: PageSizeData[]) {\n    if (pageSizeData.length + 1 === this.document.getPageCount()) {\n      // fix issue #312: Chromium LayoutNGPrinting adds unnecessary blank page\n      this.document.removePage(pageSizeData.length);\n    }\n    if (pageSizeData.length !== this.document.getPageCount()) {\n      return;\n    }\n    for (let i = 0; i < pageSizeData.length; i++) {\n      const page = this.document.getPage(i);\n      const sizeData = pageSizeData[i];\n      if (\n        !sizeData.mediaWidth ||\n        !sizeData.mediaHeight ||\n        isNaN(sizeData.bleedOffset) ||\n        isNaN(sizeData.bleedSize)\n      ) {\n        continue;\n      }\n      const yOffset = page.getHeight() - sizeData.mediaHeight;\n      page.setMediaBox(0, yOffset, sizeData.mediaWidth, sizeData.mediaHeight);\n      if (!sizeData.bleedOffset && !sizeData.bleedSize) {\n        continue;\n      }\n      page.setBleedBox(\n        sizeData.bleedOffset,\n        yOffset + sizeData.bleedOffset,\n        sizeData.mediaWidth - sizeData.bleedOffset * 2,\n        sizeData.mediaHeight - sizeData.bleedOffset * 2,\n      );\n      const trimOffset = sizeData.bleedOffset + sizeData.bleedSize;\n      page.setTrimBox(\n        trimOffset,\n        yOffset + trimOffset,\n        sizeData.mediaWidth - trimOffset * 2,\n        sizeData.mediaHeight - trimOffset * 2,\n      );\n    }\n  }\n}\n"],"mappings":"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","names":["pathToFileURL","terminalLink","upath","cyan","gray","process","_","process","fs","URL","upath","upath","upath","document","_","build","_stack","_error","_hasError","items","upath","entry","URL","page","fs","gray","_stack","_","cyan","upath","terminalLink","pathToFileURL","_error","_hasError"]}
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-62AC6XGJ.js b/package/dist/chunk-62AC6XGJ.js
--- a/package/dist/chunk-62AC6XGJ.js	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/chunk-62AC6XGJ.js	1970-01-01 09:00:00.000000000 +0900
@@ -1,56 +0,0 @@
-import {
-  loadVivliostyleConfig,
-  mergeInlineConfig,
-  resolveTaskConfig,
-  vsBrowserPlugin,
-  vsDevServerPlugin,
-  vsStaticServePlugin,
-  vsViewerPlugin,
-  warnDeprecatedConfig
-} from "./chunk-BR2V7MHE.js";
-import {
-  Logger,
-  setupConfigFromFlags
-} from "./chunk-T2VWLU2I.js";
-import {
-  VivliostyleInlineConfig
-} from "./chunk-CKXFRCPH.js";
-
-// src/vite-adapter.ts
-import * as v from "valibot";
-import * as vite from "vite";
-async function createVitePlugin(inlineConfig = {}) {
-  const parsedInlineConfig = v.parse(VivliostyleInlineConfig, inlineConfig);
-  let viteLogger;
-  Logger.setLogOptions({
-    ...parsedInlineConfig,
-    logger: parsedInlineConfig.logger ?? {
-      info: (msg) => viteLogger?.info(msg, { timestamp: true }),
-      warn: (msg) => viteLogger?.warn(msg, { timestamp: true }),
-      error: (msg) => viteLogger?.error(msg, { timestamp: true })
-    }
-  });
-  viteLogger = vite.createLogger("info", {
-    prefix: "[vivliostyle]"
-  });
-  Logger.debug("inlineConfig %O", parsedInlineConfig);
-  const vivliostyleConfig = await loadVivliostyleConfig(parsedInlineConfig) ?? setupConfigFromFlags(parsedInlineConfig);
-  warnDeprecatedConfig(vivliostyleConfig);
-  const { tasks, inlineOptions } = mergeInlineConfig(
-    vivliostyleConfig,
-    parsedInlineConfig
-  );
-  const config = resolveTaskConfig(tasks[0], inlineOptions);
-  Logger.debug("config %O", config);
-  return [
-    vsDevServerPlugin({ config, inlineConfig: parsedInlineConfig }),
-    vsViewerPlugin({ config, inlineConfig: parsedInlineConfig }),
-    vsBrowserPlugin({ config, inlineConfig: parsedInlineConfig }),
-    vsStaticServePlugin({ config, inlineConfig: parsedInlineConfig })
-  ];
-}
-
-export {
-  createVitePlugin
-};
-//# sourceMappingURL=chunk-62AC6XGJ.js.map
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-62AC6XGJ.js.map b/package/dist/chunk-62AC6XGJ.js.map
--- a/package/dist/chunk-62AC6XGJ.js.map	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/chunk-62AC6XGJ.js.map	1970-01-01 09:00:00.000000000 +0900
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/vite-adapter.ts"],"sourcesContent":["import * as v from 'valibot';\nimport * as vite from 'vite';\nimport { setupConfigFromFlags } from './commands/cli-flags.js';\nimport { loadVivliostyleConfig, warnDeprecatedConfig } from './config/load.js';\nimport { mergeInlineConfig } from './config/merge.js';\nimport { resolveTaskConfig } from './config/resolve.js';\nimport { VivliostyleInlineConfig } from './config/schema.js';\nimport { Logger } from './logger.js';\nimport { vsBrowserPlugin } from './vite/vite-plugin-browser.js';\nimport { vsDevServerPlugin } from './vite/vite-plugin-dev-server.js';\nimport { vsStaticServePlugin } from './vite/vite-plugin-static-serve.js';\nimport { vsViewerPlugin } from './vite/vite-plugin-viewer.js';\n\nexport async function createVitePlugin(\n  inlineConfig: VivliostyleInlineConfig = {},\n): Promise<vite.Plugin[]> {\n  const parsedInlineConfig = v.parse(VivliostyleInlineConfig, inlineConfig);\n  let viteLogger: ReturnType<typeof vite.createLogger>;\n  Logger.setLogOptions({\n    ...parsedInlineConfig,\n    logger: parsedInlineConfig.logger ?? {\n      info: (msg) => viteLogger?.info(msg, { timestamp: true }),\n      warn: (msg) => viteLogger?.warn(msg, { timestamp: true }),\n      error: (msg) => viteLogger?.error(msg, { timestamp: true }),\n    },\n  });\n  viteLogger = vite.createLogger('info', {\n    prefix: '[vivliostyle]',\n  });\n  Logger.debug('inlineConfig %O', parsedInlineConfig);\n  const vivliostyleConfig =\n    (await loadVivliostyleConfig(parsedInlineConfig)) ??\n    setupConfigFromFlags(parsedInlineConfig);\n  warnDeprecatedConfig(vivliostyleConfig);\n  const { tasks, inlineOptions } = mergeInlineConfig(\n    vivliostyleConfig,\n    parsedInlineConfig,\n  );\n  const config = resolveTaskConfig(tasks[0], inlineOptions);\n  Logger.debug('config %O', config);\n\n  return [\n    vsDevServerPlugin({ config, inlineConfig: parsedInlineConfig }),\n    vsViewerPlugin({ config, inlineConfig: parsedInlineConfig }),\n    vsBrowserPlugin({ config, inlineConfig: parsedInlineConfig }),\n    vsStaticServePlugin({ config, inlineConfig: parsedInlineConfig }),\n  ];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,YAAY,OAAO;AACnB,YAAY,UAAU;AAYtB,eAAsB,iBACpB,eAAwC,CAAC,GACjB;AACxB,QAAM,qBAAuB,QAAM,yBAAyB,YAAY;AACxE,MAAI;AACJ,SAAO,cAAc;AAAA,IACnB,GAAG;AAAA,IACH,QAAQ,mBAAmB,UAAU;AAAA,MACnC,MAAM,CAAC,QAAQ,YAAY,KAAK,KAAK,EAAE,WAAW,KAAK,CAAC;AAAA,MACxD,MAAM,CAAC,QAAQ,YAAY,KAAK,KAAK,EAAE,WAAW,KAAK,CAAC;AAAA,MACxD,OAAO,CAAC,QAAQ,YAAY,MAAM,KAAK,EAAE,WAAW,KAAK,CAAC;AAAA,IAC5D;AAAA,EACF,CAAC;AACD,eAAkB,kBAAa,QAAQ;AAAA,IACrC,QAAQ;AAAA,EACV,CAAC;AACD,SAAO,MAAM,mBAAmB,kBAAkB;AAClD,QAAM,oBACH,MAAM,sBAAsB,kBAAkB,KAC/C,qBAAqB,kBAAkB;AACzC,uBAAqB,iBAAiB;AACtC,QAAM,EAAE,OAAO,cAAc,IAAI;AAAA,IAC/B;AAAA,IACA;AAAA,EACF;AACA,QAAM,SAAS,kBAAkB,MAAM,CAAC,GAAG,aAAa;AACxD,SAAO,MAAM,aAAa,MAAM;AAEhC,SAAO;AAAA,IACL,kBAAkB,EAAE,QAAQ,cAAc,mBAAmB,CAAC;AAAA,IAC9D,eAAe,EAAE,QAAQ,cAAc,mBAAmB,CAAC;AAAA,IAC3D,gBAAgB,EAAE,QAAQ,cAAc,mBAAmB,CAAC;AAAA,IAC5D,oBAAoB,EAAE,QAAQ,cAAc,mBAAmB,CAAC;AAAA,EAClE;AACF;","names":[]}
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-BR2V7MHE.js b/package/dist/chunk-BR2V7MHE.js
--- a/package/dist/chunk-BR2V7MHE.js	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/chunk-BR2V7MHE.js	1970-01-01 09:00:00.000000000 +0900
@@ -1,4039 +0,0 @@
-import {
-  importNodeModule
-} from "./chunk-E6QVHS6D.js";
-import {
-  DetailError,
-  GlobMatcher,
-  Logger,
-  assertPubManifestSchema,
-  cwd,
-  debounce,
-  detectBrowserPlatform,
-  getAssetMatcher,
-  getCacheDir,
-  getDefaultBrowserTag,
-  getDefaultEpubOpfPath,
-  getEpubRootDir,
-  getFormattedError,
-  getOsLocale,
-  getWebPubResourceMatcher,
-  isInContainer,
-  isRunningOnWSL,
-  isValidUri,
-  openEpub,
-  parseJsonc,
-  pathContains,
-  pathEquals,
-  prettifySchemaError,
-  readJSON,
-  registerExitHandler,
-  runExitHandlers,
-  setupConfigFromFlags,
-  statFileSync,
-  touchTmpFile,
-  useTmpDirectory,
-  writeFileIfChanged
-} from "./chunk-T2VWLU2I.js";
-import {
-  VivliostyleConfigSchema
-} from "./chunk-CKXFRCPH.js";
-import {
-  CONTAINER_LOCAL_HOSTNAME,
-  CONTAINER_URL,
-  COVER_HTML_FILENAME,
-  COVER_HTML_IMAGE_ALT,
-  DEFAULT_BROWSER_VERSIONS,
-  EMPTY_DATA_URI,
-  EPUB_CONTAINER_XML,
-  EPUB_LANDMARKS_COVER_ENTRY,
-  EPUB_LANDMARKS_TITLE,
-  EPUB_LANDMARKS_TOC_ENTRY,
-  EPUB_NS,
-  EPUB_OUTPUT_VERSION,
-  MANIFEST_FILENAME,
-  TOC_FILENAME,
-  TOC_TITLE,
-  VIEWER_ROOT_PATH,
-  XML_DECLARATION,
-  cliVersion,
-  viewerRoot
-} from "./chunk-ZEBXHUJX.js";
-import {
-  __callDispose,
-  __using
-} from "./chunk-I7BWSAN6.js";
-
-// src/config/load.ts
-import fs from "node:fs";
-import { createRequire } from "node:module";
-import { pathToFileURL } from "node:url";
-import upath from "upath";
-import * as v from "valibot";
-var require2 = createRequire(import.meta.url);
-function locateVivliostyleConfig({
-  config,
-  cwd: cwd2 = cwd
-}) {
-  if (config) {
-    return upath.resolve(cwd2, config);
-  }
-  return [".js", ".mjs", ".cjs", ".json"].map((ext) => upath.join(cwd2, `vivliostyle.config${ext}`)).find((p) => fs.existsSync(p));
-}
-async function loadVivliostyleConfig({
-  config,
-  configData,
-  cwd: cwd2
-}) {
-  if (configData) {
-    return v.parse(VivliostyleConfigSchema, configData);
-  }
-  const absPath = locateVivliostyleConfig({ config, cwd: cwd2 });
-  if (!absPath) {
-    return;
-  }
-  let parsedConfig;
-  let jsonRaw;
-  try {
-    if (upath.extname(absPath) === ".json") {
-      jsonRaw = fs.readFileSync(absPath, "utf8");
-      parsedConfig = parseJsonc(jsonRaw);
-    } else {
-      delete require2.cache[require2.resolve(absPath)];
-      const url = pathToFileURL(absPath);
-      url.search = `version=${Date.now()}`;
-      parsedConfig = (await import(
-        /* @vite-ignore */
-        url.href
-      )).default;
-      jsonRaw = JSON.stringify(parsedConfig, null, 2);
-    }
-  } catch (error) {
-    const thrownError = error;
-    throw new DetailError(
-      `An error occurred on loading a config file: ${absPath}`,
-      thrownError.stack ?? thrownError.message
-    );
-  }
-  const result = v.safeParse(VivliostyleConfigSchema, parsedConfig);
-  if (result.success) {
-    const { tasks, inlineOptions } = result.output;
-    return {
-      tasks,
-      inlineOptions: {
-        ...inlineOptions,
-        cwd: cwd2 ?? cwd,
-        config: absPath
-      }
-    };
-  } else {
-    const errorString = prettifySchemaError(jsonRaw, result.issues);
-    throw new DetailError(
-      `Validation of vivliostyle config failed. Please check the schema: ${config}`,
-      errorString
-    );
-  }
-}
-function warnDeprecatedConfig(config) {
-  if (config.tasks.some((task) => task.includeAssets)) {
-    Logger.logWarn(
-      "'includeAssets' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'copyAsset.includes' property instead."
-    );
-  }
-  if (config.tasks.some((task) => task.tocTitle)) {
-    Logger.logWarn(
-      "'tocTitle' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'toc.title' property instead."
-    );
-  }
-  if (config.tasks.some((task) => task.http)) {
-    Logger.logWarn(
-      "'http' property of Vivliostyle config was deprecated and will be removed in a future release. This option is enabled by default, and the file protocol is no longer supported."
-    );
-  }
-}
-
-// src/config/merge.ts
-var pruneObject = (obj) => {
-  const ret = { ...obj };
-  for (const key in ret) {
-    if (ret[key] === void 0 || ret[key] === null) {
-      delete ret[key];
-    }
-  }
-  return ret;
-};
-function mergeConfig(base, override) {
-  return {
-    tasks: base.tasks.map((task, i) => ({
-      ...pruneObject(task),
-      ...pruneObject(override)
-    })),
-    inlineOptions: base.inlineOptions
-  };
-}
-function mergeInlineConfig({ tasks, inlineOptions }, inlineConfig) {
-  const {
-    theme,
-    size,
-    pressReady,
-    title,
-    author,
-    language,
-    readingProgression,
-    timeout,
-    image,
-    viewer,
-    viewerParam,
-    browser,
-    output,
-    renderMode,
-    preflight,
-    preflightOption,
-    vite: vite5,
-    viteConfigFile,
-    host,
-    port,
-    ...overrideInlineOptions
-  } = inlineConfig;
-  return {
-    tasks: tasks.map((task) => ({
-      ...pruneObject(task),
-      ...pruneObject({
-        theme,
-        size,
-        pressReady,
-        title,
-        author,
-        language,
-        readingProgression,
-        timeout,
-        image,
-        viewer,
-        viewerParam,
-        browser,
-        vite: vite5,
-        viteConfigFile
-      }),
-      output: (output?.length ? output : task.output)?.map((o) => ({
-        ...pruneObject(o),
-        ...pruneObject({
-          renderMode,
-          preflight,
-          preflightOption
-        })
-      })),
-      server: {
-        ...pruneObject(task.server ?? {}),
-        ...pruneObject({ host, port })
-      }
-    })),
-    inlineOptions: {
-      ...pruneObject(inlineOptions),
-      ...pruneObject({
-        renderMode,
-        preflight,
-        preflightOption
-      }),
-      ...pruneObject(
-        overrideInlineOptions
-      )
-    }
-  };
-}
-
-// src/config/resolve.ts
-import {
-  readMetadata,
-  VFM
-} from "@vivliostyle/vfm";
-import { lookup as mime } from "mime-types";
-import fs3 from "node:fs";
-import { fileURLToPath, pathToFileURL as pathToFileURL2 } from "node:url";
-import npa from "npm-package-arg";
-import upath2 from "upath";
-
-// src/processor/markdown.ts
-import fs2 from "node:fs";
-import vfile from "vfile";
-async function processMarkdown(documentProcessorFactory, documentMetadataReader, filepath, options = {}) {
-  const markdownString = fs2.readFileSync(filepath, "utf8");
-  const processor = documentProcessorFactory(
-    options,
-    documentMetadataReader(markdownString)
-  );
-  const processed = await processor.process(
-    vfile({ path: filepath, contents: markdownString })
-  );
-  return processed;
-}
-function readMarkdownMetadata(filepath, documentMetadataReader) {
-  return documentMetadataReader(fs2.readFileSync(filepath, "utf8"));
-}
-
-// src/config/resolve.ts
-var manuscriptMediaTypes = [
-  "text/markdown",
-  "text/html",
-  "text/plain",
-  "application/xhtml+xml",
-  // a special MIME type indicates that a custom processor is used
-  "text/x-vivliostyle-custom"
-];
-var UseTemporaryServerRoot = Symbol("UseTemporaryServerRoot");
-var DEFAULT_ASSET_EXTENSIONS = [
-  "css",
-  "css.map",
-  "png",
-  "jpg",
-  "jpeg",
-  "svg",
-  "gif",
-  "webp",
-  "apng",
-  "ttf",
-  "otf",
-  "woff",
-  "woff2"
-];
-function isManuscriptMediaType(mediaType) {
-  return !!(mediaType && manuscriptMediaTypes.includes(mediaType));
-}
-var htmlExtensions = [".html", ".htm", ".xhtml", ".xht"];
-function toHtmlExtension(filename) {
-  const ext = upath2.extname(filename).toLowerCase();
-  if (htmlExtensions.includes(
-    // @ts-expect-error check membership
-    ext
-  )) {
-    return filename;
-  }
-  return `${filename.slice(0, -ext.length)}.html`;
-}
-function isWebPubConfig(config) {
-  return config.viewerInput.type === "webpub";
-}
-function isWebbookConfig(config) {
-  return config.viewerInput.type === "webbook";
-}
-function parsePackageName(specifier, cwd2) {
-  try {
-    let result = npa(specifier, cwd2);
-    if (result.type === "git" && result.saveSpec?.startsWith("github:")) {
-      result = npa(`file:${specifier}`, cwd2);
-    }
-    return result;
-  } catch (error) {
-    return null;
-  }
-}
-function parseTheme({
-  theme,
-  context,
-  workspaceDir,
-  themesDir
-}) {
-  const { specifier, import: importPath } = typeof theme === "string" ? { specifier: theme, import: void 0 } : theme;
-  if (isValidUri(specifier)) {
-    return {
-      type: "uri",
-      name: upath2.basename(specifier),
-      location: specifier
-    };
-  }
-  const stylePath = upath2.resolve(context, specifier);
-  if (fs3.existsSync(stylePath) && stylePath.endsWith(".css")) {
-    const sourceRelPath = upath2.relative(context, stylePath);
-    return {
-      type: "file",
-      name: upath2.basename(specifier),
-      source: stylePath,
-      location: upath2.resolve(workspaceDir, sourceRelPath)
-    };
-  }
-  const parsed = parsePackageName(specifier, context);
-  if (!parsed) {
-    throw new Error(`Invalid package name: ${specifier}`);
-  }
-  if (!parsed.registry && parsed.type !== "directory") {
-    throw new Error(`This package specifier is not allowed: ${specifier}`);
-  }
-  let name = parsed.name;
-  let resolvedSpecifier = specifier;
-  if (parsed.type === "directory" && parsed.fetchSpec) {
-    const pkgJsonPath = upath2.join(parsed.fetchSpec, "package.json");
-    if (fs3.existsSync(pkgJsonPath)) {
-      const packageJson = JSON.parse(fs3.readFileSync(pkgJsonPath, "utf8"));
-      name = packageJson.name;
-      resolvedSpecifier = parsed.fetchSpec;
-    }
-  }
-  if (!name) {
-    throw new Error(`Could not determine the package name: ${specifier}`);
-  }
-  return {
-    type: "package",
-    name,
-    specifier: resolvedSpecifier,
-    location: upath2.join(themesDir, "node_modules", name),
-    registry: Boolean(parsed.registry),
-    importPath
-  };
-}
-function parsePageSize(size) {
-  const [width, height, ...others] = `${size}`.split(",");
-  if (!width || others.length) {
-    throw new Error(`Cannot parse size: ${size}`);
-  } else if (width && height) {
-    return {
-      width,
-      height
-    };
-  } else {
-    return {
-      format: width
-    };
-  }
-}
-function parseFileMetadata({
-  contentType,
-  sourcePath,
-  workspaceDir,
-  themesDir,
-  documentMetadataReader
-}) {
-  const sourceDir = upath2.dirname(sourcePath);
-  let title;
-  let themes;
-  if (documentMetadataReader) {
-    const metadata = readMarkdownMetadata(sourcePath, documentMetadataReader);
-    title = metadata.title;
-    if (metadata.vfm?.theme && themesDir) {
-      themes = [metadata.vfm.theme].flat().filter(
-        (entry) => !!entry && (typeof entry === "string" || typeof entry === "object")
-      ).map(
-        (theme) => parseTheme({
-          theme,
-          context: sourceDir,
-          workspaceDir,
-          themesDir
-        })
-      );
-    }
-  } else if (contentType === "text/html" || contentType === "application/xhtml+xml") {
-    const content = fs3.readFileSync(sourcePath, "utf8");
-    title = content.match(/<title>([^<]*)<\/title>/)?.[1] || void 0;
-  }
-  return { title, themes };
-}
-function parseCustomStyle({
-  customStyle,
-  entryContextDir
-}) {
-  if (isValidUri(customStyle)) {
-    return customStyle;
-  }
-  const stylePath = upath2.resolve(entryContextDir, customStyle);
-  if (!pathContains(entryContextDir, stylePath)) {
-    throw Error(
-      `Custom style file ${customStyle} is not in ${entryContextDir}. Make sure the file is located in the context directory or a subdirectory.`
-    );
-  }
-  if (!fs3.existsSync(stylePath)) {
-    throw new Error(`Custom style file not found: ${customStyle}`);
-  }
-  return pathToFileURL2(stylePath).href.slice(
-    pathToFileURL2(entryContextDir).href.replace(/\/$/, "").length + 1
-  );
-}
-function resolveTaskConfig(config, options) {
-  const context = options.cwd ?? cwd;
-  Logger.debug("resolveTaskConfig > context %s", context);
-  const entryContextDir = config.entryContext ? upath2.resolve(context, config.entryContext) : context;
-  const language = config.language;
-  const readingProgression = config.readingProgression;
-  const size = config.size ? parsePageSize(config.size) : void 0;
-  const cropMarks = options.cropMarks ?? false;
-  const bleed = options.bleed;
-  const cropOffset = options.cropOffset;
-  const css = options.css;
-  const singleDoc = options.singleDoc ?? false;
-  const quick = options.quick ?? false;
-  const temporaryFilePrefix = config.temporaryFilePrefix ?? `.vs-${Date.now()}.`;
-  const vfmOptions = {
-    ...config?.vfm,
-    hardLineBreaks: config?.vfm?.hardLineBreaks ?? false,
-    disableFormatHtml: config?.vfm?.disableFormatHtml ?? false
-  };
-  const timeout = config.timeout ?? 3e5;
-  const sandbox = options.sandbox ?? false;
-  const browser = (() => {
-    const type = config.browser?.type ?? "chrome";
-    const platform = detectBrowserPlatform();
-    return {
-      type,
-      tag: config.browser?.tag ?? (platform ? DEFAULT_BROWSER_VERSIONS[type][platform] : "latest"),
-      executablePath: options.executableBrowser
-    };
-  })();
-  const proxyServer = options.proxyServer ?? process.env.HTTP_PROXY ?? void 0;
-  const proxy = proxyServer ? {
-    server: proxyServer,
-    bypass: options.proxyBypass ?? process.env.NOPROXY ?? void 0,
-    username: options.proxyUser,
-    password: options.proxyPass
-  } : void 0;
-  const image = config.image ?? `${CONTAINER_URL}:${cliVersion}`;
-  const viewer = config.viewer ?? void 0;
-  const viewerParam = config.viewerParam ?? void 0;
-  const logLevel = options.logLevel ?? "silent";
-  const ignoreHttpsErrors = options.ignoreHttpsErrors ?? false;
-  const base = config.base ?? "/vivliostyle";
-  const staticRoutes = config.static ?? {};
-  const viteConfig = config.vite;
-  const viteConfigFile = config.viteConfigFile ?? true;
-  const customStyle = options.style && parseCustomStyle({ customStyle: options.style, entryContextDir }) || void 0;
-  const customUserStyle = options.userStyle && parseCustomStyle({ customStyle: options.userStyle, entryContextDir }) || void 0;
-  const outputs = (() => {
-    const defaultPdfOptions = {
-      format: "pdf",
-      renderMode: options.renderMode ?? "local",
-      preflight: options.preflight ?? (config.pressReady ? "press-ready" : void 0),
-      preflightOption: options.preflightOption ?? []
-    };
-    if (config.output) {
-      return config.output.map((target) => {
-        const outputPath = upath2.resolve(context, target.path);
-        const format = target.format;
-        switch (format) {
-          case "pdf":
-            return {
-              ...defaultPdfOptions,
-              ...target,
-              format,
-              path: outputPath
-            };
-          case "epub":
-            return {
-              ...target,
-              format,
-              path: outputPath,
-              version: EPUB_OUTPUT_VERSION
-            };
-          case "webpub":
-            return {
-              ...target,
-              format,
-              path: outputPath
-            };
-          default:
-            return format;
-        }
-      });
-    }
-    const filename = config.title ? `${config.title}.pdf` : "output.pdf";
-    return [
-      {
-        ...defaultPdfOptions,
-        path: upath2.resolve(context, filename)
-      }
-    ];
-  })();
-  const { server, rootUrl } = (() => {
-    let host = config.server?.host ?? false;
-    let allowedHosts = config.server?.allowedHosts || [];
-    const port = config.server?.port ?? 13e3;
-    if (outputs.some(
-      (target) => target.format === "pdf" && target.renderMode === "docker"
-    ) && !isInContainer()) {
-      host = true;
-      if (Array.isArray(allowedHosts) && !allowedHosts.includes(CONTAINER_LOCAL_HOSTNAME)) {
-        allowedHosts.push(CONTAINER_LOCAL_HOSTNAME);
-      }
-    }
-    const rootHostname = !host ? "localhost" : host === true ? "0.0.0.0" : host;
-    return {
-      server: {
-        host,
-        port,
-        proxy: config.server?.proxy ?? {},
-        allowedHosts
-      },
-      rootUrl: `http://${rootHostname}:${port}`
-    };
-  })();
-  const cover = config.cover && {
-    src: upath2.resolve(entryContextDir, config.cover.src),
-    name: config.cover.name || COVER_HTML_IMAGE_ALT
-  };
-  const copyAsset = {
-    includes: config.copyAsset?.includes ?? config.includeAssets ?? [],
-    excludes: config.copyAsset?.excludes ?? [],
-    fileExtensions: [
-      .../* @__PURE__ */ new Set([
-        ...DEFAULT_ASSET_EXTENSIONS,
-        ...config.copyAsset?.includeFileExtensions ?? []
-      ])
-    ].filter(
-      (ext) => !(config.copyAsset?.excludeFileExtensions ?? []).includes(ext)
-    )
-  };
-  const themeIndexes = /* @__PURE__ */ new Set();
-  const projectConfig = !options.config && options.input ? resolveSingleInputConfig({
-    config,
-    input: options.input,
-    context,
-    temporaryFilePrefix,
-    themeIndexes,
-    base
-  }) : resolveComposedProjectConfig({
-    config,
-    context,
-    entryContextDir,
-    outputs,
-    temporaryFilePrefix,
-    themeIndexes,
-    cover
-  });
-  for (const output of outputs) {
-    const relPath = upath2.relative(context, output.path);
-    if (pathContains(output.path, entryContextDir) || pathEquals(output.path, entryContextDir)) {
-      throw new Error(
-        `The output path is set to "${relPath}", but this will overwrite the original manuscript file. Please specify a different path.`
-      );
-    }
-    if (pathContains(output.path, projectConfig.workspaceDir) || pathEquals(output.path, projectConfig.workspaceDir)) {
-      throw new Error(
-        `The output path is set to "${relPath}", but this will overwrite the working directory of Vivliostyle. Please specify a different path.`
-      );
-    }
-  }
-  const { entries, workspaceDir } = projectConfig;
-  const duplicatedTarget = entries.find(
-    (v1, i) => entries.findLastIndex((v2) => v1.target === v2.target) !== i
-  )?.target;
-  if (duplicatedTarget) {
-    const sourceFile = entries.find(
-      (entry) => entry.target === duplicatedTarget && entry.source?.type === "file"
-    )?.source;
-    throw new Error(
-      `The output path "${upath2.relative(workspaceDir, duplicatedTarget)}" will overwrite existing content.` + (sourceFile ? ` Please choose a different name for the source file: ${sourceFile.pathname}` : "")
-    );
-  }
-  const resolvedConfig = {
-    ...projectConfig,
-    entryContextDir,
-    outputs,
-    themeIndexes,
-    copyAsset,
-    temporaryFilePrefix,
-    size,
-    cropMarks,
-    bleed,
-    cropOffset,
-    css,
-    customStyle,
-    customUserStyle,
-    singleDoc,
-    quick,
-    language,
-    readingProgression,
-    vfmOptions,
-    cover,
-    timeout,
-    sandbox,
-    browser,
-    proxy,
-    image,
-    viewer,
-    viewerParam,
-    logLevel,
-    ignoreHttpsErrors,
-    base,
-    server,
-    static: staticRoutes,
-    rootUrl,
-    viteConfig,
-    viteConfigFile
-  };
-  return resolvedConfig;
-}
-function resolveSingleInputConfig({
-  config,
-  input,
-  context,
-  temporaryFilePrefix,
-  themeIndexes,
-  base
-}) {
-  Logger.debug("entering single entry config mode");
-  let serverRootDir;
-  let sourcePath;
-  let workspaceDir;
-  const inputFormat = input.format;
-  const title = config?.title;
-  const author = config?.author;
-  const entries = [];
-  const exportAliases = [];
-  let isLocalResource = true;
-  if (isValidUri(input.entry)) {
-    const url = new URL(input.entry);
-    if (url.protocol === "file:") {
-      sourcePath = fileURLToPath(url);
-    } else {
-      isLocalResource = false;
-      sourcePath = input.entry;
-    }
-  } else {
-    sourcePath = upath2.resolve(context, input.entry);
-  }
-  if (isLocalResource) {
-    statFileSync(sourcePath);
-    switch (input.format) {
-      case "webbook":
-      case "markdown":
-      case "pub-manifest":
-      case "epub":
-        workspaceDir = upath2.dirname(sourcePath);
-        break;
-      case "epub-opf": {
-        const rootDir = getEpubRootDir(sourcePath);
-        if (!rootDir) {
-          throw new Error(
-            `Could not determine the EPUB root directory for the OPF file: ${sourcePath}`
-          );
-        }
-        workspaceDir = rootDir;
-        break;
-      }
-      default:
-        return input.format;
-    }
-    serverRootDir = workspaceDir;
-  } else {
-    serverRootDir = UseTemporaryServerRoot;
-    workspaceDir = context;
-  }
-  const themesDir = upath2.resolve(workspaceDir, "themes");
-  if (input.format === "markdown") {
-    const contentType = "text/markdown";
-    const documentProcessor = {
-      processorFactory: config.documentProcessor ?? VFM,
-      metadataReader: config.documentMetadataReader ?? readMetadata
-    };
-    const metadata = parseFileMetadata({
-      contentType,
-      sourcePath,
-      workspaceDir,
-      documentMetadataReader: documentProcessor.metadataReader
-    });
-    const target = toHtmlExtension(
-      upath2.resolve(
-        workspaceDir,
-        `${temporaryFilePrefix}${upath2.basename(sourcePath)}`
-      )
-    );
-    touchTmpFile(target);
-    const themes = metadata.themes ?? config.theme?.map(
-      (theme) => parseTheme({
-        theme,
-        context,
-        workspaceDir,
-        themesDir
-      })
-    ) ?? [];
-    themes.forEach((t) => themeIndexes.add(t));
-    entries.push({
-      contentType,
-      source: {
-        type: "file",
-        pathname: sourcePath,
-        contentType,
-        documentProcessor
-      },
-      target,
-      title: metadata.title,
-      themes
-    });
-    exportAliases.push({
-      source: target,
-      target: upath2.resolve(
-        upath2.dirname(target),
-        toHtmlExtension(upath2.basename(sourcePath))
-      )
-    });
-  }
-  let fallbackTitle;
-  let viewerInput;
-  if (inputFormat === "markdown") {
-    const manifestPath = upath2.resolve(
-      workspaceDir,
-      `${temporaryFilePrefix}${MANIFEST_FILENAME}`
-    );
-    touchTmpFile(manifestPath);
-    exportAliases.push({
-      source: manifestPath,
-      target: upath2.resolve(workspaceDir, MANIFEST_FILENAME)
-    });
-    fallbackTitle = entries.length === 1 && entries[0].title ? entries[0].title : upath2.basename(sourcePath);
-    viewerInput = {
-      type: "webpub",
-      manifestPath,
-      needToGenerateManifest: true
-    };
-  } else if (inputFormat === "webbook") {
-    let webbookEntryUrl;
-    let webbookPath;
-    if (isValidUri(sourcePath)) {
-      const url = new URL(sourcePath);
-      webbookEntryUrl = url.href;
-    } else {
-      const rootFileUrl = pathToFileURL2(workspaceDir).href;
-      const urlPath = pathToFileURL2(sourcePath).href.slice(rootFileUrl.length);
-      webbookEntryUrl = `${base}${urlPath}`;
-      webbookPath = sourcePath;
-    }
-    viewerInput = { type: "webbook", webbookEntryUrl, webbookPath };
-  } else if (inputFormat === "pub-manifest") {
-    viewerInput = {
-      type: "webpub",
-      manifestPath: sourcePath,
-      needToGenerateManifest: false
-    };
-  } else if (inputFormat === "epub-opf") {
-    viewerInput = { type: "epub-opf", epubOpfPath: sourcePath };
-  } else if (inputFormat === "epub") {
-    viewerInput = {
-      type: "epub",
-      epubPath: sourcePath,
-      epubTmpOutputDir: upath2.join(
-        sourcePath,
-        `../${temporaryFilePrefix}${upath2.basename(sourcePath)}`
-      )
-    };
-  } else {
-    return inputFormat;
-  }
-  return {
-    serverRootDir,
-    workspaceDir,
-    themesDir,
-    entries,
-    input: {
-      format: inputFormat,
-      entry: sourcePath
-    },
-    viewerInput,
-    exportAliases,
-    title: title || fallbackTitle,
-    author
-  };
-}
-function resolveComposedProjectConfig({
-  config,
-  context,
-  entryContextDir,
-  outputs,
-  temporaryFilePrefix,
-  themeIndexes,
-  cover
-}) {
-  Logger.debug("entering composed project config mode");
-  const workspaceDir = upath2.resolve(
-    context,
-    config.workspaceDir ?? ".vivliostyle"
-  );
-  const themesDir = upath2.resolve(workspaceDir, "themes");
-  const pkgJsonPath = upath2.resolve(context, "package.json");
-  const pkgJson = fs3.existsSync(pkgJsonPath) ? readJSON(pkgJsonPath) : void 0;
-  if (pkgJson) {
-    Logger.debug("located package.json path", pkgJsonPath);
-  }
-  const exportAliases = [];
-  const rootThemes = config.theme?.map(
-    (theme) => parseTheme({
-      theme,
-      context,
-      workspaceDir,
-      themesDir
-    })
-  ) ?? [];
-  rootThemes.forEach((t) => themeIndexes.add(t));
-  const tocConfig = {
-    tocTitle: config.toc?.title ?? config?.tocTitle ?? TOC_TITLE,
-    target: upath2.resolve(workspaceDir, config.toc?.htmlPath ?? TOC_FILENAME),
-    sectionDepth: config.toc?.sectionDepth ?? 0,
-    transform: {
-      transformDocumentList: config.toc?.transformDocumentList,
-      transformSectionList: config.toc?.transformSectionList
-    }
-  };
-  const coverHtml = config.cover && ("htmlPath" in config.cover && !config.cover.htmlPath ? void 0 : upath2.resolve(
-    workspaceDir,
-    config.cover?.htmlPath || COVER_HTML_FILENAME
-  ));
-  const ensureCoverImage = (src) => {
-    const absPath = src && upath2.resolve(entryContextDir, src);
-    if (absPath) {
-      statFileSync(absPath, {
-        errorMessage: "Specified cover image does not exist"
-      });
-    }
-    return absPath;
-  };
-  const projectTitle = config?.title ?? pkgJson?.name;
-  const projectAuthor = config?.author ?? pkgJson?.author;
-  const rootDocumentProcessor = {
-    processorFactory: config.documentProcessor ?? VFM,
-    metadataReader: config.documentMetadataReader ?? readMetadata
-  };
-  const isContentsEntry = (entry) => entry.rel === "contents";
-  const isCoverEntry = (entry) => entry.rel === "cover";
-  const isArticleEntry = (entry) => !isContentsEntry(entry) && !isCoverEntry(entry);
-  function parseEntry(entry) {
-    const getInputInfo = (entryPath) => {
-      if (/^https?:/.test(entryPath)) {
-        return {
-          type: "uri",
-          href: entryPath,
-          rootDir: upath2.join(workspaceDir, new URL(entryPath).host)
-        };
-      } else if (entryPath.startsWith("/")) {
-        return {
-          type: "uri",
-          href: entryPath,
-          rootDir: upath2.join(workspaceDir, "localhost")
-        };
-      }
-      const pathname = upath2.resolve(entryContextDir, entryPath);
-      statFileSync(pathname);
-      const rawContentType = mime(pathname);
-      const documentProcessor = {
-        processorFactory: "documentProcessor" in entry && entry.documentProcessor || rootDocumentProcessor.processorFactory,
-        metadataReader: "documentMetadataReader" in entry && entry.documentMetadataReader || rootDocumentProcessor.metadataReader
-      };
-      const hasCustomProcessor = !!(documentProcessor.processorFactory !== VFM || documentProcessor.metadataReader !== readMetadata);
-      const contentType = hasCustomProcessor && rawContentType !== "text/markdown" ? "text/x-vivliostyle-custom" : rawContentType;
-      if (!isManuscriptMediaType(contentType) || contentType === "text/plain") {
-        throw new Error(
-          `Invalid manuscript type ${rawContentType} detected: ${entry}`
-        );
-      }
-      const useDocumentProcessor = contentType === "text/markdown" || contentType === "text/x-vivliostyle-custom";
-      return {
-        type: "file",
-        pathname,
-        contentType,
-        metadata: parseFileMetadata({
-          contentType,
-          sourcePath: pathname,
-          workspaceDir,
-          themesDir,
-          documentMetadataReader: useDocumentProcessor ? documentProcessor.metadataReader : void 0
-        }),
-        ...useDocumentProcessor && { documentProcessor }
-      };
-    };
-    const getTargetPath = (source) => {
-      switch (source.type) {
-        case "file":
-          return upath2.resolve(
-            workspaceDir,
-            toHtmlExtension(upath2.relative(entryContextDir, source.pathname))
-          );
-        case "uri": {
-          const url = new URL(source.href, "a://dummy");
-          let pathname = url.pathname;
-          if (!/\.\w+$/.test(pathname)) {
-            pathname = `${pathname.replace(/\/$/, "")}/index.html`;
-          }
-          return upath2.join(source.rootDir, pathname);
-        }
-        default:
-          return source;
-      }
-    };
-    if ((isContentsEntry(entry) || isCoverEntry(entry)) && entry.path) {
-      const source = upath2.resolve(entryContextDir, entry.path);
-      try {
-        statFileSync(source);
-      } catch (error) {
-        Logger.logWarn(
-          `The "path" option is set but the file does not exist: ${source}
-Maybe you want to set the "output" field instead.`
-        );
-        entry.output = entry.path;
-        entry.path = void 0;
-      }
-    }
-    if (isContentsEntry(entry)) {
-      const inputInfo = entry.path ? getInputInfo(entry.path) : void 0;
-      const { metadata, ...template } = inputInfo || {};
-      let target = entry.output ? upath2.resolve(workspaceDir, entry.output) : inputInfo && getTargetPath(inputInfo);
-      const themes = entry.theme ? [entry.theme].flat().map(
-        (theme) => parseTheme({
-          theme,
-          context,
-          workspaceDir,
-          themesDir
-        })
-      ) : metadata?.themes ?? [...rootThemes];
-      themes.forEach((t) => themeIndexes.add(t));
-      target ??= tocConfig.target;
-      if (inputInfo?.type === "file" && pathEquals(inputInfo.pathname, target)) {
-        const tmpPath = upath2.resolve(
-          upath2.dirname(target),
-          `${temporaryFilePrefix}${upath2.basename(target)}`
-        );
-        exportAliases.push({ source: tmpPath, target });
-        touchTmpFile(tmpPath);
-        target = tmpPath;
-      }
-      const parsedEntry = {
-        rel: "contents",
-        ...tocConfig,
-        target,
-        title: entry.title ?? metadata?.title ?? projectTitle,
-        themes,
-        pageBreakBefore: entry.pageBreakBefore,
-        pageCounterReset: entry.pageCounterReset,
-        ..."type" in template && { template }
-      };
-      return parsedEntry;
-    }
-    if (isCoverEntry(entry)) {
-      const inputInfo = entry.path ? getInputInfo(entry.path) : void 0;
-      const { metadata, ...template } = inputInfo || {};
-      let target = entry.output ? upath2.resolve(workspaceDir, entry.output) : inputInfo && getTargetPath(inputInfo);
-      const themes = entry.theme ? [entry.theme].flat().map(
-        (theme) => parseTheme({
-          theme,
-          context,
-          workspaceDir,
-          themesDir
-        })
-      ) : metadata?.themes ?? [];
-      themes.forEach((t) => themeIndexes.add(t));
-      const coverImageSrc = ensureCoverImage(entry.imageSrc || cover?.src);
-      if (!coverImageSrc) {
-        throw new Error(
-          `A CoverEntryConfig is set in the entry list but a location of cover file is not set. Please set 'cover' property in your config file.`
-        );
-      }
-      target ??= upath2.resolve(
-        workspaceDir,
-        entry.path || coverHtml || COVER_HTML_FILENAME
-      );
-      if (inputInfo?.type === "file" && pathEquals(inputInfo.pathname, target)) {
-        const tmpPath = upath2.resolve(
-          upath2.dirname(target),
-          `${temporaryFilePrefix}${upath2.basename(target)}`
-        );
-        exportAliases.push({ source: tmpPath, target });
-        touchTmpFile(tmpPath);
-        target = tmpPath;
-      }
-      const parsedEntry = {
-        rel: "cover",
-        target,
-        title: entry.title ?? metadata?.title ?? projectTitle,
-        themes,
-        coverImageSrc,
-        coverImageAlt: entry.imageAlt || cover?.name || COVER_HTML_IMAGE_ALT,
-        pageBreakBefore: entry.pageBreakBefore,
-        ..."type" in template && { template }
-      };
-      return parsedEntry;
-    }
-    if (isArticleEntry(entry)) {
-      const inputInfo = getInputInfo(entry.path);
-      const { metadata, ...source } = inputInfo;
-      const target = entry.output ? upath2.resolve(workspaceDir, entry.output) : getTargetPath(inputInfo);
-      const themes = entry.theme ? [entry.theme].flat().map(
-        (theme) => parseTheme({ theme, context, workspaceDir, themesDir })
-      ) : metadata?.themes ?? [...rootThemes];
-      themes.forEach((t) => themeIndexes.add(t));
-      const parsedEntry = {
-        contentType: inputInfo.type === "file" ? inputInfo.contentType : "text/html",
-        source,
-        target,
-        title: entry.title ?? metadata?.title ?? projectTitle,
-        themes,
-        ...entry.rel && { rel: entry.rel }
-      };
-      return parsedEntry;
-    }
-    return entry;
-  }
-  const entries = config.entry.map(parseEntry);
-  let fallbackProjectTitle;
-  if (!projectTitle) {
-    if (entries.length === 1 && entries[0].title) {
-      fallbackProjectTitle = entries[0].title;
-    } else {
-      fallbackProjectTitle = upath2.basename(outputs[0].path);
-    }
-  }
-  if (!!config?.toc && !entries.find(({ rel }) => rel === "contents")) {
-    entries.unshift({
-      rel: "contents",
-      ...tocConfig,
-      themes: [...rootThemes]
-    });
-  }
-  if (cover && coverHtml && !entries.find(({ rel }) => rel === "cover")) {
-    entries.unshift({
-      rel: "cover",
-      target: coverHtml,
-      title: projectTitle,
-      themes: [],
-      // Don't inherit rootThemes for cover documents
-      coverImageSrc: ensureCoverImage(cover.src),
-      coverImageAlt: cover.name
-    });
-  }
-  return {
-    serverRootDir: context,
-    workspaceDir,
-    themesDir,
-    entries,
-    input: {
-      format: "pub-manifest",
-      entry: upath2.join(workspaceDir, MANIFEST_FILENAME)
-    },
-    viewerInput: {
-      type: "webpub",
-      manifestPath: upath2.join(workspaceDir, MANIFEST_FILENAME),
-      needToGenerateManifest: true
-    },
-    exportAliases,
-    title: projectTitle || fallbackProjectTitle,
-    author: projectAuthor
-  };
-}
-
-// src/vite/vite-plugin-browser.ts
-import "vite";
-
-// src/browser.ts
-import fs4 from "node:fs";
-import upath3 from "upath";
-var browserEnumMap = {
-  chrome: "chrome",
-  chromium: "chromium",
-  firefox: "firefox"
-};
-async function launchBrowser({
-  browserType,
-  proxy,
-  executablePath,
-  headless,
-  noSandbox,
-  disableDevShmUsage,
-  ignoreHttpsErrors
-}) {
-  const puppeteer = await importNodeModule("puppeteer-core");
-  const args = [];
-  if (browserType === "chrome" || browserType === "chromium") {
-    args.push(
-      "--disable-field-trial-config",
-      "--disable-back-forward-cache",
-      "--disable-component-update",
-      "--no-default-browser-check",
-      "--disable-features=AcceptCHFrame,AvoidUnnecessaryBeforeUnloadCheckSync,DestroyProfileOnBrowserClose,DialMediaRouteProvider,GlobalMediaControls,HttpsUpgrades,LensOverlay,MediaRouter,PaintHolding,ThirdPartyStoragePartitioning,Translate,AutoDeElevate,RenderDocument",
-      "--enable-features=CDPScreenshotNewSurface",
-      "--no-service-autorun",
-      "--unsafely-disable-devtools-self-xss-warnings",
-      "--edge-skip-compat-layer-relaunch"
-    );
-    if (process.platform === "darwin") {
-      args.push("--enable-unsafe-swiftshader");
-    }
-    if (noSandbox) {
-      args.push("--no-sandbox");
-    }
-    if (headless) {
-      args.push(
-        "--hide-scrollbars",
-        "--mute-audio",
-        "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4"
-      );
-    }
-    if (proxy?.server) {
-      const proxyURL = new URL(proxy.server);
-      const isSocks = proxyURL.protocol === "socks5:";
-      if (isSocks) {
-        args.push(
-          `--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`
-        );
-      }
-      args.push(`--proxy-server=${proxy.server}`);
-      const proxyBypassRules = [];
-      if (proxy.bypass) {
-        proxyBypassRules.push(
-          ...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t)
-        );
-      }
-      proxyBypassRules.push("<-loopback>");
-      args.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
-    }
-    args.push("--disable-web-security");
-    if (disableDevShmUsage) {
-      args.push("--disable-dev-shm-usage");
-    }
-    if (headless) {
-      args.push("--force-device-scale-factor=1");
-    }
-    if (isRunningOnWSL()) {
-      args.push("--disable-gpu");
-    }
-    args.push("--lang=en");
-    if (!headless && process.platform === "darwin") {
-      args.push("-AppleLanguages", "(en)");
-    }
-    args.push("--no-startup-window");
-  }
-  const launchOptions = {
-    executablePath,
-    args,
-    browser: browserType === "chromium" ? "chrome" : browserType,
-    headless,
-    acceptInsecureCerts: ignoreHttpsErrors,
-    waitForInitialPage: false
-  };
-  Logger.debug("launchOptions %O", launchOptions);
-  const browser = await puppeteer.launch({
-    ...launchOptions,
-    env: { ...process.env, LANG: "en.UTF-8" }
-  });
-  registerExitHandler("Closing browser", () => {
-    browser.close();
-  });
-  const [browserContext] = browser.browserContexts();
-  return { browser, browserContext };
-}
-function getPuppeteerCacheDir() {
-  if (isInContainer()) {
-    return "/opt/puppeteer";
-  }
-  return upath3.join(getCacheDir(), "browsers");
-}
-async function resolveBuildId({
-  type,
-  tag,
-  browsers
-}) {
-  const cacheDataFilename = upath3.join(
-    getPuppeteerCacheDir(),
-    "build-ids.json"
-  );
-  let cacheData;
-  try {
-    cacheData = JSON.parse(fs4.readFileSync(cacheDataFilename, "utf-8"));
-    if (Date.now() - cacheData.createdAt > 24 * 60 * 60 * 1e3) {
-      cacheData = { createdAt: Date.now(), buildIds: {} };
-    }
-  } catch (_) {
-    cacheData = { createdAt: Date.now(), buildIds: {} };
-  }
-  if (cacheData.buildIds[type]?.[tag]) {
-    return cacheData.buildIds[type][tag];
-  }
-  const platform = detectBrowserPlatform();
-  if (!platform) {
-    throw new Error("The current platform is not supported.");
-  }
-  const buildId = await browsers.resolveBuildId(
-    browserEnumMap[type],
-    platform,
-    tag
-  );
-  (cacheData.buildIds[type] ??= {})[tag] = buildId;
-  fs4.mkdirSync(upath3.dirname(cacheDataFilename), { recursive: true });
-  fs4.writeFileSync(cacheDataFilename, JSON.stringify(cacheData));
-  return buildId;
-}
-async function cleanupOutdatedBrowsers() {
-  for (const browser of Object.values(browserEnumMap)) {
-    const browsersDir = upath3.join(getPuppeteerCacheDir(), browser);
-    if (!fs4.existsSync(browsersDir)) {
-      continue;
-    }
-    const entries = fs4.readdirSync(browsersDir);
-    for (const entry of entries) {
-      const entryPath = upath3.join(browsersDir, entry);
-      const stat = fs4.statSync(entryPath);
-      if (!stat.isDirectory() || Date.now() - stat.mtimeMs > 7 * 24 * 60 * 60 * 1e3) {
-        Logger.debug(`Removing outdated browser at ${entryPath}`);
-        await fs4.promises.rm(entryPath, { recursive: true, force: true });
-      }
-    }
-  }
-}
-async function getExecutableBrowserPath({
-  type,
-  tag
-}) {
-  const browsers = await importNodeModule("@puppeteer/browsers");
-  const buildId = await resolveBuildId({ type, tag, browsers });
-  return browsers.computeExecutablePath({
-    cacheDir: getPuppeteerCacheDir(),
-    browser: browserEnumMap[type],
-    buildId
-  });
-}
-function checkBrowserAvailability(path) {
-  return fs4.existsSync(path);
-}
-async function downloadBrowser({
-  type,
-  tag
-}) {
-  const browsers = await importNodeModule("@puppeteer/browsers");
-  const buildId = await resolveBuildId({ type, tag, browsers });
-  let installedBrowser;
-  if (isInContainer()) {
-    const defaultBrowserVersion = getDefaultBrowserTag("chrome");
-    Logger.logWarn(
-      `The container you are using already includes a browser (chrome@${defaultBrowserVersion}); however, the specified browser ${type}@${tag} was not found. Downloading the browser inside the container may take a long time. Consider using a container image that includes the required browser version.`
-    );
-  }
-  {
-    var _stack = [];
-    try {
-      const _2 = __using(_stack, Logger.suspendLogging(
-        "Rendering browser is not installed yet. Downloading now."
-      ));
-      installedBrowser = await browsers.install({
-        cacheDir: getPuppeteerCacheDir(),
-        browser: browserEnumMap[type],
-        buildId,
-        downloadProgressCallback: "default"
-      });
-    } catch (_) {
-      var _error = _, _hasError = true;
-    } finally {
-      __callDispose(_stack, _error, _hasError);
-    }
-  }
-  return installedBrowser.executablePath;
-}
-async function launchPreview({
-  mode,
-  url,
-  onBrowserOpen,
-  onPageOpen,
-  config: { browser: browserConfig, proxy, sandbox, ignoreHttpsErrors }
-}) {
-  let executableBrowser = browserConfig.executablePath;
-  Logger.debug(`Specified browser path: ${executableBrowser}`);
-  if (executableBrowser) {
-    if (!checkBrowserAvailability(executableBrowser)) {
-      throw new Error(
-        `Cannot find the browser. Please check the executable browser path: ${executableBrowser}`
-      );
-    }
-  } else if (detectBrowserPlatform() === "linux_arm" && (browserConfig.type === "chrome" || browserConfig.type === "chromium")) {
-    Logger.logInfo(
-      "The official Chrome/Chromium binaries are not available for ARM64 Linux. Using the system-installed Chromium browser instead."
-    );
-    executableBrowser = "/usr/bin/chromium";
-  } else {
-    executableBrowser = await getExecutableBrowserPath(browserConfig);
-    Logger.debug(`Using default browser: ${executableBrowser}`);
-    if (!checkBrowserAvailability(executableBrowser)) {
-      await cleanupOutdatedBrowsers();
-      await downloadBrowser(browserConfig);
-    }
-  }
-  const { browser, browserContext } = await launchBrowser({
-    browserType: browserConfig.type,
-    proxy,
-    executablePath: executableBrowser,
-    headless: mode === "build",
-    noSandbox: !sandbox,
-    disableDevShmUsage: isInContainer(),
-    ignoreHttpsErrors
-  });
-  await onBrowserOpen?.(browser);
-  const page = (await browserContext.pages())[0] ?? await browserContext.newPage();
-  await page.setViewport(
-    mode === "build" ? (
-      // This viewport size is important to detect headless environment in Vivliostyle viewer
-      // https://github.com/vivliostyle/vivliostyle.js/blob/73bcf323adcad80126b0175630609451ccd09d8a/packages/core/src/vivliostyle/vgen.ts#L2489-L2500
-      { width: 800, height: 600 }
-    ) : null
-  );
-  await onPageOpen?.(page);
-  page.on("dialog", () => {
-  });
-  if (proxy?.username && proxy?.password) {
-    await page.authenticate({
-      username: proxy.username,
-      password: proxy.password
-    });
-  }
-  await page.goto(url);
-  return { browser, page };
-}
-
-// src/server.ts
-import fs10 from "node:fs";
-import { URL as URL2 } from "node:url";
-import upath11 from "upath";
-import {
-  createServer,
-  preview
-} from "vite";
-
-// src/vite/vite-plugin-dev-server.ts
-import escapeRe from "escape-string-regexp";
-import { pathToFileURL as pathToFileURL6 } from "node:url";
-import sirv from "sirv";
-import upath8 from "upath";
-import "vite";
-
-// src/processor/compile.ts
-import "@vivliostyle/jsdom";
-import { copy as copy3, move } from "fs-extra/esm";
-import fs8 from "node:fs";
-import upath7 from "upath";
-import serializeToXml2 from "w3c-xmlserializer";
-import MIMEType2 from "whatwg-mimetype";
-
-// src/output/webbook.ts
-import { copy as copy2 } from "fs-extra/esm";
-import { lookup as mime3 } from "mime-types";
-import fs6 from "node:fs";
-import { pathToFileURL as pathToFileURL5 } from "node:url";
-import { glob } from "tinyglobby";
-import upath6 from "upath";
-
-// src/processor/html.tsx
-import jsdom, {
-  ResourceLoader as BaseResourceLoader,
-  JSDOM
-} from "@vivliostyle/jsdom";
-import DOMPurify from "dompurify";
-import { toHtml } from "hast-util-to-html";
-import { fileURLToPath as fileURLToPath2, pathToFileURL as pathToFileURL3 } from "node:url";
-import upath4 from "upath";
-import MIMEType from "whatwg-mimetype";
-import { jsx, jsxs } from "hastscript/jsx-runtime";
-var createVirtualConsole = (onError) => {
-  const virtualConsole = new jsdom.VirtualConsole();
-  virtualConsole.on("error", (message) => {
-    Logger.debug("[JSDOM Console] error:", message);
-  });
-  virtualConsole.on("warn", (message) => {
-    Logger.debug("[JSDOM Console] warn:", message);
-  });
-  virtualConsole.on("log", (message) => {
-    Logger.debug("[JSDOM Console] log:", message);
-  });
-  virtualConsole.on("info", (message) => {
-    Logger.debug("[JSDOM Console] info:", message);
-  });
-  virtualConsole.on("dir", (message) => {
-    Logger.debug("[JSDOM Console] dir:", message);
-  });
-  virtualConsole.on("jsdomError", (error) => {
-    if (error.message === "Could not parse CSS stylesheet") {
-      return;
-    }
-    onError(
-      new DetailError(
-        "Error occurred when loading content",
-        error.stack ?? error.message
-      )
-    );
-  });
-  return virtualConsole;
-};
-var htmlPurify = DOMPurify(
-  // @ts-expect-error: jsdom.DOMWindow should have trustedTypes property
-  new JSDOM("").window
-);
-var ResourceLoader = class _ResourceLoader extends BaseResourceLoader {
-  static dataUrlOrigin = "http://localhost/";
-  fetcherMap = /* @__PURE__ */ new Map();
-  fetch(url, options) {
-    Logger.debug(`[JSDOM] Fetching resource: ${url}`);
-    const fetcher = super.fetch(url, options);
-    if (fetcher) {
-      this.fetcherMap.set(url, fetcher);
-    }
-    return fetcher;
-  }
-  static async saveFetchedResources({
-    fetcherMap,
-    rootUrl,
-    outputDir,
-    onError
-  }) {
-    const rootHref = rootUrl.startsWith("data:") ? _ResourceLoader.dataUrlOrigin : /^https?:/i.test(rootUrl) ? new URL("/", rootUrl).href : new URL(".", rootUrl).href;
-    const normalizeToLocalPath = (urlString, mimeType) => {
-      let url = new URL(urlString);
-      url.hash = "";
-      if (mimeType === "text/html" && !/\.html?$/.test(url.pathname)) {
-        url.pathname = `${url.pathname.replace(/\/$/, "")}/index.html`;
-      }
-      let relTarget = upath4.relative(rootHref, url.href);
-      return decodeURI(relTarget);
-    };
-    const fetchedResources = [];
-    await Promise.allSettled(
-      [...fetcherMap.entries()].flatMap(async ([url, fetcher]) => {
-        if (!url.startsWith(rootHref)) {
-          return [];
-        }
-        return fetcher.then(async (buffer) => {
-          let encodingFormat;
-          try {
-            const contentType = fetcher.response?.headers["content-type"];
-            if (contentType) {
-              encodingFormat = new MIMEType(contentType).essence;
-            }
-          } catch (e) {
-          }
-          const relTarget = normalizeToLocalPath(url, encodingFormat);
-          const target = upath4.join(outputDir, relTarget);
-          fetchedResources.push({ url: relTarget, encodingFormat });
-          writeFileIfChanged(target, buffer);
-        }).catch(onError);
-      })
-    );
-    return fetchedResources;
-  }
-};
-async function getJsdomFromUrlOrFile({
-  src,
-  resourceLoader,
-  virtualConsole = createVirtualConsole((error) => {
-    throw error;
-  })
-}) {
-  const url = isValidUri(src) ? new URL(src) : pathToFileURL3(src);
-  let dom;
-  if (url.protocol === "http:" || url.protocol === "https:") {
-    dom = await JSDOM.fromURL(src, {
-      virtualConsole,
-      resources: resourceLoader
-    });
-  } else if (url.protocol === "file:") {
-    if (resourceLoader) {
-      const file = resourceLoader._readFile(fileURLToPath2(url));
-      resourceLoader.fetcherMap.set(url.href, file);
-    }
-    dom = await JSDOM.fromFile(fileURLToPath2(url), {
-      virtualConsole,
-      resources: resourceLoader,
-      contentType: src.endsWith(".xhtml") || src.endsWith(".xml") ? "application/xhtml+xml; charset=UTF-8" : "text/html; charset=UTF-8"
-    });
-  } else if (url.protocol === "data:") {
-    const [head, body] = url.href.split(",", 2);
-    const data = decodeURIComponent(body);
-    const buffer = Buffer.from(
-      data,
-      /;base64$/i.test(head) ? "base64" : "utf8"
-    );
-    const dummyUrl = `${ResourceLoader.dataUrlOrigin}index.html`;
-    if (resourceLoader) {
-      let timeoutId;
-      const promise = new Promise((resolve) => {
-        timeoutId = setTimeout(resolve, 0, buffer);
-      });
-      promise.abort = () => {
-        if (timeoutId !== void 0) {
-          clearTimeout(timeoutId);
-        }
-      };
-      resourceLoader.fetcherMap.set(dummyUrl, promise);
-    }
-    dom = new JSDOM(buffer.toString(), {
-      virtualConsole,
-      resources: resourceLoader,
-      contentType: "text/html; charset=UTF-8",
-      url: dummyUrl
-    });
-  } else {
-    throw new Error(`Unsupported protocol: ${url.protocol}`);
-  }
-  return dom;
-}
-function getJsdomFromString({
-  html,
-  virtualConsole = createVirtualConsole((error) => {
-    throw error;
-  })
-}) {
-  return new JSDOM(html, {
-    virtualConsole
-  });
-}
-async function getStructuredSectionFromHtml(htmlPath, href) {
-  const dom = await getJsdomFromUrlOrFile({ src: htmlPath });
-  const { document: document2 } = dom.window;
-  const allHeadings = [...document2.querySelectorAll("h1, h2, h3, h4, h5, h6")].filter((el) => {
-    return !el.matches("blockquote *");
-  }).sort((a, b) => {
-    const position = a.compareDocumentPosition(b);
-    return position & 2 ? 1 : position & 4 ? -1 : 0;
-  });
-  function traverse(headers) {
-    if (headers.length === 0) {
-      return [];
-    }
-    const [head, ...tail] = headers;
-    const section = head.parentElement;
-    const id = head.id || section.id;
-    const level = Number(head.tagName.slice(1));
-    let i = tail.findIndex((s) => Number(s.tagName.slice(1)) <= level);
-    i = i === -1 ? tail.length : i;
-    return [
-      {
-        headingHtml: htmlPurify.sanitize(head.innerHTML),
-        headingText: head.textContent?.trim().replace(/\s+/g, " ") || "",
-        level,
-        ...href && id && { href: `${href}#${encodeURIComponent(id)}` },
-        ...id && { id },
-        children: traverse(tail.slice(0, i))
-      },
-      ...traverse(tail.slice(i))
-    ];
-  }
-  return traverse(allHeadings);
-}
-var getTocHtmlStyle = ({
-  pageBreakBefore,
-  pageCounterReset
-}) => {
-  if (!pageBreakBefore && typeof pageCounterReset !== "number") {
-    return null;
-  }
-  return (
-    /* css */
-    `
-${pageBreakBefore ? (
-      /* css */
-      `:root {
-  break-before: ${pageBreakBefore};
-}`
-    ) : ""}
-${// Note: `--vs-document-first-page-counter-reset` is reserved variable name in Vivliostyle base themes
-    typeof pageCounterReset === "number" ? (
-      /* css */
-      `@page :nth(1) {
-  --vs-document-first-page-counter-reset: page ${Math.floor(pageCounterReset - 1)};
-  counter-reset: var(--vs-document-first-page-counter-reset);
-}`
-    ) : ""}
-`
-  );
-};
-var defaultTocTransform = {
-  transformDocumentList: (nodeList) => (propsList) => {
-    return /* @__PURE__ */ jsx("ol", { children: nodeList.map((a, i) => [a, propsList[i]]).flatMap(
-      ([{ href, title, sections }, { children, ...otherProps }]) => {
-        if (sections?.length === 1 && sections[0].level === 1) {
-          return [children].flat().flatMap((e) => {
-            if (e.type === "element" && e.tagName === "ol") {
-              return e.children;
-            }
-            return e;
-          });
-        }
-        return /* @__PURE__ */ jsxs("li", { ...otherProps, children: [
-          /* @__PURE__ */ jsx("a", { ...{ href }, children: title }),
-          children
-        ] });
-      }
-    ) });
-  },
-  transformSectionList: (nodeList) => (propsList) => {
-    return /* @__PURE__ */ jsx("ol", { children: nodeList.map((a, i) => [a, propsList[i]]).map(
-      ([{ headingHtml, href, level }, { children, ...otherProps }]) => {
-        const headingContent = {
-          type: "raw",
-          value: headingHtml
-        };
-        return /* @__PURE__ */ jsxs("li", { ...otherProps, "data-section-level": level, children: [
-          href ? /* @__PURE__ */ jsx("a", { ...{ href }, children: headingContent }) : /* @__PURE__ */ jsx("span", { children: headingContent }),
-          children
-        ] });
-      }
-    ) });
-  }
-};
-function generateDefaultTocHtml({
-  language,
-  title
-}) {
-  const toc = /* @__PURE__ */ jsxs("html", { lang: language, children: [
-    /* @__PURE__ */ jsxs("head", { children: [
-      /* @__PURE__ */ jsx("meta", { charset: "utf-8" }),
-      /* @__PURE__ */ jsx("title", { children: title || "" }),
-      /* @__PURE__ */ jsx("style", { "data-vv-style": true })
-    ] }),
-    /* @__PURE__ */ jsxs("body", { children: [
-      /* @__PURE__ */ jsx("h1", { children: title || "" }),
-      /* @__PURE__ */ jsx("nav", { id: "toc", role: "doc-toc" })
-    ] })
-  ] });
-  return toHtml(toc);
-}
-async function generateTocListSection({
-  entries,
-  distDir,
-  sectionDepth,
-  transform = {}
-}) {
-  const {
-    transformDocumentList = defaultTocTransform.transformDocumentList,
-    transformSectionList = defaultTocTransform.transformSectionList
-  } = transform;
-  const structure = await Promise.all(
-    entries.map(async (entry) => {
-      const href = encodeURI(upath4.relative(distDir, entry.target));
-      const sections = sectionDepth >= 1 ? await getStructuredSectionFromHtml(entry.target, href) : [];
-      return {
-        title: entry.title || upath4.basename(entry.target, ".html"),
-        href: encodeURI(upath4.relative(distDir, entry.target)),
-        sections,
-        children: []
-        // TODO
-      };
-    })
-  );
-  const docToc = transformDocumentList(structure)(
-    structure.map((doc) => {
-      function renderSectionList(sections) {
-        const nodeList = sections.flatMap((section) => {
-          if (section.level > sectionDepth) {
-            return [];
-          }
-          return section;
-        });
-        if (nodeList.length === 0) {
-          return [];
-        }
-        return transformSectionList(nodeList)(
-          nodeList.map((node) => ({
-            children: [renderSectionList(node.children || [])].flat()
-          }))
-        );
-      }
-      return {
-        children: [renderSectionList(doc.sections || [])].flat()
-      };
-    })
-  );
-  return toHtml(docToc, { allowDangerousHtml: true });
-}
-async function processTocHtml(dom, {
-  manifestPath,
-  tocTitle,
-  styleOptions = {},
-  entries,
-  distDir,
-  sectionDepth,
-  transform
-}) {
-  const { document: document2 } = dom.window;
-  if (!document2.querySelector(
-    'link[rel="publication"][type="application/ld+json"]'
-  )) {
-    const l = document2.createElement("link");
-    l.setAttribute("rel", "publication");
-    l.setAttribute("type", "application/ld+json");
-    l.setAttribute("href", encodeURI(upath4.relative(distDir, manifestPath)));
-    document2.head.appendChild(l);
-  }
-  const style = document2.querySelector("style[data-vv-style]");
-  if (style) {
-    const textContent = getTocHtmlStyle(styleOptions);
-    if (textContent) {
-      style.textContent = textContent;
-    } else {
-      style.remove();
-    }
-  }
-  const nav = document2.querySelector('nav, [role="doc-toc"]');
-  if (nav && !nav.hasChildNodes()) {
-    const h2 = document2.createElement("h2");
-    h2.textContent = tocTitle;
-    nav.appendChild(h2);
-    nav.innerHTML += await generateTocListSection({
-      entries,
-      distDir,
-      sectionDepth,
-      transform
-    });
-  }
-  return dom;
-}
-var getCoverHtmlStyle = ({
-  pageBreakBefore
-}) => (
-  /* css */
-  `
-${pageBreakBefore ? `:root {
-  break-before: ${pageBreakBefore};
-}` : ""}
-body {
-  margin: 0;
-}
-[role="doc-cover"] {
-  display: block;
-  width: 100vw;
-  height: 100vh;
-  object-fit: contain;
-}
-@page {
-  margin: 0;
-}
-`
-);
-function generateDefaultCoverHtml({
-  language,
-  title
-}) {
-  const toc = /* @__PURE__ */ jsxs("html", { lang: language, children: [
-    /* @__PURE__ */ jsxs("head", { children: [
-      /* @__PURE__ */ jsx("meta", { charset: "utf-8" }),
-      /* @__PURE__ */ jsx("title", { children: title || "" }),
-      /* @__PURE__ */ jsx("style", { "data-vv-style": true })
-    ] }),
-    /* @__PURE__ */ jsx("body", { children: /* @__PURE__ */ jsx("section", { role: "region", "aria-label": "Cover", children: /* @__PURE__ */ jsx("img", { role: "doc-cover" }) }) })
-  ] });
-  return toHtml(toc);
-}
-async function processCoverHtml(dom, {
-  imageSrc,
-  imageAlt,
-  styleOptions = {}
-}) {
-  const { document: document2 } = dom.window;
-  const style = document2.querySelector("style[data-vv-style]");
-  if (style) {
-    const textContent = getCoverHtmlStyle(styleOptions);
-    if (textContent) {
-      style.textContent = textContent;
-    } else {
-      style.remove();
-    }
-  }
-  const cover = document2.querySelector('img[role="doc-cover"]');
-  if (cover && !cover.hasAttribute("src")) {
-    cover.setAttribute("src", encodeURI(imageSrc));
-  }
-  if (cover && !cover.hasAttribute("alt")) {
-    cover.setAttribute("alt", imageAlt);
-  }
-  return dom;
-}
-async function processManuscriptHtml(dom, {
-  title,
-  style,
-  contentType,
-  language
-}) {
-  const { document: document2 } = dom.window;
-  if (title) {
-    if (!document2.querySelector("title")) {
-      const t = document2.createElement("title");
-      document2.head.appendChild(t);
-    }
-    document2.title = title;
-  }
-  for (const s of style ?? []) {
-    const l = document2.createElement("link");
-    l.setAttribute("rel", "stylesheet");
-    l.setAttribute("type", "text/css");
-    l.setAttribute("href", encodeURI(s));
-    document2.head.appendChild(l);
-  }
-  if (language) {
-    if (contentType === "application/xhtml+xml") {
-      if (!document2.documentElement.getAttribute("xml:lang")) {
-        document2.documentElement.setAttribute("lang", language);
-        document2.documentElement.setAttribute("xml:lang", language);
-      }
-    } else {
-      if (!document2.documentElement.getAttribute("lang")) {
-        document2.documentElement.setAttribute("lang", language);
-      }
-    }
-  }
-  return dom;
-}
-async function fetchLinkedPublicationManifest({
-  dom,
-  resourceLoader,
-  baseUrl
-}) {
-  const { document: document2 } = dom.window;
-  const linkEl = document2.querySelector('link[href][rel="publication"]');
-  if (!linkEl) {
-    return null;
-  }
-  const href = linkEl.getAttribute("href").trim();
-  let manifest;
-  let manifestUrl = baseUrl;
-  if (href.startsWith("#")) {
-    const scriptEl = document2.getElementById(href.slice(1));
-    if (scriptEl?.getAttribute("type") !== "application/ld+json") {
-      return null;
-    }
-    Logger.debug(`Found embedded publication manifest: ${href}`);
-    try {
-      manifest = JSON.parse(scriptEl.innerHTML);
-    } catch (error) {
-      const thrownError = error;
-      throw new DetailError(
-        "Failed to parse manifest data",
-        typeof thrownError.stack
-      );
-    }
-  } else {
-    Logger.debug(`Found linked publication manifest: ${href}`);
-    const url = new URL(href, baseUrl);
-    manifestUrl = url.href;
-    const buffer = await resourceLoader.fetch(url.href);
-    if (!buffer) {
-      throw new Error(`Failed to fetch manifest JSON file: ${url.href}`);
-    }
-    const manifestJson = buffer.toString();
-    try {
-      manifest = JSON.parse(manifestJson);
-    } catch (error) {
-      const thrownError = error;
-      throw new DetailError(
-        "Failed to parse manifest data",
-        typeof thrownError.stack
-      );
-    }
-  }
-  try {
-    assertPubManifestSchema(manifest);
-  } catch (error) {
-    Logger.logWarn(
-      `Publication manifest validation failed. Processing continues, but some problems may occur.
-${error}`
-    );
-  }
-  return {
-    manifest: decodePublicationManifest(manifest),
-    manifestUrl
-  };
-}
-function parseTocDocument(dom) {
-  const { document: document2 } = dom.window;
-  const docTocEl = document2.querySelectorAll('[role="doc-toc"]');
-  if (docTocEl.length === 0) {
-    return null;
-  }
-  const tocRoot = docTocEl.item(0);
-  const parseTocItem = (element) => {
-    if (element.tagName !== "LI") {
-      return null;
-    }
-    const label = element.children.item(0);
-    const ol = element.children.item(1);
-    if (!label || label.tagName !== "A" && label.tagName !== "SPAN") {
-      return null;
-    }
-    if (!ol || ol.tagName !== "OL") {
-      return { element, label };
-    }
-    const children = Array.from(ol.children).reduce((acc, val) => {
-      if (!acc) {
-        return acc;
-      }
-      const res = parseTocItem(val);
-      return res && [...acc, res];
-    }, []);
-    return children && {
-      element,
-      label,
-      children
-    };
-  };
-  let heading;
-  for (let child of Array.from(tocRoot.children)) {
-    if (child.tagName === "OL") {
-      const children = Array.from(child.children).reduce((acc, val) => {
-        if (!acc) {
-          return acc;
-        }
-        const res = parseTocItem(val);
-        return res && [...acc, res];
-      }, []);
-      return children && { element: tocRoot, heading, children };
-    } else if (["H1", "H2", "H3", "H4", "H5", "H6", "HGROUP"].includes(child.tagName)) {
-      heading = child;
-    } else {
-      return null;
-    }
-  }
-  return null;
-}
-function parsePageListDocument(dom) {
-  const { document: document2 } = dom.window;
-  const docPageListEl = document2.querySelectorAll('[role="doc-pagelist"]');
-  if (docPageListEl.length === 0) {
-    return null;
-  }
-  const pageListRoot = docPageListEl.item(0);
-  let heading;
-  for (let child of Array.from(pageListRoot.children)) {
-    if (child.tagName === "OL") {
-      const children = Array.from(child.children).reduce((acc, element) => {
-        return acc && (element.tagName === "LI" ? [...acc, { element }] : null);
-      }, []);
-      return children && { element: pageListRoot, heading, children };
-    } else if (["H1", "H2", "H3", "H4", "H5", "H6", "HGROUP"].includes(child.tagName)) {
-      heading = child;
-    } else {
-      return null;
-    }
-  }
-  return null;
-}
-
-// src/output/epub.ts
-import archiver from "archiver";
-import { lookup as lookupLanguage } from "bcp-47-match";
-import { XMLBuilder } from "fast-xml-parser";
-import { copy } from "fs-extra/esm";
-import GithubSlugger from "github-slugger";
-import { lookup as mime2 } from "mime-types";
-import fs5 from "node:fs";
-import { pathToFileURL as pathToFileURL4 } from "node:url";
-import upath5 from "upath";
-import { v4 as uuid } from "uuid";
-import serializeToXml from "w3c-xmlserializer";
-var TOC_ID = "toc";
-var LANDMARKS_ID = "landmarks";
-var PAGELIST_ID = "page-list";
-var COVER_IMAGE_MIMETYPES = [
-  "image/gif",
-  "image/jpeg",
-  "image/png",
-  "image/svg+xml",
-  "image/webp"
-];
-var changeExtname = (filepath, newExt) => {
-  let ext = upath5.extname(filepath);
-  return `${filepath.slice(0, -ext.length)}${newExt}`;
-};
-var getRelativeHref = (target, baseUrl, rootUrl) => {
-  const absBasePath = upath5.join("/", baseUrl);
-  const absRootPath = upath5.join("/", rootUrl);
-  const hrefUrl = new URL(encodeURI(target), pathToFileURL4(absBasePath));
-  if (hrefUrl.protocol !== "file:") {
-    return target;
-  }
-  if (/\.html?$/.test(hrefUrl.pathname)) {
-    hrefUrl.pathname = changeExtname(hrefUrl.pathname, ".xhtml");
-  }
-  const pathname = upath5.posix.relative(
-    pathToFileURL4(upath5.dirname(absRootPath)).pathname,
-    hrefUrl.pathname
-  );
-  return `${pathname}${hrefUrl.search}${hrefUrl.hash}`;
-};
-var normalizeLocalizableString = (value, availableLanguages) => {
-  if (!value) {
-    return;
-  }
-  const values = [value].flat().map((value2) => typeof value2 === "string" ? { value: value2 } : value2);
-  const localizedValues = values.filter(
-    (v2) => !!v2.language
-  );
-  const preferredLang = lookupLanguage(
-    localizedValues.map((v2) => v2.language),
-    availableLanguages
-  );
-  if (preferredLang) {
-    return localizedValues[localizedValues.findIndex((v2) => v2.language === preferredLang)].value;
-  }
-  return values.find((v2) => !v2.language)?.value;
-};
-var appendManifestProperty = (entry, newProperty) => {
-  entry.properties = entry.properties ? Array.from(/* @__PURE__ */ new Set([...entry.properties.split(" "), newProperty])).join(
-    " "
-  ) : newProperty;
-};
-async function exportEpub({
-  webpubDir,
-  entryHtmlFile,
-  manifest,
-  relManifestPath,
-  target,
-  epubVersion
-}) {
-  Logger.debug("Export EPUB", {
-    webpubDir,
-    entryHtmlFile,
-    relManifestPath,
-    target,
-    epubVersion
-  });
-  const [tmpDir] = await useTmpDirectory();
-  fs5.mkdirSync(upath5.join(tmpDir, "META-INF"), { recursive: true });
-  await copy(webpubDir, upath5.join(tmpDir, "EPUB"));
-  const uid = `urn:uuid:${uuid()}`;
-  const entryHtmlRelPath = entryHtmlFile && upath5.relative(webpubDir, upath5.resolve(webpubDir, entryHtmlFile));
-  const findPublicationLink = (relType, list, filter) => [list].flat().find(
-    (e) => typeof e === "object" && e.rel === relType && (!filter || filter(e))
-  );
-  const tocResource = findPublicationLink("contents", [
-    ...[manifest.readingOrder || []].flat(),
-    ...[manifest.resources || []].flat()
-  ]);
-  const pageListResource = findPublicationLink("pagelist", [
-    ...[manifest.readingOrder || []].flat(),
-    ...[manifest.resources || []].flat()
-  ]);
-  const pictureCoverResource = findPublicationLink(
-    "cover",
-    manifest.resources,
-    (e) => COVER_IMAGE_MIMETYPES.includes(e.encodingFormat || mime2(e.url) || "")
-  );
-  const htmlCoverResource = findPublicationLink(
-    "cover",
-    [
-      ...[manifest.readingOrder || []].flat(),
-      ...[manifest.resources || []].flat()
-    ],
-    (e) => /\.html?$/.test(e.url)
-  );
-  const manifestItem = [
-    ...[manifest.links || []].flat(),
-    ...[manifest.readingOrder || []].flat(),
-    ...[manifest.resources || []].flat()
-  ].reduce(
-    (acc, val) => {
-      const { url, encodingFormat } = typeof val === "string" ? { url: val } : val;
-      try {
-        new URL(url);
-        return acc;
-      } catch (e) {
-      }
-      if (!fs5.existsSync(upath5.join(tmpDir, "EPUB", url))) {
-        return acc;
-      }
-      const mediaType = encodingFormat || mime2(url) || "text/plain";
-      acc[url] = {
-        href: url,
-        mediaType
-      };
-      if (/\.html?$/.test(url)) {
-        acc[url].href = changeExtname(url, ".xhtml");
-        acc[url].mediaType = "application/xhtml+xml";
-      }
-      if (url === pictureCoverResource?.url) {
-        acc[url].properties = "cover-image";
-      }
-      return acc;
-    },
-    {}
-  );
-  const htmlFiles = Object.keys(manifestItem).filter(
-    (url) => /\.html?$/.test(url)
-  );
-  let tocHtml = htmlFiles.find((f) => f === tocResource?.url);
-  const readingOrder = [manifest.readingOrder || entryHtmlRelPath].flat().flatMap((v2) => v2 ? typeof v2 === "string" ? { url: v2 } : v2 : []);
-  if (!tocHtml) {
-    Logger.logWarn(
-      "No table of contents document was found. for EPUB output, we recommend to enable `toc` option in your Vivliostyle config file to generate a table of contents document."
-    );
-    tocHtml = htmlFiles.find((f) => f === entryHtmlRelPath) || readingOrder[0].url;
-  }
-  const spineItems = readingOrder.map(({ url }) => ({
-    href: changeExtname(url, ".xhtml")
-  }));
-  if (!(tocHtml in manifestItem)) {
-    manifestItem[tocHtml] = {
-      href: changeExtname(tocHtml, ".xhtml"),
-      mediaType: "application/xhtml+xml"
-    };
-  }
-  appendManifestProperty(manifestItem[tocHtml], "nav");
-  const landmarks = [
-    {
-      type: "toc",
-      href: `${manifestItem[tocHtml].href}#${TOC_ID}`,
-      text: EPUB_LANDMARKS_TOC_ENTRY
-    }
-  ];
-  if (htmlCoverResource) {
-    landmarks.push({
-      type: "cover",
-      href: changeExtname(htmlCoverResource.url, ".xhtml"),
-      text: EPUB_LANDMARKS_COVER_ENTRY
-    });
-  }
-  const contextDir = upath5.join(tmpDir, "EPUB");
-  const processHtml = async (target2) => {
-    let parseResult;
-    try {
-      parseResult = await transpileHtmlToXhtml({
-        target: target2,
-        contextDir
-      });
-    } catch (error) {
-      const thrownError = error;
-      throw new DetailError(
-        `Failed to transpile document to XHTML: ${target2}`,
-        thrownError.stack ?? thrownError.message
-      );
-    }
-    if (parseResult.hasMathmlContent) {
-      appendManifestProperty(manifestItem[target2], "mathml");
-    }
-    if (parseResult.hasRemoteResources) {
-      appendManifestProperty(manifestItem[target2], "remote-resources");
-    }
-    if (parseResult.hasScriptedContent) {
-      appendManifestProperty(manifestItem[target2], "scripted");
-    }
-    if (parseResult.hasSvgContent) {
-      appendManifestProperty(manifestItem[target2], "svg");
-    }
-    return parseResult;
-  };
-  const processResult = {};
-  Logger.debug(`Transpiling ToC HTML to XHTML: ${tocHtml}`);
-  processResult[tocHtml] = await processHtml(tocHtml);
-  for (const target2 of htmlFiles.filter((f) => f !== tocHtml)) {
-    Logger.debug(`Transpiling HTML to XHTML: ${target2}`);
-    processResult[target2] = await processHtml(target2);
-  }
-  const { document: entryDocument } = processResult[tocHtml].dom.window;
-  const docLanguages = [manifest.inLanguage].flat().filter((v2) => Boolean(v2));
-  if (docLanguages.length === 0) {
-    docLanguages.push(entryDocument.documentElement.lang || "en");
-  }
-  const docTitle = normalizeLocalizableString(manifest.name, docLanguages) || entryDocument.title;
-  if (!docTitle) {
-    throw new Error("EPUB must have a title of one or more characters");
-  }
-  const { tocResourceTree } = await processTocDocument({
-    dom: processResult[tocHtml].dom,
-    target: tocHtml,
-    contextDir,
-    readingOrder,
-    docLanguages,
-    landmarks
-  });
-  const pageListHtml = pageListResource?.url || entryHtmlRelPath;
-  if (pageListHtml && pageListHtml in processResult) {
-    await processPagelistDocument({
-      dom: processResult[pageListHtml].dom,
-      target: pageListHtml,
-      contextDir
-    });
-  }
-  if (relManifestPath) {
-    await fs5.promises.rm(upath5.join(tmpDir, "EPUB", relManifestPath), {
-      force: true,
-      recursive: true
-    });
-    delete manifestItem[relManifestPath];
-  }
-  fs5.writeFileSync(
-    upath5.join(tmpDir, "META-INF/container.xml"),
-    EPUB_CONTAINER_XML,
-    "utf8"
-  );
-  Logger.debug(`Generating content.opf`);
-  fs5.writeFileSync(
-    upath5.join(tmpDir, "EPUB/content.opf"),
-    buildEpubPackageDocument({
-      epubVersion,
-      uid,
-      docTitle,
-      docLanguages,
-      manifest,
-      spineItems,
-      manifestItems: Object.values(manifestItem)
-    }),
-    "utf8"
-  );
-  await compressEpub({ target, sourceDir: tmpDir });
-}
-async function writeAsXhtml(dom, absPath) {
-  const xhtml = `${XML_DECLARATION}
-${serializeToXml(dom.window.document)}`;
-  await fs5.promises.writeFile(changeExtname(absPath, ".xhtml"), xhtml, "utf8");
-}
-async function transpileHtmlToXhtml({
-  target,
-  contextDir
-}) {
-  const absPath = upath5.join(contextDir, target);
-  const dom = await getJsdomFromUrlOrFile({ src: absPath });
-  const { document: document2 } = dom.window;
-  document2.documentElement.removeAttribute("xmlns");
-  document2.documentElement.setAttribute("xmlns:epub", EPUB_NS);
-  document2.querySelectorAll("a[href]").forEach((el) => {
-    const href = decodeURI(el.getAttribute("href"));
-    el.setAttribute("href", getRelativeHref(href, target, target));
-  });
-  await writeAsXhtml(dom, absPath);
-  await fs5.promises.unlink(absPath);
-  return {
-    dom,
-    // FIXME: Yes, I recognize this implementation is inadequate.
-    hasMathmlContent: !!document2.querySelector("math"),
-    hasRemoteResources: !!document2.querySelector(
-      '[src^="http://"], [src^="https://"]'
-    ),
-    hasScriptedContent: !!document2.querySelector("script, form"),
-    hasSvgContent: !!document2.querySelector("svg")
-  };
-}
-function replaceWithNavElement(dom, el) {
-  const nav = dom.window.document.createElement("nav");
-  while (el.firstChild) {
-    nav.appendChild(el.firstChild);
-  }
-  for (let i = 0; i < el.attributes.length; i++) {
-    nav.attributes.setNamedItem(el.attributes[i].cloneNode());
-  }
-  el.parentNode?.replaceChild(nav, el);
-  return nav;
-}
-async function processTocDocument({
-  dom,
-  target,
-  contextDir,
-  readingOrder,
-  docLanguages,
-  landmarks
-}) {
-  const { document: document2 } = dom.window;
-  let tocResourceTree = null;
-  if (!document2.querySelector("nav[epub:type]")) {
-    tocResourceTree = parseTocDocument(dom);
-    if (tocResourceTree) {
-      const nav = replaceWithNavElement(dom, tocResourceTree.element);
-      nav.setAttribute("id", TOC_ID);
-      nav.setAttribute("epub:type", "toc");
-    } else {
-      Logger.debug(`Generating toc nav element: ${target}`);
-      const nav = document2.createElement("nav");
-      nav.setAttribute("id", TOC_ID);
-      nav.setAttribute("role", "doc-toc");
-      nav.setAttribute("epub:type", "toc");
-      nav.setAttribute("hidden", "");
-      const h2 = document2.createElement("h2");
-      h2.textContent = TOC_TITLE;
-      nav.appendChild(h2);
-      const ol = document2.createElement("ol");
-      tocResourceTree = {
-        element: nav,
-        children: []
-      };
-      for (const content of readingOrder) {
-        let name = normalizeLocalizableString(content.name, docLanguages);
-        if (!name) {
-          const dom2 = await getJsdomFromUrlOrFile({
-            src: upath5.join(contextDir, changeExtname(content.url, ".xhtml"))
-          });
-          name = dom2.window.document.title;
-        }
-        const li = document2.createElement("li");
-        const a = document2.createElement("a");
-        a.textContent = name;
-        a.href = getRelativeHref(content.url, "", target);
-        li.appendChild(a);
-        ol.appendChild(li);
-        tocResourceTree.children.push({ element: li, label: a });
-      }
-      nav.appendChild(ol);
-      document2.body.appendChild(nav);
-      Logger.debug("Generated toc nav element", nav.outerHTML);
-    }
-    if (landmarks.length > 0) {
-      Logger.debug(`Generating landmark nav element: ${target}`);
-      const nav = document2.createElement("nav");
-      nav.setAttribute("epub:type", "landmarks");
-      nav.setAttribute("id", LANDMARKS_ID);
-      nav.setAttribute("hidden", "");
-      const h2 = document2.createElement("h2");
-      h2.textContent = EPUB_LANDMARKS_TITLE;
-      nav.appendChild(h2);
-      const ol = document2.createElement("ol");
-      for (const { type, href, text } of landmarks) {
-        const li = document2.createElement("li");
-        const a = document2.createElement("a");
-        a.setAttribute("epub:type", type);
-        a.setAttribute("href", getRelativeHref(href, "", target));
-        a.text = text;
-        li.appendChild(a);
-        ol.appendChild(li);
-      }
-      nav.appendChild(ol);
-      document2.body.appendChild(nav);
-      Logger.debug("Generated landmark nav element", nav.outerHTML);
-    }
-  }
-  const publicationLinkEl = document2.querySelector(
-    'link[href][rel="publication"]'
-  );
-  if (publicationLinkEl) {
-    const href = publicationLinkEl.getAttribute("href").trim();
-    if (href.startsWith("#")) {
-      const scriptEl = document2.getElementById(href.slice(1));
-      if (scriptEl?.getAttribute("type") === "application/ld+json") {
-        scriptEl.parentNode?.removeChild(scriptEl);
-      }
-    }
-    publicationLinkEl.parentNode?.removeChild(publicationLinkEl);
-  }
-  const absPath = upath5.join(contextDir, target);
-  await writeAsXhtml(dom, absPath);
-  return { tocResourceTree };
-}
-async function processPagelistDocument({
-  dom,
-  target,
-  contextDir
-}) {
-  const pageListResourceTree = parsePageListDocument(dom);
-  if (pageListResourceTree) {
-    const nav = replaceWithNavElement(dom, pageListResourceTree.element);
-    nav.setAttribute("id", PAGELIST_ID);
-    nav.setAttribute("epub:type", "page-list");
-  }
-  const absPath = upath5.join(contextDir, target);
-  await writeAsXhtml(dom, absPath);
-  return { pageListResourceTree };
-}
-function buildEpubPackageDocument({
-  epubVersion,
-  manifest,
-  uid,
-  docTitle,
-  docLanguages,
-  spineItems,
-  manifestItems
-}) {
-  const slugger = new GithubSlugger();
-  slugger.reset();
-  const bookIdentifier = slugger.slug("bookid");
-  const normalizeDate = (value) => value && `${new Date(value).toISOString().split(".")[0]}Z`;
-  const transformToGenericTextNode = (value, attributes) => [value].flat().filter(Boolean).map((v2) => ({ ...attributes || {}, "#text": `${value}` }));
-  const transformContributor = (contributorMap) => Object.entries(contributorMap).flatMap(
-    ([type, contributor]) => contributor ? [contributor].flat().map((entry, index) => ({
-      _id: slugger.slug(`${type}-${index + 1}`),
-      "#text": typeof entry === "string" ? entry : normalizeLocalizableString(entry.name, docLanguages)
-    })) : []
-  );
-  const itemIdMap = /* @__PURE__ */ new Map();
-  manifestItems.forEach(({ href }) => {
-    itemIdMap.set(href, slugger.slug(href));
-  });
-  const builder = new XMLBuilder({
-    format: true,
-    ignoreAttributes: false,
-    attributeNamePrefix: "_"
-  });
-  return builder.build({
-    "?xml": {
-      _version: "1.0",
-      _encoding: "UTF-8"
-    },
-    package: {
-      _xmlns: "http://www.idpf.org/2007/opf",
-      _version: epubVersion,
-      "_unique-identifier": bookIdentifier,
-      "_xml:lang": docLanguages[0],
-      metadata: {
-        "_xmlns:dc": "http://purl.org/dc/elements/1.1/",
-        "dc:identifier": {
-          _id: bookIdentifier,
-          "#text": uid
-        },
-        "dc:title": docTitle,
-        "dc:language": docLanguages,
-        "dc:creator": transformContributor({
-          // TODO: Define proper order
-          author: manifest.author,
-          creator: manifest.creator,
-          editor: manifest.editor,
-          artist: manifest.artist,
-          illustrator: manifest.illustrator,
-          colorist: manifest.colorist,
-          penciler: manifest.penciler,
-          inker: manifest.inker,
-          letterer: manifest.letterer,
-          translator: manifest.translator,
-          readBy: manifest.readBy
-        }),
-        "dc:publisher": transformContributor({
-          publisher: manifest.publisher
-        }),
-        "dc:contributor": transformContributor({
-          contributor: manifest.contributor
-        }),
-        "dc:date": transformToGenericTextNode(
-          normalizeDate(manifest.datePublished)
-        ),
-        "dc:rights": transformToGenericTextNode(
-          manifest.copyrightHolder && `\xA9 ${manifest.copyrightYear ? `${manifest.copyrightYear} ` : ""}${manifest.copyrightHolder}`
-        ),
-        "dc:subject": transformToGenericTextNode(
-          manifest["dc:subject"] || manifest.subject
-        ),
-        meta: [
-          ...transformToGenericTextNode(
-            normalizeDate(manifest.dateModified || Date.now()),
-            {
-              _property: "dcterms:modified"
-            }
-          ),
-          ...(() => {
-            const coverImage = manifestItems.find(
-              (it) => it.properties === "cover-image"
-            );
-            return coverImage ? [{ _name: "cover", _content: itemIdMap.get(coverImage.href) }] : [];
-          })()
-        ]
-      },
-      manifest: {
-        item: manifestItems.map(({ href, mediaType, properties }) => ({
-          _id: itemIdMap.get(href),
-          _href: encodeURI(href),
-          "_media-type": mediaType,
-          ...properties ? { _properties: properties } : {}
-        }))
-      },
-      spine: {
-        ...manifest.readingProgression ? { "_page-progression-direction": manifest.readingProgression } : {},
-        itemref: [
-          ...spineItems.map(({ href }) => ({
-            _idref: itemIdMap.get(href)
-          }))
-        ]
-      }
-    }
-  });
-}
-async function compressEpub({
-  target,
-  sourceDir
-}) {
-  Logger.debug(`Compressing EPUB: ${target}`);
-  const output = fs5.createWriteStream(target);
-  const archive = archiver("zip", {
-    zlib: { level: 9 }
-    // Compression level
-  });
-  return new Promise((resolve, reject) => {
-    output.on("close", () => {
-      Logger.debug(`Compressed EPUB: ${target}`);
-      resolve();
-    });
-    output.on("error", reject);
-    archive.on("warning", reject);
-    archive.on("error", reject);
-    archive.pipe(output);
-    archive.append("application/epub+zip", {
-      name: "mimetype",
-      // mimetype should not be compressed
-      // https://www.w3.org/TR/epub-33/#sec-zip-container-mime
-      store: true
-    });
-    archive.directory(upath5.join(sourceDir, "META-INF"), "META-INF");
-    archive.directory(upath5.join(sourceDir, "EPUB"), "EPUB");
-    archive.finalize();
-  });
-}
-
-// src/output/webbook.ts
-function sortManifestResources(manifest) {
-  if (!Array.isArray(manifest.resources)) {
-    return;
-  }
-  manifest.resources = [...manifest.resources].sort(
-    (a, b) => (typeof a === "string" ? a : a.url) > (typeof b === "string" ? b : b.url) ? 1 : -1
-  );
-}
-async function prepareWebPublicationDirectory({
-  outputDir
-}) {
-  if (fs6.existsSync(outputDir)) {
-    Logger.debug("going to remove existing webpub", outputDir);
-    await fs6.promises.rm(outputDir, { force: true, recursive: true });
-  }
-  fs6.mkdirSync(outputDir, { recursive: true });
-}
-function transformPublicationManifest(entity, transformer) {
-  const { url: transformUrl } = transformer;
-  const transformUrlOrPublicationLinks = (e) => {
-    if (typeof e === "string") {
-      return transformUrl(e);
-    }
-    const ret2 = { ...e };
-    ret2.url = transformUrl(e.url);
-    return ret2;
-  };
-  const ret = { ...entity };
-  for (const [key, tr] of Object.entries({
-    conformsTo: transformUrl,
-    url: transformUrl,
-    readingOrder: transformUrlOrPublicationLinks,
-    resources: transformUrlOrPublicationLinks,
-    links: transformUrlOrPublicationLinks
-  })) {
-    if (key in ret) {
-      ret[key] = Array.isArray(ret[key]) ? ret[key].map(tr) : tr(ret[key]);
-    }
-  }
-  return ret;
-}
-function decodePublicationManifest(input) {
-  return transformPublicationManifest(input, {
-    url: decodeURI
-  });
-}
-function encodePublicationManifest(input) {
-  return transformPublicationManifest(input, {
-    url: encodeURI
-  });
-}
-function writePublicationManifest(output, options) {
-  const entries = options.entries.map((entry) => ({
-    url: entry.path,
-    ...entry.title && { name: entry.title },
-    ...entry.encodingFormat && { encodingFormat: entry.encodingFormat },
-    ...entry.rel && { rel: entry.rel },
-    ...(entry.rel === "contents" || entry.rel === "cover") && {
-      type: "LinkedResource"
-    }
-  }));
-  const links = [
-    options.links || []
-  ].flat();
-  const resources = [
-    options.resources || []
-  ].flat();
-  if (options.cover) {
-    const mimeType = mime3(options.cover.url);
-    if (mimeType) {
-      resources.push({
-        rel: "cover",
-        url: options.cover.url,
-        name: options.cover.name,
-        encodingFormat: mimeType
-      });
-    } else {
-      Logger.logWarn(
-        `Cover image "${options.cover}" was set in your configuration but couldn\u2019t detect the image metadata. Please check a valid cover file is placed.`
-      );
-    }
-  }
-  const publication = {
-    "@context": ["https://schema.org", "https://www.w3.org/ns/pub-context"],
-    type: "Book",
-    conformsTo: "https://github.com/vivliostyle/vivliostyle-cli",
-    ...options.title && { name: options.title },
-    ...options.author && { author: options.author },
-    ...options.language && { inLanguage: options.language },
-    ...options.readingProgression && {
-      readingProgression: options.readingProgression
-    },
-    dateModified: options.modified,
-    readingOrder: entries,
-    resources,
-    links
-  };
-  const encodedManifest = encodePublicationManifest(publication);
-  Logger.debug(
-    "writePublicationManifest path: %s content: %O",
-    output,
-    encodedManifest
-  );
-  try {
-    assertPubManifestSchema(encodedManifest);
-  } catch (error) {
-    const thrownError = error;
-    throw new DetailError(
-      `Validation of publication manifest failed. Please check the schema: ${output}`,
-      typeof thrownError === "string" ? thrownError : thrownError.stack ?? thrownError.message
-    );
-  }
-  fs6.mkdirSync(upath6.dirname(output), { recursive: true });
-  fs6.writeFileSync(output, JSON.stringify(encodedManifest, null, 2));
-  return publication;
-}
-async function retrieveWebbookEntry({
-  viewerInput,
-  outputDir
-}) {
-  const webbookEntryUrl = viewerInput.webbookPath ? pathToFileURL5(viewerInput.webbookPath).href : viewerInput.webbookEntryUrl;
-  if (/^https?:/i.test(webbookEntryUrl)) {
-    Logger.logUpdate("Fetching remote contents");
-  }
-  const resourceLoader = new ResourceLoader();
-  const dom = await getJsdomFromUrlOrFile({
-    src: webbookEntryUrl,
-    resourceLoader
-  });
-  const entryHtml = viewerInput.webbookPath ? upath6.basename(viewerInput.webbookPath) : decodeURI(dom.window.location.pathname);
-  const { manifest, manifestUrl } = await fetchLinkedPublicationManifest({
-    dom,
-    resourceLoader,
-    baseUrl: webbookEntryUrl
-  }) || {};
-  let pathContains2;
-  if (webbookEntryUrl.startsWith("data:")) {
-    pathContains2 = (url) => false;
-  } else {
-    const rootUrl = /^https?:/i.test(webbookEntryUrl) ? new URL("/", webbookEntryUrl).href : new URL(".", webbookEntryUrl).href;
-    pathContains2 = (url) => !upath6.relative(rootUrl, url).startsWith("..");
-  }
-  const retriever = new Map(resourceLoader.fetcherMap);
-  if (manifest && manifestUrl) {
-    [manifest.resources || []].flat().forEach((v2) => {
-      const url = typeof v2 === "string" ? v2 : v2.url;
-      const fullUrl = new URL(encodeURI(url), manifestUrl).href;
-      if (!pathContains2(fullUrl) || retriever.has(fullUrl)) {
-        return;
-      }
-      const fetchPromise = resourceLoader.fetch(fullUrl);
-      if (fetchPromise && !retriever.has(fullUrl)) {
-        retriever.set(fullUrl, fetchPromise);
-      }
-    });
-    for (const v2 of [manifest.readingOrder || []].flat()) {
-      const url = typeof v2 === "string" ? v2 : v2.url;
-      if (!/\.html?$/.test(url) && !(typeof v2 === "string" || v2.encodingFormat === "text/html")) {
-        continue;
-      }
-      const fullUrl = new URL(encodeURI(url), manifestUrl).href;
-      if (!pathContains2(fullUrl) || fullUrl === webbookEntryUrl) {
-        continue;
-      }
-      const subpathResourceLoader = new ResourceLoader();
-      await getJsdomFromUrlOrFile({
-        src: fullUrl,
-        resourceLoader: subpathResourceLoader,
-        virtualConsole: createVirtualConsole((error) => {
-          Logger.logError(`Failed to fetch webbook resources: ${error.detail}`);
-        })
-      });
-      subpathResourceLoader.fetcherMap.forEach(
-        (v3, k) => !retriever.has(k) && retriever.set(k, v3)
-      );
-    }
-  }
-  const fetchedResources = await ResourceLoader.saveFetchedResources({
-    fetcherMap: retriever,
-    rootUrl: webbookEntryUrl,
-    outputDir,
-    /* v8 ignore next 4 */
-    onError: (error) => {
-      Logger.debug(error);
-      Logger.logError(`Failed to fetch webbook resources: ${error}`);
-    }
-  });
-  if (manifest) {
-    const referencedContents = [
-      ...[manifest.readingOrder || []].flat(),
-      ...[manifest.resources || []].flat()
-    ].map((v2) => typeof v2 === "string" ? v2 : v2.url);
-    manifest.resources = [
-      ...[manifest.resources || []].flat(),
-      ...fetchedResources.filter(
-        ({ url }) => !referencedContents.includes(url)
-      )
-    ];
-    sortManifestResources(manifest);
-  }
-  Logger.debug(
-    "Saved webbook resources",
-    fetchedResources.map((v2) => v2.url)
-  );
-  Logger.debug(
-    "Publication manifest from webbook",
-    manifest && JSON.stringify(manifest, null, 2)
-  );
-  return {
-    entryHtmlFile: upath6.join(
-      outputDir,
-      entryHtml,
-      ...upath6.extname(entryHtml) ? [] : ["index.html"]
-    ),
-    manifest
-  };
-}
-async function supplyWebPublicationManifestForWebbook({
-  entryHtmlFile,
-  outputDir,
-  ...config
-}) {
-  Logger.debug(`Generating publication manifest from HTML: ${entryHtmlFile}`);
-  const dom = await getJsdomFromUrlOrFile({ src: entryHtmlFile });
-  const { document: document2 } = dom.window;
-  const language = config.language || document2.documentElement.lang || void 0;
-  const title = config.title || document2.title || "";
-  const author = config.author || document2.querySelector('meta[name="author"]')?.getAttribute("content") || "";
-  const entry = upath6.relative(outputDir, entryHtmlFile);
-  const allFiles = await glob("**", {
-    cwd: outputDir
-  });
-  const manifest = writePublicationManifest(
-    upath6.join(outputDir, MANIFEST_FILENAME),
-    {
-      title,
-      author,
-      language,
-      readingProgression: config.readingProgression,
-      modified: (/* @__PURE__ */ new Date()).toISOString(),
-      entries: [{ path: entry }],
-      resources: allFiles.filter((f) => f !== entry)
-    }
-  );
-  sortManifestResources(manifest);
-  const link = document2.createElement("link");
-  link.setAttribute("rel", "publication");
-  link.setAttribute("type", "application/ld+json");
-  link.setAttribute(
-    "href",
-    upath6.relative(
-      upath6.dirname(entryHtmlFile),
-      upath6.join(outputDir, MANIFEST_FILENAME)
-    )
-  );
-  document2.head.appendChild(link);
-  await fs6.promises.writeFile(entryHtmlFile, dom.serialize(), "utf8");
-  Logger.debug(
-    "Generated publication manifest from HTML",
-    JSON.stringify(manifest, null, 2)
-  );
-  return manifest;
-}
-async function copyWebPublicationAssets({
-  exportAliases,
-  outputs,
-  copyAsset,
-  themesDir,
-  manifestPath,
-  input,
-  outputDir,
-  entries
-}) {
-  const relExportAliases = exportAliases.map(({ source, target }) => ({
-    source: upath6.relative(input, source),
-    target: upath6.relative(input, target)
-  })).filter(({ source }) => !source.startsWith(".."));
-  const assetMatcher = getAssetMatcher({
-    copyAsset,
-    cwd: input,
-    outputs,
-    themesDir,
-    entries
-  });
-  const webResourceMatcher = getWebPubResourceMatcher({
-    cwd: input,
-    outputs,
-    themesDir,
-    entries,
-    manifestPath,
-    copyAsset
-  });
-  const allFiles = /* @__PURE__ */ new Set([
-    ...await assetMatcher.glob(),
-    ...await webResourceMatcher.glob({
-      // follow symbolic links to copy local theme packages
-      followSymbolicLinks: true
-    })
-  ]);
-  for (const alias of relExportAliases) {
-    allFiles.delete(alias.target);
-  }
-  Logger.debug(
-    "webbook files",
-    JSON.stringify(
-      [...allFiles].map((file) => {
-        const alias = relExportAliases.find(({ source }) => source === file);
-        return alias ? `${file} (alias: ${alias.target})` : file;
-      }),
-      null,
-      2
-    )
-  );
-  const resources = [];
-  let actualManifestPath = upath6.join(
-    outputDir,
-    upath6.relative(input, manifestPath)
-  );
-  for (const file of allFiles) {
-    const alias = relExportAliases.find(({ source }) => source === file);
-    const relTarget = alias?.target || file;
-    resources.push(relTarget);
-    const target = upath6.join(outputDir, relTarget);
-    fs6.mkdirSync(upath6.dirname(target), { recursive: true });
-    await copy2(upath6.join(input, file), target);
-    if (alias && pathEquals(upath6.join(input, alias.source), manifestPath)) {
-      actualManifestPath = target;
-    }
-  }
-  Logger.debug("webbook publication.json", actualManifestPath);
-  const manifest = decodePublicationManifest(
-    JSON.parse(fs6.readFileSync(actualManifestPath, "utf8"))
-  );
-  for (const entry of relExportAliases) {
-    const rewriteAliasPath = (e) => {
-      if (typeof e === "string") {
-        return pathEquals(e, entry.source) ? entry.source : e;
-      }
-      if (pathEquals(e.url, entry.source)) {
-        e.url = entry.target;
-      }
-      return e;
-    };
-    if (manifest.links) {
-      manifest.links = Array.isArray(manifest.links) ? manifest.links.map(rewriteAliasPath) : rewriteAliasPath(manifest.links);
-    }
-    if (manifest.readingOrder) {
-      manifest.readingOrder = Array.isArray(manifest.readingOrder) ? manifest.readingOrder.map(rewriteAliasPath) : rewriteAliasPath(manifest.readingOrder);
-    }
-    if (manifest.resources) {
-      manifest.resources = Array.isArray(manifest.resources) ? manifest.resources.map(rewriteAliasPath) : rewriteAliasPath(manifest.resources);
-    }
-  }
-  const normalizeToUrl = (val) => [val || []].flat().map((e) => typeof e === "string" ? e : e.url);
-  const preDefinedResources = [
-    ...normalizeToUrl(manifest.links),
-    ...normalizeToUrl(manifest.readingOrder),
-    ...normalizeToUrl(manifest.resources)
-  ];
-  manifest.resources = [
-    ...[manifest.resources || []].flat(),
-    ...resources.flatMap((file) => {
-      if (preDefinedResources.includes(file) || // Omit publication.json itself
-      pathEquals(file, upath6.relative(outputDir, actualManifestPath))) {
-        return [];
-      }
-      return file;
-    })
-  ];
-  sortManifestResources(manifest);
-  fs6.writeFileSync(
-    actualManifestPath,
-    JSON.stringify(encodePublicationManifest(manifest), null, 2)
-  );
-  return { manifest, actualManifestPath };
-}
-async function buildWebPublication({
-  target,
-  config
-}) {
-  let outputDir;
-  if (target.format === "webpub") {
-    outputDir = target.path;
-    await prepareWebPublicationDirectory({ outputDir });
-  } else {
-    [outputDir] = await useTmpDirectory();
-  }
-  let entryHtmlFile;
-  let manifest;
-  let actualManifestPath;
-  if (config.viewerInput.type === "webpub") {
-    const ret = await copyWebPublicationAssets({
-      ...config,
-      input: config.workspaceDir,
-      outputDir,
-      manifestPath: config.viewerInput.manifestPath
-    });
-    manifest = ret.manifest;
-    actualManifestPath = ret.actualManifestPath;
-    if (config.input.format === "markdown") {
-      const entry = [manifest.readingOrder].flat()[0];
-      if (entry) {
-        entryHtmlFile = upath6.join(
-          outputDir,
-          typeof entry === "string" ? entry : entry.url
-        );
-      }
-    }
-  } else if (isWebbookConfig(config)) {
-    const ret = await retrieveWebbookEntry({
-      viewerInput: config.viewerInput,
-      outputDir
-    });
-    entryHtmlFile = ret.entryHtmlFile;
-    manifest = ret.manifest || await supplyWebPublicationManifestForWebbook({
-      ...config,
-      entryHtmlFile: ret.entryHtmlFile,
-      outputDir
-    });
-  } else {
-    throw new Error("No entry specified");
-  }
-  if (target.format === "epub") {
-    await exportEpub({
-      webpubDir: outputDir,
-      entryHtmlFile,
-      manifest,
-      relManifestPath: actualManifestPath && upath6.relative(outputDir, actualManifestPath),
-      target: target.path,
-      epubVersion: target.version
-    });
-  }
-  return target.path;
-}
-
-// src/processor/theme.ts
-import Arborist from "@npmcli/arborist";
-import fs7 from "node:fs";
-async function checkThemeInstallationNecessity({
-  themesDir,
-  themeIndexes
-}) {
-  if (!fs7.existsSync(themesDir)) {
-    return [...themeIndexes].some((theme) => theme.type === "package");
-  }
-  const commonOpt = {
-    path: themesDir,
-    lockfileVersion: 3,
-    installLinks: true
-  };
-  const arb = new Arborist(commonOpt);
-  const tree = await arb.loadActual();
-  const pkgs = Array.from(tree.children.keys());
-  return [...themeIndexes].some(
-    (theme) => theme.type === "package" && !pkgs.includes(theme.name)
-  );
-}
-async function installThemeDependencies({
-  themesDir,
-  themeIndexes
-}) {
-  fs7.mkdirSync(themesDir, { recursive: true });
-  try {
-    const commonOpt = {
-      path: themesDir,
-      lockfileVersion: 3,
-      installLinks: true
-    };
-    const tree = await new Arborist(commonOpt).buildIdealTree();
-    const existing = Array.from(tree.children.keys());
-    const add = [
-      ...new Set(
-        [...themeIndexes].flatMap(
-          (theme) => theme.type === "package" ? [theme.specifier] : []
-        )
-      )
-    ];
-    const rm = existing.filter((v2) => !add.includes(v2));
-    const opt = { ...commonOpt, rm, add };
-    const arb = new Arborist(opt);
-    await arb.reify(opt);
-    return;
-  } catch (error) {
-    const thrownError = error;
-    throw new DetailError(
-      "An error occurred during the installation of the theme",
-      thrownError.stack ?? thrownError.message
-    );
-  }
-}
-
-// src/processor/compile.ts
-function locateThemePath(theme, from) {
-  if (theme.type === "uri") {
-    return theme.location;
-  }
-  if (theme.type === "file") {
-    return upath7.relative(from, theme.location);
-  }
-  if (theme.importPath) {
-    return [theme.importPath].flat().map((locator) => {
-      const resolvedPath = upath7.resolve(theme.location, locator);
-      if (!pathContains(theme.location, resolvedPath) || !fs8.existsSync(resolvedPath)) {
-        throw new Error(
-          `Could not find a style path ${theme.importPath} for the theme: ${theme.name}.`
-        );
-      }
-      return upath7.relative(from, resolvedPath);
-    });
-  } else {
-    const pkgJsonPath = upath7.join(theme.location, "package.json");
-    const packageJson = JSON.parse(fs8.readFileSync(pkgJsonPath, "utf8"));
-    const maybeStyle = packageJson?.vivliostyle?.theme?.style ?? packageJson.style ?? packageJson.main;
-    if (!maybeStyle) {
-      throw new DetailError(
-        `Could not find a style file for the theme: ${theme.name}.`,
-        "Please ensure this package satisfies a `vivliostyle.theme.style` property."
-      );
-    }
-    return upath7.relative(from, upath7.join(theme.location, maybeStyle));
-  }
-}
-async function cleanupWorkspace({
-  entryContextDir,
-  workspaceDir,
-  themesDir,
-  entries
-}) {
-  if (pathEquals(workspaceDir, entryContextDir) || pathContains(workspaceDir, entryContextDir) || entries.some(
-    (entry) => entry.source?.type === "file" && pathContains(workspaceDir, entry.source.pathname)
-  )) {
-    return;
-  }
-  Logger.debug("cleanup workspace files", workspaceDir);
-  let movedWorkspacePath;
-  if (pathContains(workspaceDir, themesDir) && fs8.existsSync(themesDir)) {
-    movedWorkspacePath = upath7.join(
-      upath7.dirname(workspaceDir),
-      `.vs-${Date.now()}`
-    );
-    const movedThemePath = upath7.join(
-      movedWorkspacePath,
-      upath7.relative(workspaceDir, themesDir)
-    );
-    fs8.mkdirSync(upath7.dirname(movedThemePath), { recursive: true });
-    registerExitHandler(
-      `Removing the moved workspace directory: ${movedWorkspacePath}`,
-      () => {
-        if (movedWorkspacePath && fs8.existsSync(movedWorkspacePath)) {
-          fs8.rmSync(movedWorkspacePath, { recursive: true, force: true });
-        }
-      }
-    );
-    await move(themesDir, movedThemePath);
-  }
-  await fs8.promises.rm(workspaceDir, { recursive: true, force: true });
-  if (movedWorkspacePath) {
-    await move(movedWorkspacePath, workspaceDir);
-  }
-}
-async function prepareThemeDirectory({
-  themesDir,
-  themeIndexes
-}) {
-  if (fs8.existsSync(upath7.join(themesDir, "packages")) && !fs8.existsSync(upath7.join(themesDir, "node_modules"))) {
-    fs8.renameSync(
-      upath7.join(themesDir, "packages"),
-      upath7.join(themesDir, "node_modules")
-    );
-  }
-  if (await checkThemeInstallationNecessity({ themesDir, themeIndexes })) {
-    Logger.startLogging("Installing theme files");
-    await installThemeDependencies({ themesDir, themeIndexes });
-  }
-  for (const theme of themeIndexes) {
-    if (theme.type === "file" && !pathEquals(theme.source, theme.location)) {
-      fs8.mkdirSync(upath7.dirname(theme.location), { recursive: true });
-      await copy3(theme.source, theme.location);
-    }
-  }
-}
-async function transformManuscript(entry, {
-  entryContextDir,
-  workspaceDir,
-  viewerInput: { manifestPath },
-  title,
-  entries,
-  language,
-  vfmOptions,
-  rootUrl
-}) {
-  const source = entry.rel === "contents" || entry.rel === "cover" ? entry.template : entry.source;
-  let content;
-  let resourceLoader;
-  let resourceUrl;
-  const style = entry.themes.flatMap(
-    (theme) => locateThemePath(theme, upath7.dirname(entry.target))
-  );
-  if (source?.type === "file") {
-    if (source.documentProcessor) {
-      const vfile2 = await processMarkdown(
-        source.documentProcessor.processorFactory,
-        source.documentProcessor.metadataReader,
-        source.pathname,
-        {
-          ...vfmOptions,
-          style,
-          title: entry.title,
-          language: language ?? void 0
-        }
-      );
-      content = getJsdomFromString({ html: String(vfile2) });
-    } else if (source.contentType === "text/html" || source.contentType === "application/xhtml+xml") {
-      content = await getJsdomFromUrlOrFile({ src: source.pathname });
-      content = await processManuscriptHtml(content, {
-        style,
-        title: entry.title,
-        contentType: source.contentType,
-        language
-      });
-    } else {
-      if (!pathEquals(source.pathname, entry.target)) {
-        await copy3(source.pathname, entry.target);
-      }
-    }
-  } else if (source?.type === "uri") {
-    resourceUrl = /^https?:/.test(source.href) ? source.href : `${rootUrl}${source.href}`;
-    resourceLoader = new ResourceLoader();
-    try {
-      await getJsdomFromUrlOrFile({
-        src: resourceUrl,
-        resourceLoader,
-        virtualConsole: createVirtualConsole((error) => {
-          Logger.logError(`Failed to fetch resources: ${error.detail}`);
-        })
-      });
-    } catch (error) {
-      throw new DetailError(
-        `Failed to fetch the content from ${resourceUrl}`,
-        error.stack ?? error.message
-      );
-    }
-    const contentFetcher = resourceLoader.fetcherMap.get(resourceUrl);
-    if (contentFetcher) {
-      const buffer = await contentFetcher;
-      const contentType = contentFetcher.response?.headers["content-type"];
-      if (!contentType || new MIMEType2(contentType).essence !== "text/html") {
-        throw new Error(`The content is not an HTML document: ${resourceUrl}`);
-      }
-      content = getJsdomFromString({ html: buffer.toString("utf8") });
-      content = await processManuscriptHtml(content, {
-        style,
-        title: entry.title,
-        contentType: "text/html",
-        language
-      });
-    }
-  } else if (entry.rel === "contents") {
-    content = getJsdomFromString({
-      html: generateDefaultTocHtml({
-        language,
-        title
-      })
-    });
-    content = await processManuscriptHtml(content, {
-      style,
-      title,
-      contentType: "text/html",
-      language
-    });
-  } else if (entry.rel === "cover") {
-    content = getJsdomFromString({
-      html: generateDefaultCoverHtml({ language, title: entry.title })
-    });
-    content = await processManuscriptHtml(content, {
-      style,
-      title: entry.title,
-      contentType: "text/html",
-      language
-    });
-  }
-  if (!content) {
-    return;
-  }
-  if (entry.rel === "contents") {
-    const contentsEntry = entry;
-    const manuscriptEntries = entries.filter(
-      (e) => "source" in e
-    );
-    content = await processTocHtml(content, {
-      entries: manuscriptEntries,
-      manifestPath,
-      distDir: upath7.dirname(contentsEntry.target),
-      tocTitle: contentsEntry.tocTitle,
-      sectionDepth: contentsEntry.sectionDepth,
-      styleOptions: contentsEntry,
-      transform: contentsEntry.transform
-    });
-  }
-  if (entry.rel === "cover") {
-    const coverEntry = entry;
-    content = await processCoverHtml(content, {
-      imageSrc: upath7.relative(
-        upath7.join(
-          entryContextDir,
-          upath7.relative(workspaceDir, coverEntry.target),
-          ".."
-        ),
-        coverEntry.coverImageSrc
-      ),
-      imageAlt: coverEntry.coverImageAlt,
-      styleOptions: coverEntry
-    });
-  }
-  let html;
-  if (content.window.document.contentType === "application/xhtml+xml") {
-    html = `${XML_DECLARATION}
-${serializeToXml2(content.window.document)}`;
-  } else {
-    html = content.serialize();
-  }
-  const htmlBuffer = Buffer.from(html, "utf8");
-  if (!source || source.type === "file" && !pathEquals(source.pathname, entry.target)) {
-    writeFileIfChanged(entry.target, htmlBuffer);
-  }
-  if (source?.type === "uri" && resourceLoader && resourceUrl) {
-    const { response } = resourceLoader.fetcherMap.get(resourceUrl);
-    const contentFetcher = Promise.resolve(
-      htmlBuffer
-    );
-    contentFetcher.abort = () => {
-    };
-    contentFetcher.response = response;
-    resourceLoader.fetcherMap.set(resourceUrl, contentFetcher);
-    await ResourceLoader.saveFetchedResources({
-      fetcherMap: resourceLoader.fetcherMap,
-      rootUrl: resourceUrl,
-      outputDir: source.rootDir
-    });
-  }
-  return html;
-}
-async function generateManifest({
-  entryContextDir,
-  workspaceDir,
-  viewerInput: { manifestPath },
-  title,
-  author,
-  entries,
-  language,
-  readingProgression,
-  cover
-}) {
-  const manifestEntries = entries.map((entry) => ({
-    title: entry.rel === "contents" && entry.tocTitle || entry.title,
-    path: upath7.relative(workspaceDir, entry.target),
-    encodingFormat: !("contentType" in entry) || entry.contentType === "text/markdown" || entry.contentType === "text/x-vivliostyle-custom" || entry.contentType === "text/html" ? void 0 : entry.contentType,
-    rel: entry.rel
-  }));
-  writePublicationManifest(manifestPath, {
-    title,
-    author,
-    language,
-    readingProgression,
-    cover: cover && {
-      url: upath7.relative(entryContextDir, cover.src),
-      name: cover.name
-    },
-    entries: manifestEntries,
-    modified: (/* @__PURE__ */ new Date()).toISOString()
-  });
-}
-async function compile(config) {
-  const tocEntries = [];
-  for (const entry of config.entries) {
-    if (entry.rel === "contents") {
-      tocEntries.push(entry);
-      continue;
-    }
-    await transformManuscript(entry, config);
-  }
-  for (const entry of tocEntries) {
-    await transformManuscript(entry, config);
-  }
-  if (config.viewerInput.needToGenerateManifest) {
-    await generateManifest(config);
-  }
-}
-
-// src/vite/plugin-util.ts
-var headStartTagRe = /<head[^>]*>/i;
-var prependToHead = (html, content) => html.replace(headStartTagRe, (match) => `${match}
-${content}`);
-async function reloadConfig(prevConfig, inlineConfig, resolvedViteConfig) {
-  let config = await loadVivliostyleConfig(inlineConfig) ?? setupConfigFromFlags(inlineConfig);
-  config = mergeInlineConfig(config, inlineConfig);
-  config = mergeConfig(config, {
-    temporaryFilePrefix: prevConfig.temporaryFilePrefix,
-    server: resolvedViteConfig?.server
-  });
-  const taskConfig = resolveTaskConfig(config.tasks[0], config.inlineOptions);
-  return taskConfig;
-}
-
-// src/vite/vite-plugin-dev-server.ts
-function createEntriesRouteLookup(entries, cwd2) {
-  const extns = ["", "html", "htm"];
-  const toAssume = (uri) => {
-    let i = 0, x, len = uri.length - 1;
-    if (uri.charCodeAt(len) === 47) {
-      uri = uri.substring(0, len);
-    }
-    let arr = [], tmp = `${uri}/index`;
-    for (; i < extns.length; i++) {
-      x = extns[i] ? `.${extns[i]}` : "";
-      if (uri) arr.push(uri + x);
-      arr.push(tmp + x);
-    }
-    return arr;
-  };
-  const cache = entries.reduce((acc, e) => {
-    acc[`/${upath8.relative(cwd2, e.target).normalize().replace(/\\+/g, "/")}`] = e;
-    return acc;
-  }, {});
-  return (uri) => {
-    let i = 0, data, arr = toAssume(uri);
-    for (; i < arr.length; i++) {
-      if (data = cache[arr[i]]) return [data, arr[i]];
-    }
-  };
-}
-function getWorkspaceMatcher({
-  workspaceDir,
-  themesDir,
-  viewerInput,
-  themeIndexes,
-  entries,
-  outputs,
-  copyAsset
-}) {
-  if (viewerInput.type === "webpub") {
-    return getWebPubResourceMatcher({
-      outputs,
-      themesDir,
-      entries,
-      cwd: workspaceDir,
-      manifestPath: viewerInput.manifestPath,
-      copyAsset
-    });
-  }
-  let entryFiles = [];
-  switch (viewerInput.type) {
-    case "epub":
-      entryFiles = [
-        upath8.join(
-          upath8.relative(workspaceDir, viewerInput.epubTmpOutputDir),
-          "**"
-        )
-      ];
-      break;
-    case "epub-opf":
-    case "webbook":
-      entryFiles = ["**"];
-      break;
-    default:
-      entryFiles = viewerInput;
-  }
-  return new GlobMatcher([
-    {
-      patterns: entryFiles,
-      ignore: ["node_modules/**"],
-      dot: true,
-      cwd: workspaceDir
-    }
-  ]);
-}
-function vsDevServerPlugin({
-  config: _config,
-  inlineConfig
-}) {
-  let config = _config;
-  let server;
-  let program;
-  const transformCache = /* @__PURE__ */ new Map();
-  let matchProjectDep;
-  async function reload(forceUpdate = false) {
-    const prevConfig = config;
-    config = await reloadConfig(prevConfig, inlineConfig, server?.config);
-    transformCache.clear();
-    const needToUpdateManifest = forceUpdate || // FIXME: More precise comparison
-    JSON.stringify(prevConfig) !== JSON.stringify(config);
-    if (isWebPubConfig(config) && config.viewerInput.needToGenerateManifest && needToUpdateManifest) {
-      await generateManifest(config);
-    }
-    await prepareThemeDirectory(config);
-    const entriesLookup = createEntriesRouteLookup(
-      config.entries,
-      config.workspaceDir
-    );
-    const urlMatchRe = new RegExp(
-      `^${escapeRe(config.base)}(/[^?#]*)([?#].*)?$`
-    );
-    const serveWorkspace = sirv(config.workspaceDir, {
-      dev: true,
-      etag: false,
-      dotfiles: true,
-      extensions: []
-    });
-    const serveWorkspaceMatcher = getWorkspaceMatcher(config);
-    const serveAssets = sirv(config.entryContextDir, {
-      dev: true,
-      etag: false,
-      extensions: []
-    });
-    const serveAssetsMatcher = getAssetMatcher({
-      ...config,
-      cwd: config.entryContextDir
-    });
-    program = {
-      entriesLookup,
-      urlMatchRe,
-      serveWorkspace,
-      serveWorkspaceMatcher,
-      serveAssets,
-      serveAssetsMatcher
-    };
-    if (needToUpdateManifest) {
-      Logger.debug(
-        "dev-server > serveWorkspaceMatcher %O",
-        serveWorkspaceMatcher.matcherConfig
-      );
-      Logger.debug(
-        "dev-server > serveAssetsMatcher %O",
-        serveAssetsMatcher.matcherConfig
-      );
-    }
-    const configPath = locateVivliostyleConfig(inlineConfig);
-    const projectDeps = [];
-    if (configPath) {
-      projectDeps.push(configPath);
-      server?.watcher.add(configPath);
-    }
-    if (config.viewerInput.type === "webpub") {
-      projectDeps.push(config.viewerInput.manifestPath);
-      server?.watcher.add(config.viewerInput.manifestPath);
-    }
-    const flattenWatchTarget = (themes) => [...themes].flatMap((theme) => {
-      if (theme.type === "file") {
-        return [theme.source];
-      }
-      if (theme.type === "package" && !theme.registry) {
-        return [theme.specifier];
-      }
-      return [];
-    });
-    const prevThemeFiles = flattenWatchTarget(prevConfig.themeIndexes);
-    const themeFiles = flattenWatchTarget(config.themeIndexes);
-    server?.watcher.unwatch(
-      prevThemeFiles.filter((target) => !themeFiles.includes(target))
-    );
-    server?.watcher.add(themeFiles);
-    projectDeps.push(...themeFiles);
-    matchProjectDep = (pathname) => projectDeps.some(
-      (dep) => pathEquals(dep, pathname) || pathContains(dep, pathname)
-    );
-  }
-  async function transform(entry, host) {
-    if (!isWebPubConfig(config)) {
-      return;
-    }
-    const rootUrl = host ? `${server?.config.server.https ? "https" : "http"}://${host}` : config.rootUrl;
-    const promise = (async () => {
-      try {
-        const html = await transformManuscript(entry, { ...config, rootUrl });
-        if (!html) {
-          transformCache.delete(entry.target);
-          return;
-        }
-        const etag = `W/"${Date.now()}"`;
-        if (entry.source?.type === "file") {
-          server?.watcher.add(entry.source.pathname);
-        }
-        return { content: html, etag };
-      } catch (error) {
-        server?.config.logger.error(getFormattedError(error));
-        transformCache.delete(entry.target);
-        return;
-      }
-    })();
-    transformCache.set(entry.target, promise);
-    return await promise;
-  }
-  async function transformAll(host) {
-    const tocEntries = [];
-    for (const entry of config.entries) {
-      if (entry.rel === "contents") {
-        tocEntries.push(entry);
-        continue;
-      }
-      await transform(entry, host);
-    }
-    for (const entry of tocEntries) {
-      await transform(entry, host);
-    }
-  }
-  async function invalidate(entry) {
-    const cwd2 = pathToFileURL6(config.workspaceDir);
-    const target = pathToFileURL6(entry.target);
-    if (target.href.indexOf(cwd2.href) !== 0) {
-      return;
-    }
-    transformCache.delete(entry.target);
-    config.entries.filter((entry2) => entry2.rel === "contents").forEach((entry2) => {
-      transformCache.delete(entry2.target);
-    });
-    server?.ws.send({
-      type: "full-reload",
-      path: target.href.slice(cwd2.href.length)
-    });
-  }
-  const devServerMiddleware = async function vivliostyleDevServerMiddleware(req, res, next) {
-    if (!program) {
-      return next();
-    }
-    const { entriesLookup, urlMatchRe } = program;
-    const [_, pathname, qs] = decodeURI(req.url).match(urlMatchRe) ?? [];
-    const match = pathname && entriesLookup(pathname);
-    if (!match) {
-      return next();
-    }
-    const [entry, expected] = match;
-    if (pathname !== expected) {
-      res.statusCode = 301;
-      res.setHeader("Location", `${expected}${qs || ""}`);
-      return res.end();
-    }
-    Logger.debug("dev-server > request %s", pathname);
-    const cachePromise = transformCache.get(entry.target);
-    if (cachePromise) {
-      const cached = await cachePromise;
-      if (!cached) {
-        return next();
-      }
-      if (req.headers["if-none-match"] === cached.etag) {
-        res.statusCode = 304;
-        return res.end();
-      } else {
-        res.statusCode = 200;
-        res.setHeader("Content-Type", "text/html;charset=utf-8");
-        res.setHeader("Cache-Control", "no-cache");
-        res.setHeader("Etag", cached.etag);
-        return res.end(cached.content);
-      }
-    }
-    const { host } = req.headers;
-    if (entry.rel === "contents") {
-      await transformAll(host);
-    }
-    const result = await transform(entry, host);
-    if (!result) {
-      return next();
-    }
-    res.statusCode = 200;
-    res.setHeader("Content-Type", "text/html;charset=utf-8");
-    res.setHeader("Cache-Control", "no-cache");
-    res.setHeader("Etag", result.etag);
-    return res.end(result.content);
-  };
-  const serveWorkspaceMiddleware = async function vivliostyleServeWorkspaceMiddleware(req, res, next) {
-    if (!config || !program) {
-      return next();
-    }
-    const {
-      urlMatchRe,
-      serveWorkspace,
-      serveWorkspaceMatcher,
-      serveAssets,
-      serveAssetsMatcher
-    } = program;
-    const [_, pathname] = decodeURI(req.url).match(urlMatchRe) ?? [];
-    if (!pathname) {
-      return next();
-    }
-    const handleWorkspace = (next2) => {
-      if (!serveWorkspaceMatcher.match(pathname.slice(1))) {
-        return next2();
-      }
-      Logger.debug("dev-server > serveWorkspace %s", pathname);
-      const url = req.url;
-      req.url = req.url.slice(config.base.length);
-      return serveWorkspace(req, res, () => {
-        req.url = url;
-        next2();
-      });
-    };
-    const handleAssets = (next2) => {
-      if (!serveAssetsMatcher.match(pathname.slice(1))) {
-        return next2();
-      }
-      Logger.debug("dev-server > serveAssets %s", pathname);
-      const url = req.url;
-      req.url = url.slice(config.base.length);
-      return serveAssets(req, res, () => {
-        req.url = url;
-        next2();
-      });
-    };
-    handleWorkspace(() => handleAssets(next));
-  };
-  return {
-    name: "vivliostyle:dev-server",
-    enforce: "pre",
-    configureServer(viteServer) {
-      server = viteServer;
-      const requestReload = debounce(async () => {
-        await reload();
-        viteServer.ws.send({
-          type: "full-reload",
-          path: "*"
-        });
-      }, 200);
-      const handleUpdate = (pathname) => {
-        if (!matchProjectDep?.(pathname)) {
-          return;
-        }
-        requestReload();
-      };
-      viteServer.watcher.on("add", handleUpdate);
-      viteServer.watcher.on("change", handleUpdate);
-      viteServer.watcher.on("unlink", handleUpdate);
-      return () => {
-        viteServer.middlewares.use(devServerMiddleware);
-        viteServer.middlewares.use(serveWorkspaceMiddleware);
-      };
-    },
-    configurePreviewServer(viteServer) {
-      return () => {
-        viteServer.middlewares.use(
-          config.base,
-          sirv(config.workspaceDir, { dev: true, etag: false, extensions: [] })
-        );
-      };
-    },
-    async buildStart() {
-      await reload(true);
-      await transformAll(void 0);
-    },
-    async handleHotUpdate(ctx) {
-      const entry = config?.entries.find(
-        (e) => e.source?.type === "file" && e.source.pathname === ctx.file || !e.source && e.target === ctx.file
-      );
-      if (config && entry) {
-        await invalidate(entry);
-      }
-    }
-  };
-}
-
-// src/vite/vite-plugin-static-serve.ts
-import sirv2 from "sirv";
-import upath9 from "upath";
-import "vite";
-function vsStaticServePlugin({
-  config: _config,
-  inlineConfig
-}) {
-  let config = _config;
-  const createMiddlewares = () => {
-    if (typeof config.serverRootDir !== "string") {
-      return [];
-    }
-    return Object.entries(config.static).flatMap(
-      ([base, dirs]) => dirs.map(
-        (dir) => [
-          base,
-          sirv2(upath9.resolve(config.serverRootDir, dir), {
-            dev: true,
-            etag: false
-          })
-        ]
-      )
-    );
-  };
-  return {
-    name: "vivliostyle:static-serve",
-    apply: () => Boolean(inlineConfig.enableStaticServe),
-    configureServer(viteServer) {
-      return () => {
-        createMiddlewares().forEach(([base, middleware]) => {
-          viteServer.middlewares.use(base, middleware);
-        });
-      };
-    },
-    configurePreviewServer(viteServer) {
-      return () => {
-        createMiddlewares().forEach(([base, middleware]) => {
-          viteServer.middlewares.use(base, middleware);
-        });
-      };
-    }
-  };
-}
-
-// src/vite/vite-plugin-viewer.ts
-import fs9 from "node:fs";
-import sirv3 from "sirv";
-import upath10 from "upath";
-import "vite";
-var viewerClientId = "@vivliostyle:viewer:client";
-var viewerClientRequestPath = `/${viewerClientId}`;
-var viewerClientContent = (
-  /* js */
-  `
-if (import.meta.hot) {
-  import.meta.hot.on('vite:beforeFullReload', (e) => {
-    location.reload();
-  });
-}`
-);
-function vsViewerPlugin(_) {
-  const serveRootDir = upath10.join(viewerRoot, "lib");
-  const serve = sirv3(serveRootDir, { dev: false, etag: true });
-  let cachedIndexHtml;
-  const middleware = async function vivliostyleViewerMiddleware(req, res, next) {
-    if (req.url === "/" || req.url === "/index.html") {
-      cachedIndexHtml ??= prependToHead(
-        fs9.readFileSync(upath10.join(serveRootDir, "index.html"), "utf-8"),
-        `<script type="module" src="${viewerClientRequestPath}"></script>`
-      );
-      res.statusCode = 200;
-      res.setHeader("Content-Type", "text/html;charset=utf-8");
-      res.setHeader("Cache-Control", "no-cache");
-      return res.end(cachedIndexHtml);
-    } else {
-      return serve(req, res, next);
-    }
-  };
-  return {
-    name: "vivliostyle:viewer",
-    config() {
-      return {
-        optimizeDeps: {
-          exclude: ["@vivliostyle/viewer"]
-        }
-      };
-    },
-    configureServer(viteServer) {
-      viteServer.middlewares.use(VIEWER_ROOT_PATH, middleware);
-    },
-    configurePreviewServer(viteServer) {
-      viteServer.middlewares.use(VIEWER_ROOT_PATH, serve);
-    },
-    load(id) {
-      if (id === viewerClientRequestPath) {
-        return viewerClientContent;
-      }
-    }
-  };
-}
-
-// src/server.ts
-function getViewerParams(src, {
-  size,
-  cropMarks,
-  bleed,
-  cropOffset,
-  css,
-  customStyle,
-  customUserStyle,
-  singleDoc,
-  quick,
-  viewerParam,
-  base
-}) {
-  const pageSizeValue = size && ("format" in size ? size.format : `${size.width} ${size.height}`);
-  function escapeParam(url) {
-    return url.replace(/&/g, "%26");
-  }
-  let viewerParams = src ? `src=${escapeParam(src)}` : "";
-  viewerParams += `&bookMode=${!singleDoc}&renderAllPages=${!quick}`;
-  if (customStyle) {
-    const param = isValidUri(customStyle) ? customStyle : upath11.posix.join(base, customStyle);
-    viewerParams += `&style=${escapeParam(param)}`;
-  }
-  if (customUserStyle) {
-    const param = isValidUri(customUserStyle) ? customUserStyle : upath11.posix.join(base, customUserStyle);
-    viewerParams += `&userStyle=${escapeParam(param)}`;
-  }
-  if (pageSizeValue || cropMarks || bleed || cropOffset || css) {
-    let pageStyle = "@page{";
-    if (pageSizeValue) {
-      pageStyle += `size:${pageSizeValue};`;
-    }
-    if (cropMarks) {
-      pageStyle += `marks:crop cross;`;
-    }
-    if (bleed || cropMarks) {
-      pageStyle += `bleed:${bleed ?? "3mm"};`;
-    }
-    if (cropOffset) {
-      pageStyle += `crop-offset:${cropOffset};`;
-    }
-    pageStyle += "}";
-    viewerParams += `&style=data:,/*<viewer>*/${encodeURIComponent(
-      pageStyle
-    )}/*</viewer>*/${encodeURIComponent(css ?? "")}`;
-  }
-  if (viewerParam) {
-    viewerParams += `&${viewerParam}`;
-  }
-  return viewerParams;
-}
-async function getSourceUrl({
-  viewerInput,
-  base,
-  workspaceDir,
-  rootUrl
-}) {
-  let input;
-  switch (viewerInput.type) {
-    case "webpub":
-      input = viewerInput.manifestPath;
-      break;
-    case "webbook":
-      input = viewerInput.webbookEntryUrl;
-      break;
-    case "epub-opf":
-      input = viewerInput.epubOpfPath;
-      break;
-    case "epub": {
-      if (!fs10.existsSync(viewerInput.epubTmpOutputDir)) {
-        await openEpub(viewerInput.epubPath, viewerInput.epubTmpOutputDir);
-      }
-      input = getDefaultEpubOpfPath(viewerInput.epubTmpOutputDir);
-      break;
-    }
-    default:
-      input = viewerInput;
-  }
-  return (isValidUri(input) ? new URL2(input) : new URL2(
-    upath11.posix.join(base, upath11.relative(workspaceDir, input)),
-    rootUrl
-  )).href;
-}
-async function getViewerFullUrl({
-  viewerInput,
-  base,
-  workspaceDir,
-  rootUrl,
-  viewer,
-  ...config
-}) {
-  const viewerUrl = viewer ? new URL2(viewer) : new URL2(`${VIEWER_ROOT_PATH}/index.html`, rootUrl);
-  const sourceUrl = await getSourceUrl({
-    viewerInput,
-    base,
-    workspaceDir,
-    rootUrl
-  });
-  const viewerParams = getViewerParams(
-    sourceUrl === EMPTY_DATA_URI ? void 0 : sourceUrl,
-    { base, ...config }
-  );
-  viewerUrl.hash = "";
-  return `${viewerUrl.href}#${viewerParams}`;
-}
-async function createViteServer({
-  config,
-  viteConfig,
-  inlineConfig,
-  mode
-}) {
-  const viteInlineConfig = {
-    clearScreen: false,
-    configFile: false,
-    appType: "custom",
-    plugins: [
-      vsDevServerPlugin({ config, inlineConfig }),
-      vsViewerPlugin({ config, inlineConfig }),
-      vsBrowserPlugin({ config, inlineConfig }),
-      vsStaticServePlugin({ config, inlineConfig })
-    ],
-    server: viteConfig.server,
-    preview: viteConfig.preview,
-    customLogger: viteConfig.customLogger,
-    cacheDir: viteConfig.cacheDir,
-    root: viteConfig.root
-  };
-  Logger.debug("createViteServer > viteInlineConfig %O", viteInlineConfig);
-  if (config.serverRootDir === config.workspaceDir) {
-    const { cacheDir } = viteInlineConfig;
-    registerExitHandler("Removing the Vite cacheDir", () => {
-      if (fs10.existsSync(cacheDir)) {
-        fs10.rmSync(cacheDir, { recursive: true });
-      }
-    });
-  }
-  if (mode === "preview") {
-    return await createServer(viteInlineConfig);
-  } else {
-    return await preview(viteInlineConfig);
-  }
-}
-
-// src/vite/vite-plugin-browser.ts
-function vsBrowserPlugin({
-  config: _config,
-  inlineConfig
-}) {
-  let config = _config;
-  let server;
-  let closeBrowser;
-  async function handlePageClose() {
-    await server?.close();
-    runExitHandlers();
-  }
-  async function openPreviewPage() {
-    const locale = await getOsLocale();
-    const url = await getViewerFullUrl(config);
-    const { page, browser } = await launchPreview({
-      mode: "preview",
-      url,
-      config,
-      /* v8 ignore next 4 */
-      onPageOpen: async (page2) => {
-        page2.on("close", handlePageClose);
-      }
-    });
-    if (!import.meta.env?.VITEST) {
-      await page.evaluate((locale2) => {
-        window.localStorage.setItem("i18nextLng", locale2);
-      }, locale);
-    }
-    await page.bringToFront();
-    if (!import.meta.env?.VITEST) {
-      await page.evaluate(() => {
-        document.querySelector("#vivliostyle-input-url")?.focus();
-      });
-    }
-    closeBrowser = () => {
-      page.off("close", handlePageClose);
-      browser.close();
-    };
-  }
-  return {
-    name: "vivliostyle:browser",
-    apply: () => Boolean(inlineConfig.openViewer),
-    configureServer(viteServer) {
-      server = viteServer;
-      const _listen = viteServer.listen;
-      viteServer.listen = async (...args) => {
-        const server2 = await _listen(...args);
-        config = await reloadConfig(config, inlineConfig, server2.config);
-        await openPreviewPage();
-        return server2;
-      };
-    },
-    closeBundle() {
-      closeBrowser?.();
-    }
-  };
-}
-
-export {
-  loadVivliostyleConfig,
-  warnDeprecatedConfig,
-  mergeConfig,
-  mergeInlineConfig,
-  isWebPubConfig,
-  resolveTaskConfig,
-  launchPreview,
-  vsBrowserPlugin,
-  buildWebPublication,
-  cleanupWorkspace,
-  prepareThemeDirectory,
-  compile,
-  vsDevServerPlugin,
-  vsStaticServePlugin,
-  vsViewerPlugin,
-  getSourceUrl,
-  getViewerFullUrl,
-  createViteServer
-};
-//# sourceMappingURL=chunk-BR2V7MHE.js.map
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-BR2V7MHE.js.map b/package/dist/chunk-BR2V7MHE.js.map
--- a/package/dist/chunk-BR2V7MHE.js.map	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/chunk-BR2V7MHE.js.map	1970-01-01 09:00:00.000000000 +0900
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/config/load.ts","../src/config/merge.ts","../src/config/resolve.ts","../src/processor/markdown.ts","../src/vite/vite-plugin-browser.ts","../src/browser.ts","../src/server.ts","../src/vite/vite-plugin-dev-server.ts","../src/processor/compile.ts","../src/output/webbook.ts","../src/processor/html.tsx","../src/output/epub.ts","../src/processor/theme.ts","../src/vite/plugin-util.ts","../src/vite/vite-plugin-static-serve.ts","../src/vite/vite-plugin-viewer.ts"],"sourcesContent":["import fs from 'node:fs';\nimport { createRequire } from 'node:module';\nimport { pathToFileURL } from 'node:url';\nimport upath from 'upath';\nimport * as v from 'valibot';\nimport { Logger } from '../logger.js';\nimport {\n  cwd as defaultRoot,\n  DetailError,\n  parseJsonc,\n  prettifySchemaError,\n} from '../util.js';\nimport {\n  type InlineOptions,\n  type ParsedVivliostyleConfigSchema,\n  VivliostyleConfigSchema,\n} from './schema.js';\n\nconst require = createRequire(import.meta.url);\n\nexport function locateVivliostyleConfig({\n  config,\n  cwd = defaultRoot,\n}: Pick<InlineOptions, 'config' | 'cwd'>) {\n  if (config) {\n    return upath.resolve(cwd, config);\n  }\n  return ['.js', '.mjs', '.cjs', '.json']\n    .map((ext) => upath.join(cwd, `vivliostyle.config${ext}`))\n    .find((p) => fs.existsSync(p));\n}\n\nexport async function loadVivliostyleConfig({\n  config,\n  configData,\n  cwd,\n}: Pick<InlineOptions, 'config' | 'configData' | 'cwd'>): Promise<\n  ParsedVivliostyleConfigSchema | undefined\n> {\n  if (configData) {\n    return v.parse(VivliostyleConfigSchema, configData);\n  }\n\n  const absPath = locateVivliostyleConfig({ config, cwd });\n  if (!absPath) {\n    return;\n  }\n\n  let parsedConfig: unknown;\n  let jsonRaw: string | undefined;\n  try {\n    if (upath.extname(absPath) === '.json') {\n      jsonRaw = fs.readFileSync(absPath, 'utf8');\n      parsedConfig = parseJsonc(jsonRaw);\n    } else {\n      // Clear require cache to reload CJS config files\n      delete require.cache[require.resolve(absPath)];\n      const url = pathToFileURL(absPath);\n      // Invalidate cache for ESM config files\n      // https://github.com/nodejs/node/issues/49442\n      url.search = `version=${Date.now()}`;\n      parsedConfig = (await import(/* @vite-ignore */ url.href)).default;\n      jsonRaw = JSON.stringify(parsedConfig, null, 2);\n    }\n  } catch (error) {\n    const thrownError = error as Error;\n    throw new DetailError(\n      `An error occurred on loading a config file: ${absPath}`,\n      thrownError.stack ?? thrownError.message,\n    );\n  }\n\n  const result = v.safeParse(VivliostyleConfigSchema, parsedConfig);\n  if (result.success) {\n    const { tasks, inlineOptions } = result.output;\n    return {\n      tasks,\n      inlineOptions: {\n        ...inlineOptions,\n        cwd: cwd ?? defaultRoot,\n        config: absPath,\n      },\n    };\n  } else {\n    const errorString = prettifySchemaError(jsonRaw, result.issues);\n    throw new DetailError(\n      `Validation of vivliostyle config failed. Please check the schema: ${config}`,\n      errorString,\n    );\n  }\n}\n\nexport function warnDeprecatedConfig(config: ParsedVivliostyleConfigSchema) {\n  if (config.tasks.some((task) => task.includeAssets)) {\n    Logger.logWarn(\n      \"'includeAssets' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'copyAsset.includes' property instead.\",\n    );\n  }\n\n  if (config.tasks.some((task) => task.tocTitle)) {\n    Logger.logWarn(\n      \"'tocTitle' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'toc.title' property instead.\",\n    );\n  }\n\n  if (config.tasks.some((task) => task.http)) {\n    Logger.logWarn(\n      \"'http' property of Vivliostyle config was deprecated and will be removed in a future release. This option is enabled by default, and the file protocol is no longer supported.\",\n    );\n  }\n}\n","import type {\n  InlineOptions,\n  ParsedBuildTask,\n  ParsedVivliostyleConfigSchema,\n  ParsedVivliostyleInlineConfig,\n} from './schema.js';\n\nconst pruneObject = <T extends Record<string, unknown>>(obj: T) => {\n  const ret = { ...obj };\n  for (const key in ret) {\n    if (ret[key] === undefined || ret[key] === null) {\n      delete ret[key];\n    }\n  }\n  return ret as { [K in keyof T]: NonNullable<T[K]> };\n};\n\nexport function mergeConfig(\n  base: ParsedVivliostyleConfigSchema,\n  override: Partial<ParsedBuildTask>,\n): ParsedVivliostyleConfigSchema {\n  return {\n    tasks: base.tasks.map((task, i) => ({\n      ...pruneObject(task),\n      ...pruneObject(override),\n    })),\n    inlineOptions: base.inlineOptions,\n  };\n}\n\ntype HasOnlyInlineOptionsProperties<T> =\n  Exclude<keyof T, keyof InlineOptions> extends never ? T : never;\n\nexport function mergeInlineConfig(\n  { tasks, inlineOptions }: ParsedVivliostyleConfigSchema,\n  inlineConfig: ParsedVivliostyleInlineConfig,\n): ParsedVivliostyleConfigSchema {\n  const {\n    theme,\n    size,\n    pressReady,\n    title,\n    author,\n    language,\n    readingProgression,\n    timeout,\n    image,\n    viewer,\n    viewerParam,\n    browser,\n    output,\n    renderMode,\n    preflight,\n    preflightOption,\n    vite,\n    viteConfigFile,\n    host,\n    port,\n    ...overrideInlineOptions\n  } = inlineConfig;\n\n  return {\n    tasks: tasks.map((task) => ({\n      ...pruneObject(task),\n      ...pruneObject({\n        theme,\n        size,\n        pressReady,\n        title,\n        author,\n        language,\n        readingProgression,\n        timeout,\n        image,\n        viewer,\n        viewerParam,\n        browser,\n        vite,\n        viteConfigFile,\n      }),\n      output: (output?.length ? output : task.output)?.map((o) => ({\n        ...pruneObject(o),\n        ...pruneObject({\n          renderMode,\n          preflight,\n          preflightOption,\n        }),\n      })),\n      server: {\n        ...pruneObject(task.server ?? {}),\n        ...pruneObject({ host, port }),\n      },\n    })),\n    inlineOptions: {\n      ...pruneObject(inlineOptions),\n      ...pruneObject({\n        renderMode,\n        preflight,\n        preflightOption,\n      }),\n      ...pruneObject(\n        overrideInlineOptions satisfies HasOnlyInlineOptionsProperties<\n          typeof overrideInlineOptions\n        >,\n      ),\n    },\n  };\n}\n","import {\n  type Metadata,\n  readMetadata,\n  type StringifyMarkdownOptions,\n  VFM,\n} from '@vivliostyle/vfm';\nimport { lookup as mime } from 'mime-types';\nimport fs from 'node:fs';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport npa from 'npm-package-arg';\nimport type { Processor } from 'unified';\nimport upath from 'upath';\nimport type { ResolvedConfig as ResolvedViteConfig, UserConfig } from 'vite';\nimport {\n  ArticleEntryConfig,\n  BrowserType,\n  ContentsEntryConfig,\n  CoverEntryConfig,\n  EntryConfig,\n  type InputFormat,\n  StructuredDocument,\n  StructuredDocumentSection,\n  ThemeConfig,\n} from '../config/schema.js';\nimport {\n  cliVersion,\n  CONTAINER_LOCAL_HOSTNAME,\n  CONTAINER_URL,\n  COVER_HTML_FILENAME,\n  COVER_HTML_IMAGE_ALT,\n  DEFAULT_BROWSER_VERSIONS,\n  EPUB_OUTPUT_VERSION,\n  MANIFEST_FILENAME,\n  TOC_FILENAME,\n  TOC_TITLE,\n} from '../const.js';\nimport { Logger } from '../logger.js';\nimport { readMarkdownMetadata } from '../processor/markdown.js';\nimport {\n  cwd as defaultCwd,\n  detectBrowserPlatform,\n  getEpubRootDir,\n  isInContainer,\n  isValidUri,\n  pathContains,\n  pathEquals,\n  readJSON,\n  statFileSync,\n  touchTmpFile,\n} from '../util.js';\nimport type { InlineOptions, ParsedBuildTask } from './schema.js';\n\nexport type ParsedTheme = UriTheme | FileTheme | PackageTheme;\n\nexport interface UriTheme {\n  type: 'uri';\n  name: string;\n  location: string;\n}\n\nexport interface FileTheme {\n  type: 'file';\n  name: string;\n  source: string;\n  location: string;\n}\n\nexport interface PackageTheme {\n  type: 'package';\n  name: string;\n  specifier: string;\n  location: string;\n  registry: boolean;\n  importPath?: string | string[];\n}\n\nexport type EntrySource = FileEntrySource | UriEntrySource;\n\nexport interface DocumentProcessor {\n  processorFactory: DocumentProcessorFactory;\n  metadataReader: DocumentMetadataReader;\n}\n\nexport interface FileEntrySource {\n  type: 'file';\n  pathname: string;\n  contentType: ManuscriptMediaType;\n  documentProcessor?: DocumentProcessor;\n}\n\nexport interface UriEntrySource {\n  type: 'uri';\n  href: string;\n  rootDir: string;\n}\n\nexport const manuscriptMediaTypes = [\n  'text/markdown',\n  'text/html',\n  'text/plain',\n  'application/xhtml+xml',\n  // a special MIME type indicates that a custom processor is used\n  'text/x-vivliostyle-custom',\n] as const;\nexport type ManuscriptMediaType = (typeof manuscriptMediaTypes)[number];\n\nexport interface ManuscriptEntry {\n  contentType: ManuscriptMediaType;\n  title?: string;\n  themes: ParsedTheme[];\n  source: EntrySource;\n  template?: undefined;\n  target: string;\n  rel?: string | string[];\n}\n\nexport interface ContentsEntry {\n  rel: 'contents';\n  title?: string;\n  themes: ParsedTheme[];\n  source?: undefined;\n  template?: EntrySource;\n  target: string;\n  tocTitle: string;\n  sectionDepth: number;\n  transform: {\n    transformDocumentList:\n      | ((\n          nodeList: StructuredDocument[],\n        ) => (propsList: { children: any }[]) => any)\n      | undefined;\n    transformSectionList:\n      | ((\n          nodeList: StructuredDocumentSection[],\n        ) => (propsList: { children: any }[]) => any)\n      | undefined;\n  };\n  pageBreakBefore?: 'left' | 'right' | 'recto' | 'verso';\n  pageCounterReset?: number;\n}\n\nexport interface CoverEntry {\n  rel: 'cover';\n  title?: string;\n  themes: ParsedTheme[];\n  source?: undefined;\n  template?: EntrySource;\n  target: string;\n  coverImageSrc: string;\n  coverImageAlt: string;\n  pageBreakBefore?: 'left' | 'right' | 'recto' | 'verso';\n}\n\nexport type ParsedEntry = ManuscriptEntry | ContentsEntry | CoverEntry;\n\nexport interface WebPublicationManifestConfig {\n  type: 'webpub';\n  manifestPath: string;\n  needToGenerateManifest: boolean;\n}\n\nexport interface EpubEntryConfig {\n  type: 'epub';\n  epubPath: string;\n  epubTmpOutputDir: string;\n}\n\nexport interface EpubOpfEntryConfig {\n  type: 'epub-opf';\n  epubOpfPath: string;\n}\n\nexport interface WebBookEntryConfig {\n  type: 'webbook';\n  webbookEntryUrl: string;\n  webbookPath: string | undefined;\n}\n\nexport type ViewerInputConfig =\n  | WebPublicationManifestConfig\n  | EpubEntryConfig\n  | EpubOpfEntryConfig\n  | WebBookEntryConfig;\n\nexport interface PdfOutput {\n  format: 'pdf';\n  path: string;\n  renderMode: 'local' | 'docker';\n  preflight: 'press-ready' | 'press-ready-local' | undefined;\n  preflightOption: string[];\n}\n\nexport interface WebPublicationOutput {\n  format: 'webpub';\n  path: string;\n}\n\nexport interface EpubOutput {\n  format: 'epub';\n  path: string;\n  version: '3.0'; // Reserved for future updates\n}\n\nexport type OutputConfig = PdfOutput | WebPublicationOutput | EpubOutput;\n\nexport type PageSize = { format: string } | { width: string; height: string };\n\nexport type DocumentProcessorFactory = (\n  options: StringifyMarkdownOptions,\n  metadata: Metadata,\n) => Processor;\n\nexport type DocumentMetadataReader = (content: string) => Metadata;\n\nexport const UseTemporaryServerRoot = Symbol('UseTemporaryServerRoot');\nexport type UseTemporaryServerRoot = typeof UseTemporaryServerRoot;\n\nexport type ResolvedTaskConfig = {\n  serverRootDir: string | UseTemporaryServerRoot;\n  entryContextDir: string;\n  workspaceDir: string;\n  themesDir: string;\n  entries: ParsedEntry[];\n  input: {\n    format: InputFormat;\n    entry: string;\n  };\n  viewerInput: ViewerInputConfig;\n  outputs: OutputConfig[];\n  themeIndexes: Set<ParsedTheme>;\n  copyAsset: {\n    includes: string[];\n    excludes: string[];\n    fileExtensions: string[];\n  };\n  exportAliases: {\n    source: string;\n    target: string;\n  }[];\n  temporaryFilePrefix: string;\n  size: PageSize | undefined;\n  cropMarks: boolean;\n  bleed: string | undefined;\n  cropOffset: string | undefined;\n  css: string | undefined;\n  customStyle: string | undefined;\n  customUserStyle: string | undefined;\n  singleDoc: boolean;\n  quick: boolean;\n  title: string | undefined;\n  author: string | undefined;\n  language: string | undefined;\n  readingProgression: 'ltr' | 'rtl' | undefined;\n  vfmOptions: {\n    hardLineBreaks: boolean;\n    disableFormatHtml: boolean;\n  };\n  cover:\n    | {\n        src: string;\n        name: string;\n      }\n    | undefined;\n  timeout: number;\n  sandbox: boolean;\n  browser: {\n    type: BrowserType;\n    tag: string;\n    executablePath: string | undefined;\n  };\n  proxy:\n    | {\n        server: string;\n        bypass: string | undefined;\n        username: string | undefined;\n        password: string | undefined;\n      }\n    | undefined;\n  image: string;\n  viewer: string | undefined;\n  viewerParam: string | undefined;\n  logLevel: 'silent' | 'info' | 'verbose' | 'debug';\n  ignoreHttpsErrors: boolean;\n  base: string;\n  server: Required<\n    Pick<\n      ResolvedViteConfig['server'],\n      'host' | 'port' | 'proxy' | 'allowedHosts'\n    >\n  >;\n  static: Record<string, string[]>;\n  rootUrl: string;\n  viteConfig: UserConfig | undefined;\n  viteConfigFile: string | boolean;\n};\n\nconst DEFAULT_ASSET_EXTENSIONS = [\n  'css',\n  'css.map',\n  'png',\n  'jpg',\n  'jpeg',\n  'svg',\n  'gif',\n  'webp',\n  'apng',\n  'ttf',\n  'otf',\n  'woff',\n  'woff2',\n];\n\nfunction isManuscriptMediaType(\n  mediaType: string | false,\n): mediaType is ManuscriptMediaType {\n  return !!(\n    mediaType && manuscriptMediaTypes.includes(mediaType as ManuscriptMediaType)\n  );\n}\n\nconst htmlExtensions = ['.html', '.htm', '.xhtml', '.xht'] as const;\n\n/**\n * Convert non-HTML file extensions to .html\n * HTML/XHTML extensions are preserved as-is\n */\nfunction toHtmlExtension(filename: string): string {\n  const ext = upath.extname(filename).toLowerCase();\n  if (\n    htmlExtensions.includes(\n      // @ts-expect-error check membership\n      ext,\n    )\n  ) {\n    return filename;\n  }\n  return `${filename.slice(0, -ext.length)}.html`;\n}\n\nexport function isWebPubConfig(\n  config: ResolvedTaskConfig,\n): config is ResolvedTaskConfig & {\n  viewerInput: WebPublicationManifestConfig;\n} {\n  return config.viewerInput.type === 'webpub';\n}\n\nexport function isWebbookConfig(\n  config: ResolvedTaskConfig,\n): config is ResolvedTaskConfig & {\n  viewerInput: WebBookEntryConfig;\n} {\n  return config.viewerInput.type === 'webbook';\n}\n\nexport function parsePackageName(\n  specifier: string,\n  cwd: string,\n): npa.Result | null {\n  try {\n    let result = npa(specifier, cwd);\n    // #373: Relative path specifiers may be assumed as shorthand of hosted git\n    // (ex: foo/bar -> github:foo/bar)\n    if (result.type === 'git' && result.saveSpec?.startsWith('github:')) {\n      result = npa(`file:${specifier}`, cwd);\n    }\n    return result;\n  } catch (error) {\n    return null;\n  }\n}\n\n// parse theme locator\nexport function parseTheme({\n  theme,\n  context,\n  workspaceDir,\n  themesDir,\n}: {\n  theme: string | ThemeConfig;\n  context: string;\n  workspaceDir: string;\n  themesDir: string;\n}): ParsedTheme {\n  const { specifier, import: importPath } =\n    typeof theme === 'string' ? { specifier: theme, import: undefined } : theme;\n\n  // url\n  if (isValidUri(specifier)) {\n    return {\n      type: 'uri',\n      name: upath.basename(specifier),\n      location: specifier,\n    };\n  }\n\n  // bare .css file\n  const stylePath = upath.resolve(context, specifier);\n  if (fs.existsSync(stylePath) && stylePath.endsWith('.css')) {\n    const sourceRelPath = upath.relative(context, stylePath);\n    return {\n      type: 'file',\n      name: upath.basename(specifier),\n      source: stylePath,\n      location: upath.resolve(workspaceDir, sourceRelPath),\n    };\n  }\n\n  // node_modules, local pkg\n  const parsed = parsePackageName(specifier, context);\n\n  if (!parsed) {\n    throw new Error(`Invalid package name: ${specifier}`);\n  }\n  // To security reason, Vivliostyle CLI disallow other than npm registry or local file as download source\n  // TODO: Add option that user can allow an unofficial registry explicitly\n  if (!parsed.registry && parsed.type !== 'directory') {\n    throw new Error(`This package specifier is not allowed: ${specifier}`);\n  }\n  let name = parsed.name;\n  let resolvedSpecifier = specifier;\n  if (parsed.type === 'directory' && parsed.fetchSpec) {\n    const pkgJsonPath = upath.join(parsed.fetchSpec, 'package.json');\n    if (fs.existsSync(pkgJsonPath)) {\n      const packageJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));\n      name = packageJson.name;\n      resolvedSpecifier = parsed.fetchSpec;\n    }\n  }\n  if (!name) {\n    throw new Error(`Could not determine the package name: ${specifier}`);\n  }\n  return {\n    type: 'package',\n    name,\n    specifier: resolvedSpecifier,\n    location: upath.join(themesDir, 'node_modules', name),\n    registry: Boolean(parsed.registry),\n    importPath,\n  };\n}\n\nfunction parsePageSize(size: string): PageSize {\n  const [width, height, ...others] = `${size}`.split(',');\n  if (!width || others.length) {\n    throw new Error(`Cannot parse size: ${size}`);\n  } else if (width && height) {\n    return {\n      width,\n      height,\n    };\n  } else {\n    return {\n      format: width,\n    };\n  }\n}\n\nfunction parseFileMetadata({\n  contentType,\n  sourcePath,\n  workspaceDir,\n  themesDir,\n  documentMetadataReader,\n}: {\n  contentType: ManuscriptMediaType;\n  sourcePath: string;\n  workspaceDir: string;\n  themesDir?: string;\n  documentMetadataReader?: DocumentMetadataReader;\n}): { title?: string; themes?: ParsedTheme[] } {\n  const sourceDir = upath.dirname(sourcePath);\n  let title: string | undefined;\n  let themes: ParsedTheme[] | undefined;\n  if (documentMetadataReader) {\n    const metadata = readMarkdownMetadata(sourcePath, documentMetadataReader);\n    title = metadata.title;\n    if (metadata.vfm?.theme && themesDir) {\n      themes = [metadata.vfm.theme]\n        .flat()\n        .filter(\n          (entry) =>\n            !!entry && (typeof entry === 'string' || typeof entry === 'object'),\n        )\n        .map((theme) =>\n          parseTheme({\n            theme,\n            context: sourceDir,\n            workspaceDir,\n            themesDir,\n          }),\n        );\n    }\n  } else if (\n    contentType === 'text/html' ||\n    contentType === 'application/xhtml+xml'\n  ) {\n    const content = fs.readFileSync(sourcePath, 'utf8');\n    title = content.match(/<title>([^<]*)<\\/title>/)?.[1] || undefined;\n  }\n  return { title, themes };\n}\n\nexport function parseCustomStyle({\n  customStyle,\n  entryContextDir,\n}: {\n  customStyle: string;\n  entryContextDir: string;\n}): string {\n  if (isValidUri(customStyle)) {\n    return customStyle;\n  }\n  const stylePath = upath.resolve(entryContextDir, customStyle);\n  if (!pathContains(entryContextDir, stylePath)) {\n    throw Error(\n      `Custom style file ${customStyle} is not in ${entryContextDir}. Make sure the file is located in the context directory or a subdirectory.`,\n    );\n  }\n  if (!fs.existsSync(stylePath)) {\n    throw new Error(`Custom style file not found: ${customStyle}`);\n  }\n  return pathToFileURL(stylePath).href.slice(\n    pathToFileURL(entryContextDir).href.replace(/\\/$/, '').length + 1,\n  );\n}\n\nexport function resolveTaskConfig(\n  config: ParsedBuildTask,\n  options: InlineOptions,\n): ResolvedTaskConfig {\n  const context = options.cwd ?? defaultCwd;\n  Logger.debug('resolveTaskConfig > context %s', context);\n\n  const entryContextDir = config.entryContext\n    ? upath.resolve(context, config.entryContext)\n    : context;\n  const language = config.language;\n  const readingProgression = config.readingProgression;\n  const size = config.size ? parsePageSize(config.size) : undefined;\n  const cropMarks = options.cropMarks ?? false;\n  const bleed = options.bleed;\n  const cropOffset = options.cropOffset;\n  const css = options.css;\n  const singleDoc = options.singleDoc ?? false;\n  const quick = options.quick ?? false;\n  const temporaryFilePrefix =\n    config.temporaryFilePrefix ?? `.vs-${Date.now()}.`;\n\n  const vfmOptions = {\n    ...config?.vfm,\n    hardLineBreaks: config?.vfm?.hardLineBreaks ?? false,\n    disableFormatHtml: config?.vfm?.disableFormatHtml ?? false,\n  };\n\n  const timeout = config.timeout ?? 300_000; // 5 minutes\n  const sandbox = options.sandbox ?? false;\n  const browser = (() => {\n    const type = config.browser?.type ?? 'chrome';\n    const platform = detectBrowserPlatform();\n    return {\n      type,\n      tag:\n        config.browser?.tag ??\n        (platform ? DEFAULT_BROWSER_VERSIONS[type][platform] : 'latest'),\n      executablePath: options.executableBrowser,\n    };\n  })();\n  const proxyServer =\n    options.proxyServer ?? process.env.HTTP_PROXY ?? undefined;\n  const proxy = proxyServer\n    ? {\n        server: proxyServer,\n        bypass: options.proxyBypass ?? process.env.NOPROXY ?? undefined,\n        username: options.proxyUser,\n        password: options.proxyPass,\n      }\n    : undefined;\n  const image = config.image ?? `${CONTAINER_URL}:${cliVersion}`;\n  const viewer = config.viewer ?? undefined;\n  const viewerParam = config.viewerParam ?? undefined;\n  const logLevel = options.logLevel ?? 'silent';\n  const ignoreHttpsErrors = options.ignoreHttpsErrors ?? false;\n  const base = config.base ?? '/vivliostyle';\n  const staticRoutes = config.static ?? {};\n  const viteConfig = config.vite;\n  const viteConfigFile = config.viteConfigFile ?? true;\n\n  const customStyle =\n    (options.style &&\n      parseCustomStyle({ customStyle: options.style, entryContextDir })) ||\n    undefined;\n  const customUserStyle =\n    (options.userStyle &&\n      parseCustomStyle({ customStyle: options.userStyle, entryContextDir })) ||\n    undefined;\n\n  const outputs = ((): OutputConfig[] => {\n    const defaultPdfOptions: Omit<PdfOutput, 'path'> = {\n      format: 'pdf',\n      renderMode: options.renderMode ?? 'local',\n      preflight:\n        options.preflight ?? (config.pressReady ? 'press-ready' : undefined),\n      preflightOption: options.preflightOption ?? [],\n    };\n    if (config.output) {\n      return config.output.map((target): OutputConfig => {\n        const outputPath = upath.resolve(context, target.path);\n        const format = target.format;\n        switch (format) {\n          case 'pdf':\n            return {\n              ...defaultPdfOptions,\n              ...target,\n              format,\n              path: outputPath,\n            };\n          case 'epub':\n            return {\n              ...target,\n              format,\n              path: outputPath,\n              version: EPUB_OUTPUT_VERSION,\n            };\n          case 'webpub':\n            return {\n              ...target,\n              format,\n              path: outputPath,\n            };\n          default:\n            return format satisfies never;\n        }\n      });\n    }\n    // Outputs a pdf file if any output configuration is not set\n    const filename = config.title ? `${config.title}.pdf` : 'output.pdf';\n    return [\n      {\n        ...defaultPdfOptions,\n        path: upath.resolve(context, filename),\n      },\n    ];\n  })();\n\n  const { server, rootUrl } = (() => {\n    let host = config.server?.host ?? false;\n    let allowedHosts = config.server?.allowedHosts || [];\n    const port = config.server?.port ?? 13000;\n    if (\n      outputs.some(\n        (target) => target.format === 'pdf' && target.renderMode === 'docker',\n      ) &&\n      !isInContainer()\n    ) {\n      // Docker render mode requires wildcard host to allow access from the container\n      host = true;\n      if (\n        Array.isArray(allowedHosts) &&\n        !allowedHosts.includes(CONTAINER_LOCAL_HOSTNAME)\n      ) {\n        allowedHosts.push(CONTAINER_LOCAL_HOSTNAME);\n      }\n    }\n    const rootHostname = !host ? 'localhost' : host === true ? '0.0.0.0' : host;\n    return {\n      server: {\n        host,\n        port,\n        proxy: config.server?.proxy ?? {},\n        allowedHosts,\n      } satisfies ResolvedTaskConfig['server'],\n      rootUrl: `http://${rootHostname}:${port}`,\n    };\n  })();\n\n  const cover = config.cover && {\n    src: upath.resolve(entryContextDir, config.cover.src),\n    name: config.cover.name || COVER_HTML_IMAGE_ALT,\n  };\n\n  const copyAsset = {\n    includes: config.copyAsset?.includes ?? config.includeAssets ?? [],\n    excludes: config.copyAsset?.excludes ?? [],\n    fileExtensions: [\n      ...new Set([\n        ...DEFAULT_ASSET_EXTENSIONS,\n        ...(config.copyAsset?.includeFileExtensions ?? []),\n      ]),\n    ].filter(\n      (ext) => !(config.copyAsset?.excludeFileExtensions ?? []).includes(ext),\n    ),\n  };\n\n  const themeIndexes = new Set<ParsedTheme>();\n  const projectConfig =\n    !options.config && options.input\n      ? resolveSingleInputConfig({\n          config,\n          input: options.input!,\n          context,\n          temporaryFilePrefix,\n          themeIndexes,\n          base,\n        })\n      : resolveComposedProjectConfig({\n          config,\n          context,\n          entryContextDir,\n          outputs,\n          temporaryFilePrefix,\n          themeIndexes,\n          cover,\n        });\n\n  // Check overwrites\n  for (const output of outputs) {\n    const relPath = upath.relative(context, output.path);\n    if (\n      pathContains(output.path, entryContextDir) ||\n      pathEquals(output.path, entryContextDir)\n    ) {\n      throw new Error(\n        `The output path is set to \"${relPath}\", but this will overwrite the original manuscript file. Please specify a different path.`,\n      );\n    }\n    if (\n      pathContains(output.path, projectConfig.workspaceDir) ||\n      pathEquals(output.path, projectConfig.workspaceDir)\n    ) {\n      throw new Error(\n        `The output path is set to \"${relPath}\", but this will overwrite the working directory of Vivliostyle. Please specify a different path.`,\n      );\n    }\n  }\n  const { entries, workspaceDir } = projectConfig;\n  const duplicatedTarget = entries.find(\n    (v1, i) => entries.findLastIndex((v2) => v1.target === v2.target) !== i,\n  )?.target;\n  if (duplicatedTarget) {\n    const sourceFile = entries.find(\n      (entry) =>\n        entry.target === duplicatedTarget && entry.source?.type === 'file',\n    )?.source as FileEntrySource | undefined;\n    throw new Error(\n      `The output path \"${upath.relative(workspaceDir, duplicatedTarget)}\" will overwrite existing content.` +\n        (sourceFile\n          ? ` Please choose a different name for the source file: ${sourceFile.pathname}`\n          : ''),\n    );\n  }\n\n  const resolvedConfig = {\n    ...projectConfig,\n    entryContextDir,\n    outputs,\n    themeIndexes,\n    copyAsset,\n    temporaryFilePrefix,\n    size,\n    cropMarks,\n    bleed,\n    cropOffset,\n    css,\n    customStyle,\n    customUserStyle,\n    singleDoc,\n    quick,\n    language,\n    readingProgression,\n    vfmOptions,\n    cover,\n    timeout,\n    sandbox,\n    browser,\n    proxy,\n    image,\n    viewer,\n    viewerParam,\n    logLevel,\n    ignoreHttpsErrors,\n    base,\n    server,\n    static: staticRoutes,\n    rootUrl,\n    viteConfig,\n    viteConfigFile,\n  } satisfies ResolvedTaskConfig;\n  return resolvedConfig;\n}\n\ntype ProjectConfig = Pick<\n  ResolvedTaskConfig,\n  | 'serverRootDir'\n  | 'workspaceDir'\n  | 'themesDir'\n  | 'entries'\n  | 'input'\n  | 'viewerInput'\n  | 'exportAliases'\n  | 'title'\n  | 'author'\n>;\n\nfunction resolveSingleInputConfig({\n  config,\n  input,\n  context,\n  temporaryFilePrefix,\n  themeIndexes,\n  base,\n}: Pick<ResolvedTaskConfig, 'temporaryFilePrefix' | 'themeIndexes' | 'base'> & {\n  config: ParsedBuildTask;\n  input: NonNullable<InlineOptions['input']>;\n  context: string;\n}): ProjectConfig {\n  Logger.debug('entering single entry config mode');\n\n  let serverRootDir: string | UseTemporaryServerRoot;\n  let sourcePath: string;\n  let workspaceDir: string;\n  const inputFormat = input.format;\n  const title = config?.title;\n  const author = config?.author;\n  const entries: ParsedEntry[] = [];\n  const exportAliases: { source: string; target: string }[] = [];\n\n  let isLocalResource = true;\n  if (isValidUri(input.entry)) {\n    const url = new URL(input.entry);\n    if (url.protocol === 'file:') {\n      sourcePath = fileURLToPath(url);\n    } else {\n      isLocalResource = false;\n      sourcePath = input.entry;\n    }\n  } else {\n    sourcePath = upath.resolve(context, input.entry);\n  }\n  if (isLocalResource) {\n    // Check file exists\n    statFileSync(sourcePath);\n    switch (input.format) {\n      case 'webbook':\n      case 'markdown':\n      case 'pub-manifest':\n      case 'epub':\n        workspaceDir = upath.dirname(sourcePath);\n        break;\n      case 'epub-opf': {\n        const rootDir = getEpubRootDir(sourcePath);\n        if (!rootDir) {\n          throw new Error(\n            `Could not determine the EPUB root directory for the OPF file: ${sourcePath}`,\n          );\n        }\n        workspaceDir = rootDir;\n        break;\n      }\n      default:\n        return input.format satisfies never;\n    }\n    serverRootDir = workspaceDir;\n  } else {\n    serverRootDir = UseTemporaryServerRoot;\n    workspaceDir = context;\n  }\n  const themesDir = upath.resolve(workspaceDir, 'themes');\n\n  if (input.format === 'markdown') {\n    // Single input file; create temporary file\n    const contentType = 'text/markdown';\n    const documentProcessor = {\n      processorFactory: config.documentProcessor ?? VFM,\n      metadataReader: config.documentMetadataReader ?? readMetadata,\n    } satisfies DocumentProcessor;\n    const metadata = parseFileMetadata({\n      contentType,\n      sourcePath,\n      workspaceDir,\n      documentMetadataReader: documentProcessor.metadataReader,\n    });\n    const target = toHtmlExtension(\n      upath.resolve(\n        workspaceDir,\n        `${temporaryFilePrefix}${upath.basename(sourcePath)}`,\n      ),\n    );\n    touchTmpFile(target);\n    const themes =\n      metadata.themes ??\n      config.theme?.map((theme) =>\n        parseTheme({\n          theme,\n          context,\n          workspaceDir,\n          themesDir,\n        }),\n      ) ??\n      [];\n    themes.forEach((t) => themeIndexes.add(t));\n    entries.push({\n      contentType,\n      source: {\n        type: 'file',\n        pathname: sourcePath,\n        contentType,\n        documentProcessor,\n      },\n      target,\n      title: metadata.title,\n      themes,\n    });\n    exportAliases.push({\n      source: target,\n      target: upath.resolve(\n        upath.dirname(target),\n        toHtmlExtension(upath.basename(sourcePath)),\n      ),\n    });\n  }\n\n  let fallbackTitle: string | undefined;\n  let viewerInput: ViewerInputConfig;\n\n  if (inputFormat === 'markdown') {\n    // create temporary manifest file\n    const manifestPath = upath.resolve(\n      workspaceDir,\n      `${temporaryFilePrefix}${MANIFEST_FILENAME}`,\n    );\n    touchTmpFile(manifestPath);\n    exportAliases.push({\n      source: manifestPath,\n      target: upath.resolve(workspaceDir, MANIFEST_FILENAME),\n    });\n    fallbackTitle =\n      entries.length === 1 && entries[0].title\n        ? (entries[0].title as string)\n        : upath.basename(sourcePath);\n    viewerInput = {\n      type: 'webpub',\n      manifestPath,\n      needToGenerateManifest: true,\n    };\n  } else if (inputFormat === 'webbook') {\n    let webbookEntryUrl: string;\n    let webbookPath: string | undefined;\n    if (isValidUri(sourcePath)) {\n      const url = new URL(sourcePath);\n      webbookEntryUrl = url.href;\n    } else {\n      const rootFileUrl = pathToFileURL(workspaceDir).href;\n      const urlPath = pathToFileURL(sourcePath).href.slice(rootFileUrl.length);\n      webbookEntryUrl = `${base}${urlPath}`;\n      webbookPath = sourcePath;\n    }\n    viewerInput = { type: 'webbook', webbookEntryUrl, webbookPath };\n  } else if (inputFormat === 'pub-manifest') {\n    viewerInput = {\n      type: 'webpub',\n      manifestPath: sourcePath,\n      needToGenerateManifest: false,\n    };\n  } else if (inputFormat === 'epub-opf') {\n    viewerInput = { type: 'epub-opf', epubOpfPath: sourcePath };\n  } else if (inputFormat === 'epub') {\n    viewerInput = {\n      type: 'epub',\n      epubPath: sourcePath,\n      epubTmpOutputDir: upath.join(\n        sourcePath,\n        `../${temporaryFilePrefix}${upath.basename(sourcePath)}`,\n      ),\n    };\n  } else {\n    return inputFormat satisfies never;\n  }\n\n  return {\n    serverRootDir,\n    workspaceDir,\n    themesDir,\n    entries,\n    input: {\n      format: inputFormat,\n      entry: sourcePath,\n    },\n    viewerInput,\n    exportAliases,\n    title: title || fallbackTitle,\n    author,\n  };\n}\n\nfunction resolveComposedProjectConfig({\n  config,\n  context,\n  entryContextDir,\n  outputs,\n  temporaryFilePrefix,\n  themeIndexes,\n  cover,\n}: Pick<\n  ResolvedTaskConfig,\n  | 'entryContextDir'\n  | 'outputs'\n  | 'temporaryFilePrefix'\n  | 'themeIndexes'\n  | 'cover'\n> & { config: ParsedBuildTask; context: string }): ProjectConfig {\n  Logger.debug('entering composed project config mode');\n\n  const workspaceDir = upath.resolve(\n    context,\n    config.workspaceDir ?? '.vivliostyle',\n  );\n  const themesDir = upath.resolve(workspaceDir, 'themes');\n  const pkgJsonPath = upath.resolve(context, 'package.json');\n  const pkgJson = fs.existsSync(pkgJsonPath)\n    ? readJSON(pkgJsonPath)\n    : undefined;\n  if (pkgJson) {\n    Logger.debug('located package.json path', pkgJsonPath);\n  }\n  const exportAliases: { source: string; target: string }[] = [];\n\n  const rootThemes =\n    config.theme?.map((theme) =>\n      parseTheme({\n        theme,\n        context,\n        workspaceDir,\n        themesDir,\n      }),\n    ) ?? [];\n  rootThemes.forEach((t) => themeIndexes.add(t));\n  const tocConfig = {\n    tocTitle: config.toc?.title ?? config?.tocTitle ?? TOC_TITLE,\n    target: upath.resolve(workspaceDir, config.toc?.htmlPath ?? TOC_FILENAME),\n    sectionDepth: config.toc?.sectionDepth ?? 0,\n    transform: {\n      transformDocumentList: config.toc?.transformDocumentList,\n      transformSectionList: config.toc?.transformSectionList,\n    },\n  };\n  const coverHtml =\n    config.cover &&\n    ('htmlPath' in config.cover && !config.cover.htmlPath\n      ? undefined\n      : upath.resolve(\n          workspaceDir,\n          config.cover?.htmlPath || COVER_HTML_FILENAME,\n        ));\n\n  const ensureCoverImage = (src?: string) => {\n    const absPath = src && upath.resolve(entryContextDir, src);\n    if (absPath) {\n      statFileSync(absPath, {\n        errorMessage: 'Specified cover image does not exist',\n      });\n    }\n    return absPath;\n  };\n\n  const projectTitle: string | undefined = config?.title ?? pkgJson?.name;\n  const projectAuthor: string | undefined = config?.author ?? pkgJson?.author;\n\n  const rootDocumentProcessor = {\n    processorFactory: config.documentProcessor ?? VFM,\n    metadataReader: config.documentMetadataReader ?? readMetadata,\n  } satisfies DocumentProcessor;\n\n  const isContentsEntry = (entry: EntryConfig): entry is ContentsEntryConfig =>\n    entry.rel === 'contents';\n  const isCoverEntry = (entry: EntryConfig): entry is CoverEntryConfig =>\n    entry.rel === 'cover';\n  const isArticleEntry = (entry: EntryConfig): entry is ArticleEntryConfig =>\n    !isContentsEntry(entry) && !isCoverEntry(entry);\n\n  function parseEntry(entry: EntryConfig): ParsedEntry {\n    const getInputInfo = (\n      entryPath: string,\n    ):\n      | (FileEntrySource & { metadata: ReturnType<typeof parseFileMetadata> })\n      | (UriEntrySource & { metadata?: undefined }) => {\n      if (/^https?:/.test(entryPath)) {\n        return {\n          type: 'uri',\n          href: entryPath,\n          rootDir: upath.join(workspaceDir, new URL(entryPath).host),\n        };\n      } else if (entryPath.startsWith('/')) {\n        return {\n          type: 'uri',\n          href: entryPath,\n          rootDir: upath.join(workspaceDir, 'localhost'),\n        };\n      }\n      const pathname = upath.resolve(entryContextDir, entryPath);\n      statFileSync(pathname);\n      const rawContentType = mime(pathname);\n\n      const documentProcessor = {\n        processorFactory:\n          ('documentProcessor' in entry && entry.documentProcessor) ||\n          rootDocumentProcessor.processorFactory,\n        metadataReader:\n          ('documentMetadataReader' in entry && entry.documentMetadataReader) ||\n          rootDocumentProcessor.metadataReader,\n      } satisfies DocumentProcessor;\n      // If custom documentProcessor is provided, allow any text-based content type\n      const hasCustomProcessor = !!(\n        documentProcessor.processorFactory !== VFM ||\n        documentProcessor.metadataReader !== readMetadata\n      );\n      const contentType =\n        hasCustomProcessor && rawContentType !== 'text/markdown'\n          ? 'text/x-vivliostyle-custom'\n          : rawContentType;\n      if (\n        !isManuscriptMediaType(contentType) ||\n        contentType === 'text/plain' // disallow text/plain (for now)\n      ) {\n        throw new Error(\n          `Invalid manuscript type ${rawContentType} detected: ${entry}`,\n        );\n      }\n\n      const useDocumentProcessor =\n        contentType === 'text/markdown' ||\n        contentType === 'text/x-vivliostyle-custom';\n      return {\n        type: 'file',\n        pathname,\n        contentType,\n        metadata: parseFileMetadata({\n          contentType,\n          sourcePath: pathname,\n          workspaceDir,\n          themesDir,\n          documentMetadataReader: useDocumentProcessor\n            ? documentProcessor.metadataReader\n            : undefined,\n        }),\n        ...(useDocumentProcessor && { documentProcessor }),\n      };\n    };\n\n    const getTargetPath = (source: EntrySource) => {\n      switch (source.type) {\n        case 'file':\n          return upath.resolve(\n            workspaceDir,\n            toHtmlExtension(upath.relative(entryContextDir, source.pathname)),\n          );\n        case 'uri': {\n          const url = new URL(source.href, 'a://dummy');\n          let pathname = url.pathname;\n          if (!/\\.\\w+$/.test(pathname)) {\n            pathname = `${pathname.replace(/\\/$/, '')}/index.html`;\n          }\n          return upath.join(source.rootDir, pathname);\n        }\n        default:\n          return source satisfies never;\n      }\n    };\n\n    if ((isContentsEntry(entry) || isCoverEntry(entry)) && entry.path) {\n      const source = upath.resolve(entryContextDir, entry.path);\n      try {\n        statFileSync(source);\n        /* v8 ignore next 10 */\n      } catch (error) {\n        // For backward compatibility, we allow missing files then assume that option as `output` field.\n        Logger.logWarn(\n          `The \"path\" option is set but the file does not exist: ${source}\\nMaybe you want to set the \"output\" field instead.`,\n        );\n        entry.output = entry.path;\n        entry.path = undefined;\n      }\n    }\n\n    if (isContentsEntry(entry)) {\n      const inputInfo = entry.path ? getInputInfo(entry.path) : undefined;\n      const { metadata, ...template } = inputInfo || {};\n      let target = entry.output\n        ? upath.resolve(workspaceDir, entry.output)\n        : inputInfo && getTargetPath(inputInfo);\n      const themes = entry.theme\n        ? [entry.theme].flat().map((theme) =>\n            parseTheme({\n              theme,\n              context,\n              workspaceDir,\n              themesDir,\n            }),\n          )\n        : (metadata?.themes ?? [...rootThemes]);\n      themes.forEach((t) => themeIndexes.add(t));\n      target ??= tocConfig.target;\n      if (\n        inputInfo?.type === 'file' &&\n        pathEquals(inputInfo.pathname, target)\n      ) {\n        const tmpPath = upath.resolve(\n          upath.dirname(target),\n          `${temporaryFilePrefix}${upath.basename(target)}`,\n        );\n        exportAliases.push({ source: tmpPath, target });\n        touchTmpFile(tmpPath);\n        target = tmpPath;\n      }\n      const parsedEntry: ContentsEntry = {\n        rel: 'contents',\n        ...tocConfig,\n        target,\n        title: entry.title ?? metadata?.title ?? projectTitle,\n        themes,\n        pageBreakBefore: entry.pageBreakBefore,\n        pageCounterReset: entry.pageCounterReset,\n        ...('type' in template && { template }),\n      };\n      return parsedEntry;\n    }\n\n    if (isCoverEntry(entry)) {\n      const inputInfo = entry.path ? getInputInfo(entry.path) : undefined;\n      const { metadata, ...template } = inputInfo || {};\n      let target = entry.output\n        ? upath.resolve(workspaceDir, entry.output)\n        : inputInfo && getTargetPath(inputInfo);\n      const themes = entry.theme\n        ? [entry.theme].flat().map((theme) =>\n            parseTheme({\n              theme,\n              context,\n              workspaceDir,\n              themesDir,\n            }),\n          )\n        : (metadata?.themes ?? []); // Don't inherit rootThemes for cover documents\n      themes.forEach((t) => themeIndexes.add(t));\n      const coverImageSrc = ensureCoverImage(entry.imageSrc || cover?.src);\n      if (!coverImageSrc) {\n        throw new Error(\n          `A CoverEntryConfig is set in the entry list but a location of cover file is not set. Please set 'cover' property in your config file.`,\n        );\n      }\n      target ??= upath.resolve(\n        workspaceDir,\n        entry.path || coverHtml || COVER_HTML_FILENAME,\n      );\n      if (\n        inputInfo?.type === 'file' &&\n        pathEquals(inputInfo.pathname, target)\n      ) {\n        const tmpPath = upath.resolve(\n          upath.dirname(target),\n          `${temporaryFilePrefix}${upath.basename(target)}`,\n        );\n        exportAliases.push({ source: tmpPath, target });\n        touchTmpFile(tmpPath);\n        target = tmpPath;\n      }\n      const parsedEntry: CoverEntry = {\n        rel: 'cover',\n        target,\n        title: entry.title ?? metadata?.title ?? projectTitle,\n        themes,\n        coverImageSrc,\n        coverImageAlt: entry.imageAlt || cover?.name || COVER_HTML_IMAGE_ALT,\n        pageBreakBefore: entry.pageBreakBefore,\n        ...('type' in template && { template }),\n      };\n      return parsedEntry;\n    }\n\n    if (isArticleEntry(entry)) {\n      const inputInfo = getInputInfo(entry.path);\n      const { metadata, ...source } = inputInfo;\n      const target = entry.output\n        ? upath.resolve(workspaceDir, entry.output)\n        : getTargetPath(inputInfo);\n      const themes = entry.theme\n        ? [entry.theme]\n            .flat()\n            .map((theme) =>\n              parseTheme({ theme, context, workspaceDir, themesDir }),\n            )\n        : (metadata?.themes ?? [...rootThemes]);\n      themes.forEach((t) => themeIndexes.add(t));\n\n      const parsedEntry: ManuscriptEntry = {\n        contentType:\n          inputInfo.type === 'file' ? inputInfo.contentType : 'text/html',\n        source,\n        target,\n        title: entry.title ?? metadata?.title ?? projectTitle,\n        themes,\n        ...(entry.rel && { rel: entry.rel }),\n      };\n      return parsedEntry;\n    }\n\n    /* v8 ignore next */\n    return entry satisfies never;\n  }\n\n  const entries = config.entry.map(parseEntry);\n\n  let fallbackProjectTitle: string | undefined;\n  if (!projectTitle) {\n    if (entries.length === 1 && entries[0].title) {\n      fallbackProjectTitle = entries[0].title;\n    } else {\n      fallbackProjectTitle = upath.basename(outputs[0].path);\n    }\n  }\n  if (!!config?.toc && !entries.find(({ rel }) => rel === 'contents')) {\n    entries.unshift({\n      rel: 'contents',\n      ...tocConfig,\n      themes: [...rootThemes],\n    });\n  }\n  if (cover && coverHtml && !entries.find(({ rel }) => rel === 'cover')) {\n    entries.unshift({\n      rel: 'cover',\n      target: coverHtml,\n      title: projectTitle,\n      themes: [], // Don't inherit rootThemes for cover documents\n      coverImageSrc: ensureCoverImage(cover.src)!,\n      coverImageAlt: cover.name,\n    });\n  }\n\n  return {\n    serverRootDir: context,\n    workspaceDir,\n    themesDir,\n    entries,\n    input: {\n      format: 'pub-manifest',\n      entry: upath.join(workspaceDir, MANIFEST_FILENAME),\n    },\n    viewerInput: {\n      type: 'webpub',\n      manifestPath: upath.join(workspaceDir, MANIFEST_FILENAME),\n      needToGenerateManifest: true,\n    },\n    exportAliases,\n    title: projectTitle || fallbackProjectTitle,\n    author: projectAuthor,\n  };\n}\n","import type { Metadata, StringifyMarkdownOptions } from '@vivliostyle/vfm';\nimport fs from 'node:fs';\nimport vfile, { type VFile } from 'vfile';\nimport type {\n  DocumentMetadataReader,\n  DocumentProcessorFactory,\n} from '../config/resolve.js';\n\nexport interface VSFile extends VFile {\n  data: {\n    title?: string;\n    theme?: string;\n  };\n}\n\nexport async function processMarkdown(\n  documentProcessorFactory: DocumentProcessorFactory,\n  documentMetadataReader: DocumentMetadataReader,\n  filepath: string,\n  options: StringifyMarkdownOptions = {},\n): Promise<VSFile> {\n  const markdownString = fs.readFileSync(filepath, 'utf8');\n  const processor = documentProcessorFactory(\n    options,\n    documentMetadataReader(markdownString),\n  );\n  const processed = (await processor.process(\n    vfile({ path: filepath, contents: markdownString }),\n  )) as VSFile;\n  return processed;\n}\n\nexport function readMarkdownMetadata(\n  filepath: string,\n  documentMetadataReader: DocumentMetadataReader,\n): Metadata {\n  return documentMetadataReader(fs.readFileSync(filepath, 'utf8'));\n}\n","import * as vite from 'vite';\nimport { launchPreview } from '../browser.js';\nimport type { ResolvedTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { getViewerFullUrl } from '../server.js';\nimport { getOsLocale, runExitHandlers } from '../util.js';\nimport { reloadConfig } from './plugin-util.js';\n\nexport function vsBrowserPlugin({\n  config: _config,\n  inlineConfig,\n}: {\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): vite.Plugin {\n  let config = _config;\n  let server: vite.ViteDevServer | undefined;\n  let closeBrowser: (() => void) | undefined;\n\n  async function handlePageClose() {\n    await server?.close();\n    runExitHandlers();\n  }\n\n  async function openPreviewPage() {\n    const locale = await getOsLocale();\n    const url = await getViewerFullUrl(config);\n    const { page, browser } = await launchPreview({\n      mode: 'preview',\n      url,\n      config,\n      /* v8 ignore next 4 */\n      onPageOpen: async (page) => {\n        // Terminate preview when the previewing page is closed\n        page.on('close', handlePageClose);\n      },\n    });\n\n    // Vivliostyle Viewer uses `i18nextLng` in localStorage for UI language\n    if (!import.meta.env?.VITEST) {\n      /* v8 ignore next 4 */\n      await page.evaluate((locale) => {\n        window.localStorage.setItem('i18nextLng', locale);\n      }, locale);\n    }\n    // Move focus from the address bar to the page\n    await page.bringToFront();\n    // Focus to the URL input box if available\n    if (!import.meta.env?.VITEST) {\n      /* v8 ignore next 6 */\n      await page.evaluate(() => {\n        document\n          .querySelector<HTMLInputElement>('#vivliostyle-input-url')\n          ?.focus();\n      });\n    }\n\n    closeBrowser = () => {\n      page.off('close', handlePageClose);\n      browser.close();\n    };\n  }\n\n  return {\n    name: 'vivliostyle:browser',\n    apply: () => Boolean(inlineConfig.openViewer),\n    configureServer(viteServer) {\n      server = viteServer;\n\n      const _listen = viteServer.listen;\n      viteServer.listen = async (...args) => {\n        const server = await _listen(...args);\n        config = await reloadConfig(config, inlineConfig, server.config);\n        await openPreviewPage();\n        return server;\n      };\n    },\n    closeBundle() {\n      closeBrowser?.();\n    },\n  };\n}\n","import type {\n  InstalledBrowser,\n  Browser as SupportedBrowser,\n} from '@puppeteer/browsers';\nimport fs from 'node:fs';\nimport type {\n  Browser,\n  BrowserContext,\n  LaunchOptions,\n  Page,\n} from 'puppeteer-core';\nimport upath from 'upath';\nimport type { ResolvedTaskConfig } from './config/resolve.js';\nimport type { BrowserType } from './config/schema.js';\nimport { Logger } from './logger.js';\nimport { importNodeModule } from './node-modules.js';\nimport {\n  detectBrowserPlatform,\n  getCacheDir,\n  getDefaultBrowserTag,\n  isInContainer,\n  isRunningOnWSL,\n  registerExitHandler,\n} from './util.js';\n\nconst browserEnumMap = {\n  chrome: 'chrome' as SupportedBrowser.CHROME,\n  chromium: 'chromium' as SupportedBrowser.CHROMIUM,\n  firefox: 'firefox' as SupportedBrowser.FIREFOX,\n} as const satisfies {\n  [key in BrowserType]: SupportedBrowser;\n};\n\nasync function launchBrowser({\n  browserType,\n  proxy,\n  executablePath,\n  headless,\n  noSandbox,\n  disableDevShmUsage,\n  ignoreHttpsErrors,\n}: {\n  browserType: BrowserType;\n  proxy:\n    | {\n        server: string;\n        bypass: string | undefined;\n        username: string | undefined;\n        password: string | undefined;\n      }\n    | undefined;\n  executablePath: string;\n  headless: boolean;\n  noSandbox: boolean;\n  disableDevShmUsage: boolean;\n  ignoreHttpsErrors: boolean;\n}): Promise<{\n  browser: Browser;\n  browserContext: BrowserContext;\n}> {\n  const puppeteer = await importNodeModule('puppeteer-core');\n\n  const args: string[] = [];\n  // https://github.com/microsoft/playwright/blob/35709546cd4210b7744943ceb22b92c1b126d48d/packages/playwright-core/src/server/chromium/chromium.ts\n  if (browserType === 'chrome' || browserType === 'chromium') {\n    args.push(\n      '--disable-field-trial-config',\n      '--disable-back-forward-cache',\n      '--disable-component-update',\n      '--no-default-browser-check',\n      '--disable-features=AcceptCHFrame,AvoidUnnecessaryBeforeUnloadCheckSync,DestroyProfileOnBrowserClose,DialMediaRouteProvider,GlobalMediaControls,HttpsUpgrades,LensOverlay,MediaRouter,PaintHolding,ThirdPartyStoragePartitioning,Translate,AutoDeElevate,RenderDocument',\n      '--enable-features=CDPScreenshotNewSurface',\n      '--no-service-autorun',\n      '--unsafely-disable-devtools-self-xss-warnings',\n      '--edge-skip-compat-layer-relaunch',\n    );\n\n    if (process.platform === 'darwin') {\n      args.push('--enable-unsafe-swiftshader');\n    }\n    if (noSandbox) {\n      args.push('--no-sandbox');\n    }\n    if (headless) {\n      args.push(\n        '--hide-scrollbars',\n        '--mute-audio',\n        '--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4',\n      );\n    }\n    if (proxy?.server) {\n      const proxyURL = new URL(proxy.server);\n      const isSocks = proxyURL.protocol === 'socks5:';\n      if (isSocks) {\n        args.push(\n          `--host-resolver-rules=\"MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}\"`,\n        );\n      }\n      args.push(`--proxy-server=${proxy.server}`);\n      const proxyBypassRules = [];\n      if (proxy.bypass) {\n        proxyBypassRules.push(\n          ...proxy.bypass\n            .split(',')\n            .map((t) => t.trim())\n            .map((t) => (t.startsWith('.') ? '*' + t : t)),\n        );\n      }\n      proxyBypassRules.push('<-loopback>');\n      args.push(`--proxy-bypass-list=${proxyBypassRules.join(';')}`);\n    }\n    // #579: disable web security to allow cross-origin requests\n    args.push('--disable-web-security');\n    if (disableDevShmUsage) {\n      args.push('--disable-dev-shm-usage');\n    }\n    // #357: Set devicePixelRatio=1 otherwise it causes layout issues in HiDPI displays\n    if (headless) {\n      args.push('--force-device-scale-factor=1');\n    }\n    // #565: Add --disable-gpu option when running on WSL\n    if (isRunningOnWSL()) {\n      args.push('--disable-gpu');\n    }\n    // set Chromium language to English to avoid locale-dependent issues\n    args.push('--lang=en');\n    if (!headless && process.platform === 'darwin') {\n      args.push('-AppleLanguages', '(en)');\n    }\n    args.push('--no-startup-window');\n  }\n  // TODO: Investigate appropriate settings on Firefox\n\n  const launchOptions = {\n    executablePath,\n    args,\n    browser: browserType === 'chromium' ? 'chrome' : browserType,\n    headless,\n    acceptInsecureCerts: ignoreHttpsErrors,\n    waitForInitialPage: false,\n  } satisfies LaunchOptions;\n  Logger.debug('launchOptions %O', launchOptions);\n  const browser = await puppeteer.launch({\n    ...launchOptions,\n    env: { ...process.env, LANG: 'en.UTF-8' },\n  });\n  registerExitHandler('Closing browser', () => {\n    browser.close();\n  });\n  const [browserContext] = browser.browserContexts();\n  return { browser, browserContext };\n}\n\nfunction getPuppeteerCacheDir() {\n  if (isInContainer()) {\n    return '/opt/puppeteer';\n  }\n  return upath.join(getCacheDir(), 'browsers');\n}\n\ninterface BuildIdsCache {\n  createdAt: number;\n  buildIds: Record<string, Record<string, string>>;\n}\n\nasync function resolveBuildId({\n  type,\n  tag,\n  browsers,\n}: Pick<ResolvedTaskConfig['browser'], 'type' | 'tag'> & {\n  browsers: typeof import('@puppeteer/browsers');\n}): Promise<string> {\n  // Return cached data to reduce network requests to browser registry\n  // Cache is valid for 24 hours\n  const cacheDataFilename = upath.join(\n    getPuppeteerCacheDir(),\n    'build-ids.json',\n  );\n  let cacheData: BuildIdsCache;\n  try {\n    cacheData = JSON.parse(fs.readFileSync(cacheDataFilename, 'utf-8'));\n    if (Date.now() - cacheData.createdAt > 24 * 60 * 60 * 1000) {\n      cacheData = { createdAt: Date.now(), buildIds: {} };\n    }\n  } catch (_) {\n    cacheData = { createdAt: Date.now(), buildIds: {} };\n  }\n  if (cacheData.buildIds[type]?.[tag]) {\n    return cacheData.buildIds[type][tag];\n  }\n\n  const platform = detectBrowserPlatform();\n  if (!platform) {\n    throw new Error('The current platform is not supported.');\n  }\n  const buildId = await browsers.resolveBuildId(\n    browserEnumMap[type],\n    platform,\n    tag,\n  );\n  (cacheData.buildIds[type] ??= {})[tag] = buildId;\n  fs.mkdirSync(upath.dirname(cacheDataFilename), { recursive: true });\n  fs.writeFileSync(cacheDataFilename, JSON.stringify(cacheData));\n  return buildId;\n}\n\nasync function cleanupOutdatedBrowsers() {\n  for (const browser of Object.values(browserEnumMap)) {\n    const browsersDir = upath.join(getPuppeteerCacheDir(), browser);\n    if (!fs.existsSync(browsersDir)) {\n      continue;\n    }\n    const entries = fs.readdirSync(browsersDir);\n    for (const entry of entries) {\n      const entryPath = upath.join(browsersDir, entry);\n      const stat = fs.statSync(entryPath);\n      // Files that are not directories are temporary files created\n      // during downloads and should be deleted.\n      if (\n        !stat.isDirectory() ||\n        Date.now() - stat.mtimeMs > 7 * 24 * 60 * 60 * 1000\n      ) {\n        Logger.debug(`Removing outdated browser at ${entryPath}`);\n        await fs.promises.rm(entryPath, { recursive: true, force: true });\n      }\n    }\n  }\n}\n\nexport async function getExecutableBrowserPath({\n  type,\n  tag,\n}: ResolvedTaskConfig['browser']): Promise<string> {\n  const browsers = await importNodeModule('@puppeteer/browsers');\n  const buildId = await resolveBuildId({ type, tag, browsers });\n  return browsers.computeExecutablePath({\n    cacheDir: getPuppeteerCacheDir(),\n    browser: browserEnumMap[type],\n    buildId,\n  });\n}\n\nfunction checkBrowserAvailability(path: string): boolean {\n  return fs.existsSync(path);\n}\n\nasync function downloadBrowser({\n  type,\n  tag,\n}: ResolvedTaskConfig['browser']): Promise<string> {\n  const browsers = await importNodeModule('@puppeteer/browsers');\n  const buildId = await resolveBuildId({ type, tag, browsers });\n  let installedBrowser: InstalledBrowser | undefined;\n\n  if (isInContainer()) {\n    const defaultBrowserVersion = getDefaultBrowserTag('chrome');\n    Logger.logWarn(\n      `The container you are using already includes a browser (chrome@${defaultBrowserVersion}); however, the specified browser ${type}@${tag} was not found. Downloading the browser inside the container may take a long time. Consider using a container image that includes the required browser version.`,\n    );\n  }\n  {\n    using _ = Logger.suspendLogging(\n      'Rendering browser is not installed yet. Downloading now.',\n    );\n    installedBrowser = await browsers.install({\n      cacheDir: getPuppeteerCacheDir(),\n      browser: browserEnumMap[type],\n      buildId,\n      downloadProgressCallback: 'default',\n    });\n  }\n  return installedBrowser.executablePath;\n}\n\nexport async function launchPreview({\n  mode,\n  url,\n  onBrowserOpen,\n  onPageOpen,\n  config: { browser: browserConfig, proxy, sandbox, ignoreHttpsErrors },\n}: {\n  mode: 'preview' | 'build';\n  url: string;\n  onBrowserOpen?: (browser: Browser) => void | Promise<void>;\n  onPageOpen?: (page: Page) => void | Promise<void>;\n  config: Pick<\n    ResolvedTaskConfig,\n    'browser' | 'proxy' | 'sandbox' | 'ignoreHttpsErrors'\n  >;\n}) {\n  let executableBrowser = browserConfig.executablePath;\n  Logger.debug(`Specified browser path: ${executableBrowser}`);\n  if (executableBrowser) {\n    if (!checkBrowserAvailability(executableBrowser)) {\n      throw new Error(\n        `Cannot find the browser. Please check the executable browser path: ${executableBrowser}`,\n      );\n    }\n  } else if (\n    detectBrowserPlatform() === 'linux_arm' &&\n    (browserConfig.type === 'chrome' || browserConfig.type === 'chromium')\n  ) {\n    // https://github.com/puppeteer/puppeteer/issues/7740\n    Logger.logInfo(\n      'The official Chrome/Chromium binaries are not available for ARM64 Linux. Using the system-installed Chromium browser instead.',\n    );\n    executableBrowser = '/usr/bin/chromium';\n  } else {\n    executableBrowser = await getExecutableBrowserPath(browserConfig);\n    Logger.debug(`Using default browser: ${executableBrowser}`);\n    if (!checkBrowserAvailability(executableBrowser)) {\n      // The browser isn't downloaded first time starting CLI so try to download it\n      await cleanupOutdatedBrowsers();\n      await downloadBrowser(browserConfig);\n    }\n  }\n\n  const { browser, browserContext } = await launchBrowser({\n    browserType: browserConfig.type,\n    proxy,\n    executablePath: executableBrowser,\n    headless: mode === 'build',\n    noSandbox: !sandbox,\n    disableDevShmUsage: isInContainer(),\n    ignoreHttpsErrors,\n  });\n  await onBrowserOpen?.(browser);\n\n  const page =\n    (await browserContext.pages())[0] ?? (await browserContext.newPage());\n  await page.setViewport(\n    mode === 'build'\n      ? // This viewport size is important to detect headless environment in Vivliostyle viewer\n        // https://github.com/vivliostyle/vivliostyle.js/blob/73bcf323adcad80126b0175630609451ccd09d8a/packages/core/src/vivliostyle/vgen.ts#L2489-L2500\n        { width: 800, height: 600 }\n      : null,\n  );\n  await onPageOpen?.(page);\n\n  // Prevent confirm dialog from being auto-dismissed\n  page.on('dialog', () => {});\n\n  if (proxy?.username && proxy?.password) {\n    await page.authenticate({\n      username: proxy.username,\n      password: proxy.password,\n    });\n  }\n  await page.goto(url);\n\n  return { browser, page };\n}\n","import fs from 'node:fs';\nimport { URL } from 'node:url';\nimport upath from 'upath';\nimport {\n  createServer,\n  type InlineConfig,\n  preview,\n  type PreviewServer,\n  type ResolvedConfig as ResolvedViteConfig,\n  type ViteDevServer,\n} from 'vite';\nimport type { ResolvedTaskConfig } from './config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from './config/schema.js';\nimport { EMPTY_DATA_URI, VIEWER_ROOT_PATH } from './const.js';\nimport { Logger } from './logger.js';\nimport {\n  getDefaultEpubOpfPath,\n  isValidUri,\n  openEpub,\n  registerExitHandler,\n} from './util.js';\nimport { vsBrowserPlugin } from './vite/vite-plugin-browser.js';\nimport { vsDevServerPlugin } from './vite/vite-plugin-dev-server.js';\nimport { vsStaticServePlugin } from './vite/vite-plugin-static-serve.js';\nimport { vsViewerPlugin } from './vite/vite-plugin-viewer.js';\n\nexport type ViewerUrlOption = Pick<\n  ResolvedTaskConfig,\n  | 'size'\n  | 'cropMarks'\n  | 'bleed'\n  | 'cropOffset'\n  | 'css'\n  | 'customStyle'\n  | 'customUserStyle'\n  | 'singleDoc'\n  | 'quick'\n  | 'viewerParam'\n  | 'base'\n>;\n\nexport function getViewerParams(\n  src: string | undefined,\n  {\n    size,\n    cropMarks,\n    bleed,\n    cropOffset,\n    css,\n    customStyle,\n    customUserStyle,\n    singleDoc,\n    quick,\n    viewerParam,\n    base,\n  }: ViewerUrlOption,\n): string {\n  const pageSizeValue =\n    size && ('format' in size ? size.format : `${size.width} ${size.height}`);\n\n  function escapeParam(url: string) {\n    return url.replace(/&/g, '%26');\n  }\n\n  let viewerParams = src ? `src=${escapeParam(src)}` : '';\n  viewerParams += `&bookMode=${!singleDoc}&renderAllPages=${!quick}`;\n\n  if (customStyle) {\n    const param = isValidUri(customStyle)\n      ? customStyle\n      : upath.posix.join(base, customStyle);\n    viewerParams += `&style=${escapeParam(param)}`;\n  }\n\n  if (customUserStyle) {\n    const param = isValidUri(customUserStyle)\n      ? customUserStyle\n      : upath.posix.join(base, customUserStyle);\n    viewerParams += `&userStyle=${escapeParam(param)}`;\n  }\n\n  if (pageSizeValue || cropMarks || bleed || cropOffset || css) {\n    let pageStyle = '@page{';\n    if (pageSizeValue) {\n      pageStyle += `size:${pageSizeValue};`;\n    }\n    if (cropMarks) {\n      pageStyle += `marks:crop cross;`;\n    }\n    if (bleed || cropMarks) {\n      pageStyle += `bleed:${bleed ?? '3mm'};`;\n    }\n    if (cropOffset) {\n      pageStyle += `crop-offset:${cropOffset};`;\n    }\n    pageStyle += '}';\n\n    // The pageStyle settings are put between the `/*<viewer>*/` and `/*</viewer>*/`\n    // in the `&style=data:,â€¦` viewer parameter so that they are reflected in the\n    // Settings menu of the Viewer. Also the custom CSS code is appended after the\n    // `/*</viewer>*/` so that it is shown in the Edit CSS box in the Settings menu.\n    viewerParams += `&style=data:,/*<viewer>*/${encodeURIComponent(\n      pageStyle,\n    )}/*</viewer>*/${encodeURIComponent(css ?? '')}`;\n  }\n\n  if (viewerParam) {\n    // append additional viewer parameters\n    viewerParams += `&${viewerParam}`;\n  }\n\n  return viewerParams;\n}\n\nexport async function getSourceUrl({\n  viewerInput,\n  base,\n  workspaceDir,\n  rootUrl,\n}: Pick<\n  ResolvedTaskConfig,\n  'viewerInput' | 'base' | 'workspaceDir' | 'rootUrl'\n>) {\n  let input: string;\n  switch (viewerInput.type) {\n    case 'webpub':\n      input = viewerInput.manifestPath;\n      break;\n    case 'webbook':\n      input = viewerInput.webbookEntryUrl;\n      break;\n    case 'epub-opf':\n      input = viewerInput.epubOpfPath;\n      break;\n    case 'epub': {\n      if (!fs.existsSync(viewerInput.epubTmpOutputDir)) {\n        await openEpub(viewerInput.epubPath, viewerInput.epubTmpOutputDir);\n      }\n      input = getDefaultEpubOpfPath(viewerInput.epubTmpOutputDir);\n      break;\n    }\n    default:\n      input = viewerInput satisfies never;\n  }\n  return (\n    isValidUri(input)\n      ? new URL(input)\n      : new URL(\n          upath.posix.join(base, upath.relative(workspaceDir, input)),\n          rootUrl,\n        )\n  ).href;\n}\n\nexport async function getViewerFullUrl({\n  viewerInput,\n  base,\n  workspaceDir,\n  rootUrl,\n  viewer,\n  ...config\n}: ViewerUrlOption &\n  Pick<\n    ResolvedTaskConfig,\n    'viewerInput' | 'base' | 'workspaceDir' | 'rootUrl' | 'viewer'\n  >) {\n  const viewerUrl = viewer\n    ? new URL(viewer)\n    : new URL(`${VIEWER_ROOT_PATH}/index.html`, rootUrl);\n  const sourceUrl = await getSourceUrl({\n    viewerInput,\n    base,\n    workspaceDir,\n    rootUrl,\n  });\n  const viewerParams = getViewerParams(\n    sourceUrl === EMPTY_DATA_URI\n      ? undefined // open Viewer start page\n      : sourceUrl,\n    { base, ...config },\n  );\n  viewerUrl.hash = '';\n  return `${viewerUrl.href}#${viewerParams}`;\n}\n\nexport async function createViteServer(args: {\n  config: ResolvedTaskConfig;\n  viteConfig: ResolvedViteConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n  mode: 'preview';\n}): Promise<ViteDevServer>;\nexport async function createViteServer(args: {\n  config: ResolvedTaskConfig;\n  viteConfig: ResolvedViteConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n  mode: 'build';\n}): Promise<PreviewServer>;\nexport async function createViteServer({\n  config,\n  viteConfig,\n  inlineConfig,\n  mode,\n}: {\n  config: ResolvedTaskConfig;\n  viteConfig: ResolvedViteConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n  mode: 'preview' | 'build';\n}) {\n  const viteInlineConfig = {\n    clearScreen: false,\n    configFile: false,\n    appType: 'custom',\n    plugins: [\n      vsDevServerPlugin({ config, inlineConfig }),\n      vsViewerPlugin({ config, inlineConfig }),\n      vsBrowserPlugin({ config, inlineConfig }),\n      vsStaticServePlugin({ config, inlineConfig }),\n    ],\n    server: viteConfig.server,\n    preview: viteConfig.preview,\n    customLogger: viteConfig.customLogger,\n    cacheDir: viteConfig.cacheDir,\n    root: viteConfig.root,\n  } satisfies InlineConfig;\n  Logger.debug('createViteServer > viteInlineConfig %O', viteInlineConfig);\n\n  if (config.serverRootDir === config.workspaceDir) {\n    const { cacheDir } = viteInlineConfig;\n    registerExitHandler('Removing the Vite cacheDir', () => {\n      if (fs.existsSync(cacheDir)) {\n        fs.rmSync(cacheDir, { recursive: true });\n      }\n    });\n  }\n\n  if (mode === 'preview') {\n    return await createServer(viteInlineConfig);\n  } else {\n    return await preview(viteInlineConfig);\n  }\n}\n","import type { NextHandleFunction } from 'connect';\nimport escapeRe from 'escape-string-regexp';\nimport { pathToFileURL } from 'node:url';\nimport sirv, { type RequestHandler } from 'sirv';\nimport upath from 'upath';\nimport * as vite from 'vite';\nimport { locateVivliostyleConfig } from '../config/load.js';\nimport {\n  isWebPubConfig,\n  type ParsedEntry,\n  type ParsedTheme,\n  type ResolvedTaskConfig,\n} from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { Logger } from '../logger.js';\nimport {\n  getAssetMatcher,\n  getWebPubResourceMatcher,\n  GlobMatcher,\n} from '../processor/asset.js';\nimport {\n  generateManifest,\n  prepareThemeDirectory,\n  transformManuscript,\n} from '../processor/compile.js';\nimport {\n  debounce,\n  getFormattedError,\n  pathContains,\n  pathEquals,\n} from '../util.js';\nimport { reloadConfig } from './plugin-util.js';\n\n// Ref: https://github.com/lukeed/sirv\nfunction createEntriesRouteLookup(entries: ParsedEntry[], cwd: string) {\n  const extns = ['', 'html', 'htm'];\n  const toAssume = (uri: string) => {\n    let i = 0,\n      x,\n      len = uri.length - 1;\n    if (uri.charCodeAt(len) === 47) {\n      uri = uri.substring(0, len);\n    }\n    let arr = [],\n      tmp = `${uri}/index`;\n    for (; i < extns.length; i++) {\n      x = extns[i] ? `.${extns[i]}` : '';\n      if (uri) arr.push(uri + x);\n      arr.push(tmp + x);\n    }\n\n    return arr;\n  };\n  const cache = entries.reduce<Record<string, ParsedEntry>>((acc, e) => {\n    acc[`/${upath.relative(cwd, e.target).normalize().replace(/\\\\+/g, '/')}`] =\n      e;\n    return acc;\n  }, {});\n  return (uri: string) => {\n    let i = 0,\n      data,\n      arr = toAssume(uri);\n    for (; i < arr.length; i++) {\n      if ((data = cache[arr[i]])) return [data, arr[i]] as const;\n    }\n  };\n}\n\nfunction getWorkspaceMatcher({\n  workspaceDir,\n  themesDir,\n  viewerInput,\n  themeIndexes,\n  entries,\n  outputs,\n  copyAsset,\n}: ResolvedTaskConfig) {\n  if (viewerInput.type === 'webpub') {\n    return getWebPubResourceMatcher({\n      outputs,\n      themesDir,\n      entries,\n      cwd: workspaceDir,\n      manifestPath: viewerInput.manifestPath,\n      copyAsset,\n    });\n  }\n\n  let entryFiles: string[] = [];\n  switch (viewerInput.type) {\n    case 'epub':\n      entryFiles = [\n        upath.join(\n          upath.relative(workspaceDir, viewerInput.epubTmpOutputDir),\n          '**',\n        ),\n      ];\n      break;\n    case 'epub-opf':\n    case 'webbook':\n      entryFiles = ['**'];\n      break;\n    default:\n      entryFiles = viewerInput satisfies never;\n  }\n\n  return new GlobMatcher([\n    {\n      patterns: entryFiles,\n      ignore: ['node_modules/**'],\n      dot: true,\n      cwd: workspaceDir,\n    },\n  ]);\n}\n\nexport function vsDevServerPlugin({\n  config: _config,\n  inlineConfig,\n}: {\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): vite.Plugin {\n  let config = _config;\n  let server: vite.ViteDevServer | undefined;\n  let program:\n    | {\n        entriesLookup: (\n          uri: string,\n        ) => readonly [ParsedEntry, string] | undefined;\n        urlMatchRe: RegExp;\n        serveWorkspace: RequestHandler;\n        serveWorkspaceMatcher: GlobMatcher;\n        serveAssets: RequestHandler;\n        serveAssetsMatcher: GlobMatcher;\n      }\n    | undefined;\n\n  const transformCache: Map<\n    string,\n    Promise<{ content: string; etag: string } | undefined>\n  > = new Map();\n  let matchProjectDep: (pathname: string) => boolean;\n\n  async function reload(forceUpdate = false) {\n    const prevConfig = config;\n    config = await reloadConfig(prevConfig, inlineConfig, server?.config);\n\n    transformCache.clear();\n    const needToUpdateManifest =\n      forceUpdate ||\n      // FIXME: More precise comparison\n      JSON.stringify(prevConfig) !== JSON.stringify(config);\n    if (\n      isWebPubConfig(config) &&\n      config.viewerInput.needToGenerateManifest &&\n      needToUpdateManifest\n    ) {\n      await generateManifest(config);\n    }\n\n    await prepareThemeDirectory(config);\n\n    const entriesLookup = createEntriesRouteLookup(\n      config.entries,\n      config.workspaceDir,\n    );\n    const urlMatchRe = new RegExp(\n      `^${escapeRe(config.base)}(/[^?#]*)([?#].*)?$`,\n    );\n    const serveWorkspace = sirv(config.workspaceDir, {\n      dev: true,\n      etag: false,\n      dotfiles: true,\n      extensions: [],\n    });\n    const serveWorkspaceMatcher = getWorkspaceMatcher(config);\n    const serveAssets = sirv(config.entryContextDir, {\n      dev: true,\n      etag: false,\n      extensions: [],\n    });\n    const serveAssetsMatcher = getAssetMatcher({\n      ...config,\n      cwd: config.entryContextDir,\n    });\n    program = {\n      entriesLookup,\n      urlMatchRe,\n      serveWorkspace,\n      serveWorkspaceMatcher,\n      serveAssets,\n      serveAssetsMatcher,\n    };\n    if (needToUpdateManifest) {\n      Logger.debug(\n        'dev-server > serveWorkspaceMatcher %O',\n        serveWorkspaceMatcher.matcherConfig,\n      );\n      Logger.debug(\n        'dev-server > serveAssetsMatcher %O',\n        serveAssetsMatcher.matcherConfig,\n      );\n    }\n\n    const configPath = locateVivliostyleConfig(inlineConfig);\n    const projectDeps: string[] = [];\n    if (configPath) {\n      projectDeps.push(configPath);\n      server?.watcher.add(configPath);\n    }\n    if (config.viewerInput.type === 'webpub') {\n      projectDeps.push(config.viewerInput.manifestPath);\n      server?.watcher.add(config.viewerInput.manifestPath);\n    }\n\n    const flattenWatchTarget = (themes: Set<ParsedTheme>) =>\n      [...themes].flatMap((theme) => {\n        if (theme.type === 'file') {\n          return [theme.source];\n        }\n        if (theme.type === 'package' && !theme.registry) {\n          return [theme.specifier];\n        }\n        return [];\n      });\n    const prevThemeFiles = flattenWatchTarget(prevConfig.themeIndexes);\n    const themeFiles = flattenWatchTarget(config.themeIndexes);\n    server?.watcher.unwatch(\n      prevThemeFiles.filter((target) => !themeFiles.includes(target)),\n    );\n    server?.watcher.add(themeFiles);\n    projectDeps.push(...themeFiles);\n    matchProjectDep = (pathname: string) =>\n      projectDeps.some(\n        (dep) => pathEquals(dep, pathname) || pathContains(dep, pathname),\n      );\n  }\n\n  async function transform(entry: ParsedEntry, host: string | undefined) {\n    if (!isWebPubConfig(config)) {\n      return;\n    }\n    // Respect the host header instead of the original rootUrl configuration,\n    // as the dev server may run on a different port through a server other than Vite.\n    const rootUrl = host\n      ? `${server?.config.server.https ? 'https' : 'http'}://${host}`\n      : config.rootUrl;\n    const promise = (async () => {\n      try {\n        const html = await transformManuscript(entry, { ...config, rootUrl });\n        if (!html) {\n          transformCache.delete(entry.target);\n          return;\n        }\n        const etag = `W/\"${Date.now()}\"`;\n        if (entry.source?.type === 'file') {\n          server?.watcher.add(entry.source.pathname);\n        }\n        return { content: html, etag };\n      } catch (error: any) {\n        server?.config.logger.error(getFormattedError(error));\n        transformCache.delete(entry.target);\n        return;\n      }\n    })();\n    transformCache.set(entry.target, promise);\n    return await promise;\n  }\n\n  async function transformAll(host: string | undefined) {\n    const tocEntries: ParsedEntry[] = [];\n    for (const entry of config.entries) {\n      if (entry.rel === 'contents') {\n        // To transpile the table of contents, all dependent content must be transpiled in advance\n        tocEntries.push(entry);\n        continue;\n      }\n      await transform(entry, host);\n    }\n    for (const entry of tocEntries) {\n      await transform(entry, host);\n    }\n  }\n\n  async function invalidate(entry: ParsedEntry) {\n    const cwd = pathToFileURL(config.workspaceDir);\n    const target = pathToFileURL(entry.target);\n    if (target.href.indexOf(cwd.href) !== 0) {\n      return;\n    }\n    transformCache.delete(entry.target);\n    config.entries\n      .filter((entry) => entry.rel === 'contents')\n      .forEach((entry) => {\n        transformCache.delete(entry.target);\n      });\n    server?.ws.send({\n      type: 'full-reload',\n      path: target.href.slice(cwd.href.length),\n    });\n  }\n\n  const devServerMiddleware = async function vivliostyleDevServerMiddleware(\n    req,\n    res,\n    next,\n  ) {\n    if (!program) {\n      return next();\n    }\n    const { entriesLookup, urlMatchRe } = program;\n    const [_, pathname, qs] = decodeURI(req.url!).match(urlMatchRe) ?? [];\n    const match = pathname && entriesLookup(pathname);\n    if (!match) {\n      return next();\n    }\n    const [entry, expected] = match;\n    // Enforce using the actual path to match the full-reload event of the Vite client\n    if (pathname !== expected) {\n      res.statusCode = 301;\n      res.setHeader('Location', `${expected}${qs || ''}`);\n      return res.end();\n    }\n\n    Logger.debug('dev-server > request %s', pathname);\n    const cachePromise = transformCache.get(entry.target);\n    if (cachePromise) {\n      const cached = await cachePromise;\n      if (!cached) {\n        return next();\n      }\n      if (req.headers['if-none-match'] === cached.etag) {\n        res.statusCode = 304;\n        return res.end();\n      } else {\n        res.statusCode = 200;\n        res.setHeader('Content-Type', 'text/html;charset=utf-8');\n        res.setHeader('Cache-Control', 'no-cache');\n        res.setHeader('Etag', cached.etag);\n        return res.end(cached.content);\n      }\n    }\n\n    const { host } = req.headers;\n    if (entry.rel === 'contents') {\n      await transformAll(host);\n    }\n    const result = await transform(entry, host);\n    if (!result) {\n      return next();\n    }\n\n    res.statusCode = 200;\n    res.setHeader('Content-Type', 'text/html;charset=utf-8');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Etag', result.etag);\n    return res.end(result.content);\n  } satisfies NextHandleFunction;\n\n  const serveWorkspaceMiddleware =\n    async function vivliostyleServeWorkspaceMiddleware(req, res, next) {\n      if (!config || !program) {\n        return next();\n      }\n      const {\n        urlMatchRe,\n        serveWorkspace,\n        serveWorkspaceMatcher,\n        serveAssets,\n        serveAssetsMatcher,\n      } = program;\n      const [_, pathname] = decodeURI(req.url!).match(urlMatchRe) ?? [];\n      if (!pathname) {\n        return next();\n      }\n\n      const handleWorkspace = (next: () => void) => {\n        if (!serveWorkspaceMatcher.match(pathname.slice(1))) {\n          return next();\n        }\n        Logger.debug('dev-server > serveWorkspace %s', pathname);\n        const url = req.url!;\n        req.url = req.url!.slice(config.base.length);\n        return serveWorkspace(req, res, () => {\n          req.url = url;\n          next();\n        });\n      };\n\n      const handleAssets = (next: () => void) => {\n        if (!serveAssetsMatcher.match(pathname.slice(1))) {\n          return next();\n        }\n        Logger.debug('dev-server > serveAssets %s', pathname);\n        const url = req.url!;\n        req.url = url!.slice(config.base.length);\n        return serveAssets(req, res, () => {\n          req.url = url;\n          next();\n        });\n      };\n\n      handleWorkspace(() => handleAssets(next));\n    } satisfies NextHandleFunction;\n\n  return {\n    name: 'vivliostyle:dev-server',\n    enforce: 'pre',\n\n    configureServer(viteServer) {\n      server = viteServer;\n      const requestReload = debounce(async () => {\n        await reload();\n        viteServer.ws.send({\n          type: 'full-reload',\n          path: '*',\n        });\n      }, 200);\n      const handleUpdate = (pathname: string) => {\n        if (!matchProjectDep?.(pathname)) {\n          return;\n        }\n        requestReload();\n      };\n      viteServer.watcher.on('add', handleUpdate);\n      viteServer.watcher.on('change', handleUpdate);\n      viteServer.watcher.on('unlink', handleUpdate);\n\n      return () => {\n        viteServer.middlewares.use(devServerMiddleware);\n        viteServer.middlewares.use(serveWorkspaceMiddleware);\n      };\n    },\n    configurePreviewServer(viteServer) {\n      return () => {\n        viteServer.middlewares.use(\n          config.base,\n          sirv(config.workspaceDir, { dev: true, etag: false, extensions: [] }),\n        );\n      };\n    },\n    async buildStart() {\n      await reload(true);\n      await transformAll(undefined);\n    },\n    async handleHotUpdate(ctx) {\n      const entry = config?.entries.find(\n        (e) =>\n          (e.source?.type === 'file' && e.source.pathname === ctx.file) ||\n          (!e.source && e.target === ctx.file),\n      );\n      if (config && entry) {\n        await invalidate(entry);\n      }\n    },\n  };\n}\n","import jsdom, { JSDOM } from '@vivliostyle/jsdom';\nimport { copy, move } from 'fs-extra/esm';\nimport fs from 'node:fs';\nimport upath from 'upath';\nimport serializeToXml from 'w3c-xmlserializer';\nimport MIMEType from 'whatwg-mimetype';\nimport type {\n  ContentsEntry,\n  CoverEntry,\n  ManuscriptEntry,\n  ParsedEntry,\n  ParsedTheme,\n  ResolvedTaskConfig,\n  WebPublicationManifestConfig,\n} from '../config/resolve.js';\nimport type { ArticleEntryConfig } from '../config/schema.js';\nimport { XML_DECLARATION } from '../const.js';\nimport { Logger } from '../logger.js';\nimport { writePublicationManifest } from '../output/webbook.js';\nimport {\n  DetailError,\n  pathContains,\n  pathEquals,\n  registerExitHandler,\n  writeFileIfChanged,\n} from '../util.js';\nimport {\n  createVirtualConsole,\n  generateDefaultCoverHtml,\n  generateDefaultTocHtml,\n  getJsdomFromString,\n  getJsdomFromUrlOrFile,\n  processCoverHtml,\n  processManuscriptHtml,\n  processTocHtml,\n  ResourceLoader,\n} from './html.js';\nimport { processMarkdown } from './markdown.js';\nimport {\n  checkThemeInstallationNecessity,\n  installThemeDependencies,\n} from './theme.js';\n\nfunction locateThemePath(theme: ParsedTheme, from: string): string | string[] {\n  if (theme.type === 'uri') {\n    return theme.location;\n  }\n  if (theme.type === 'file') {\n    return upath.relative(from, theme.location);\n  }\n  if (theme.importPath) {\n    return [theme.importPath].flat().map((locator) => {\n      const resolvedPath = upath.resolve(theme.location, locator);\n      if (\n        !pathContains(theme.location, resolvedPath) ||\n        !fs.existsSync(resolvedPath)\n      ) {\n        throw new Error(\n          `Could not find a style path ${theme.importPath} for the theme: ${theme.name}.`,\n        );\n      }\n      return upath.relative(from, resolvedPath);\n    });\n  } else {\n    const pkgJsonPath = upath.join(theme.location, 'package.json');\n    const packageJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));\n    const maybeStyle =\n      packageJson?.vivliostyle?.theme?.style ??\n      packageJson.style ??\n      packageJson.main;\n    if (!maybeStyle) {\n      throw new DetailError(\n        `Could not find a style file for the theme: ${theme.name}.`,\n        'Please ensure this package satisfies a `vivliostyle.theme.style` property.',\n      );\n    }\n    return upath.relative(from, upath.join(theme.location, maybeStyle));\n  }\n}\n\nexport async function cleanupWorkspace({\n  entryContextDir,\n  workspaceDir,\n  themesDir,\n  entries,\n}: ResolvedTaskConfig) {\n  if (\n    pathEquals(workspaceDir, entryContextDir) ||\n    pathContains(workspaceDir, entryContextDir) ||\n    entries.some(\n      (entry) =>\n        entry.source?.type === 'file' &&\n        pathContains(workspaceDir, entry.source.pathname),\n    )\n  ) {\n    return;\n  }\n  // workspaceDir is placed on different directory; delete everything excepting theme files\n  Logger.debug('cleanup workspace files', workspaceDir);\n  let movedWorkspacePath: string | undefined;\n  if (pathContains(workspaceDir, themesDir) && fs.existsSync(themesDir)) {\n    movedWorkspacePath = upath.join(\n      upath.dirname(workspaceDir),\n      `.vs-${Date.now()}`,\n    );\n    const movedThemePath = upath.join(\n      movedWorkspacePath,\n      upath.relative(workspaceDir, themesDir),\n    );\n    fs.mkdirSync(upath.dirname(movedThemePath), { recursive: true });\n    registerExitHandler(\n      `Removing the moved workspace directory: ${movedWorkspacePath}`,\n      () => {\n        if (movedWorkspacePath && fs.existsSync(movedWorkspacePath)) {\n          fs.rmSync(movedWorkspacePath, { recursive: true, force: true });\n        }\n      },\n    );\n    await move(themesDir, movedThemePath);\n  }\n  await fs.promises.rm(workspaceDir, { recursive: true, force: true });\n  if (movedWorkspacePath) {\n    await move(movedWorkspacePath, workspaceDir);\n  }\n}\n\nexport async function prepareThemeDirectory({\n  themesDir,\n  themeIndexes,\n}: ResolvedTaskConfig) {\n  // Backward compatibility: v8 to v9\n  if (\n    fs.existsSync(upath.join(themesDir, 'packages')) &&\n    !fs.existsSync(upath.join(themesDir, 'node_modules'))\n  ) {\n    fs.renameSync(\n      upath.join(themesDir, 'packages'),\n      upath.join(themesDir, 'node_modules'),\n    );\n  }\n\n  // install theme packages\n  if (await checkThemeInstallationNecessity({ themesDir, themeIndexes })) {\n    Logger.startLogging('Installing theme files');\n    await installThemeDependencies({ themesDir, themeIndexes });\n  }\n\n  // copy theme files\n  for (const theme of themeIndexes) {\n    if (theme.type === 'file' && !pathEquals(theme.source, theme.location)) {\n      fs.mkdirSync(upath.dirname(theme.location), { recursive: true });\n      await copy(theme.source, theme.location);\n    }\n  }\n}\n\nexport async function transformManuscript(\n  entry: ParsedEntry,\n  {\n    entryContextDir,\n    workspaceDir,\n    viewerInput: { manifestPath },\n    title,\n    entries,\n    language,\n    vfmOptions,\n    rootUrl,\n  }: ResolvedTaskConfig & { viewerInput: WebPublicationManifestConfig },\n): Promise<string | undefined> {\n  const source =\n    entry.rel === 'contents' || entry.rel === 'cover'\n      ? (entry as ContentsEntry | CoverEntry).template\n      : (entry as ManuscriptEntry).source;\n  let content: JSDOM | undefined;\n  let resourceLoader: ResourceLoader | undefined;\n  let resourceUrl: string | undefined;\n\n  // calculate style path\n  const style = entry.themes.flatMap((theme) =>\n    locateThemePath(theme, upath.dirname(entry.target)),\n  );\n\n  if (source?.type === 'file') {\n    if (source.documentProcessor) {\n      // Process with a configured document processor\n      const vfile = await processMarkdown(\n        source.documentProcessor.processorFactory,\n        source.documentProcessor.metadataReader,\n        source.pathname,\n        {\n          ...vfmOptions,\n          style,\n          title: entry.title,\n          language: language ?? undefined,\n        },\n      );\n      content = getJsdomFromString({ html: String(vfile) });\n    } else if (\n      source.contentType === 'text/html' ||\n      source.contentType === 'application/xhtml+xml'\n    ) {\n      content = await getJsdomFromUrlOrFile({ src: source.pathname });\n      content = await processManuscriptHtml(content, {\n        style,\n        title: entry.title,\n        contentType: source.contentType,\n        language,\n      });\n    } else {\n      if (!pathEquals(source.pathname, entry.target)) {\n        await copy(source.pathname, entry.target);\n      }\n    }\n  } else if (source?.type === 'uri') {\n    resourceUrl = /^https?:/.test(source.href)\n      ? source.href\n      : `${rootUrl}${source.href}`;\n    resourceLoader = new ResourceLoader();\n    try {\n      await getJsdomFromUrlOrFile({\n        src: resourceUrl,\n        resourceLoader,\n        virtualConsole: createVirtualConsole((error) => {\n          Logger.logError(`Failed to fetch resources: ${error.detail}`);\n        }),\n      });\n    } catch (error: any) {\n      throw new DetailError(\n        `Failed to fetch the content from ${resourceUrl}`,\n        error.stack ?? error.message,\n      );\n    }\n\n    const contentFetcher = resourceLoader.fetcherMap.get(resourceUrl);\n    if (contentFetcher) {\n      const buffer = await contentFetcher;\n      const contentType = contentFetcher.response?.headers['content-type'];\n      if (!contentType || new MIMEType(contentType).essence !== 'text/html') {\n        throw new Error(`The content is not an HTML document: ${resourceUrl}`);\n      }\n      content = getJsdomFromString({ html: buffer.toString('utf8') });\n      content = await processManuscriptHtml(content, {\n        style,\n        title: entry.title,\n        contentType: 'text/html',\n        language,\n      });\n    }\n  } else if (entry.rel === 'contents') {\n    content = getJsdomFromString({\n      html: generateDefaultTocHtml({\n        language,\n        title,\n      }),\n    });\n    content = await processManuscriptHtml(content, {\n      style,\n      title,\n      contentType: 'text/html',\n      language,\n    });\n  } else if (entry.rel === 'cover') {\n    content = getJsdomFromString({\n      html: generateDefaultCoverHtml({ language, title: entry.title }),\n    });\n    content = await processManuscriptHtml(content, {\n      style,\n      title: entry.title,\n      contentType: 'text/html',\n      language,\n    });\n  }\n\n  if (!content) {\n    return;\n  }\n\n  if (entry.rel === 'contents') {\n    const contentsEntry = entry as ContentsEntry;\n    const manuscriptEntries = entries.filter(\n      (e): e is ManuscriptEntry => 'source' in e,\n    );\n    content = await processTocHtml(content, {\n      entries: manuscriptEntries,\n      manifestPath,\n      distDir: upath.dirname(contentsEntry.target),\n      tocTitle: contentsEntry.tocTitle,\n      sectionDepth: contentsEntry.sectionDepth,\n      styleOptions: contentsEntry,\n      transform: contentsEntry.transform,\n    });\n  }\n\n  if (entry.rel === 'cover') {\n    const coverEntry = entry as CoverEntry;\n    content = await processCoverHtml(content, {\n      imageSrc: upath.relative(\n        upath.join(\n          entryContextDir,\n          upath.relative(workspaceDir, coverEntry.target),\n          '..',\n        ),\n        coverEntry.coverImageSrc,\n      ),\n      imageAlt: coverEntry.coverImageAlt,\n      styleOptions: coverEntry,\n    });\n  }\n\n  let html;\n  if (content.window.document.contentType === 'application/xhtml+xml') {\n    html = `${XML_DECLARATION}\\n${serializeToXml(content.window.document)}`;\n  } else {\n    html = content.serialize();\n  }\n  const htmlBuffer = Buffer.from(html, 'utf8');\n  if (\n    !source ||\n    (source.type === 'file' && !pathEquals(source.pathname, entry.target))\n  ) {\n    writeFileIfChanged(entry.target, htmlBuffer);\n  }\n\n  if (source?.type === 'uri' && resourceLoader && resourceUrl) {\n    const { response } = resourceLoader.fetcherMap.get(resourceUrl)!;\n    const contentFetcher = Promise.resolve(\n      htmlBuffer,\n    ) as jsdom.AbortablePromise<Buffer>;\n    contentFetcher.abort = () => {};\n    contentFetcher.response = response;\n    resourceLoader.fetcherMap.set(resourceUrl, contentFetcher);\n\n    await ResourceLoader.saveFetchedResources({\n      fetcherMap: resourceLoader.fetcherMap,\n      rootUrl: resourceUrl,\n      outputDir: source.rootDir,\n    });\n  }\n\n  return html;\n}\n\nexport async function generateManifest({\n  entryContextDir,\n  workspaceDir,\n  viewerInput: { manifestPath },\n  title,\n  author,\n  entries,\n  language,\n  readingProgression,\n  cover,\n}: ResolvedTaskConfig & { viewerInput: WebPublicationManifestConfig }) {\n  const manifestEntries: ArticleEntryConfig[] = entries.map((entry) => ({\n    title:\n      (entry.rel === 'contents' && (entry as ContentsEntry).tocTitle) ||\n      entry.title,\n    path: upath.relative(workspaceDir, entry.target),\n    encodingFormat:\n      !('contentType' in entry) ||\n      entry.contentType === 'text/markdown' ||\n      entry.contentType === 'text/x-vivliostyle-custom' ||\n      entry.contentType === 'text/html'\n        ? undefined\n        : entry.contentType,\n    rel: entry.rel,\n  }));\n  writePublicationManifest(manifestPath, {\n    title,\n    author,\n    language,\n    readingProgression,\n    cover: cover && {\n      url: upath.relative(entryContextDir, cover.src),\n      name: cover.name,\n    },\n    entries: manifestEntries,\n    modified: new Date().toISOString(),\n  });\n}\n\nexport async function compile(\n  config: ResolvedTaskConfig & { viewerInput: WebPublicationManifestConfig },\n): Promise<void> {\n  const tocEntries: ParsedEntry[] = [];\n  for (const entry of config.entries) {\n    if (entry.rel === 'contents') {\n      // To transpile the table of contents, all dependent entries must be transpiled in advance\n      tocEntries.push(entry);\n      continue;\n    }\n    await transformManuscript(entry, config);\n  }\n  for (const entry of tocEntries) {\n    await transformManuscript(entry, config);\n  }\n\n  // generate manifest\n  if (config.viewerInput.needToGenerateManifest) {\n    await generateManifest(config);\n  }\n}\n","import { copy } from 'fs-extra/esm';\nimport { lookup as mime } from 'mime-types';\nimport fs from 'node:fs';\nimport { pathToFileURL } from 'node:url';\nimport { glob } from 'tinyglobby';\nimport upath from 'upath';\nimport {\n  type EpubOutput,\n  isWebbookConfig,\n  type ResolvedTaskConfig,\n  type WebBookEntryConfig,\n  type WebPublicationOutput,\n} from '../config/resolve.js';\nimport { ArticleEntryConfig } from '../config/schema.js';\nimport { MANIFEST_FILENAME } from '../const.js';\nimport { Logger } from '../logger.js';\nimport {\n  getAssetMatcher,\n  getWebPubResourceMatcher,\n} from '../processor/asset.js';\nimport {\n  createVirtualConsole,\n  fetchLinkedPublicationManifest,\n  getJsdomFromUrlOrFile,\n  ResourceLoader,\n} from '../processor/html.js';\nimport type {\n  PublicationLinks,\n  PublicationManifest,\n  URL as PublicationURL,\n  ResourceCategorization,\n} from '../schema/publication.schema.js';\nimport {\n  assertPubManifestSchema,\n  DetailError,\n  pathEquals,\n  useTmpDirectory,\n} from '../util.js';\nimport { exportEpub } from './epub.js';\n\nfunction sortManifestResources(manifest: PublicationManifest) {\n  if (!Array.isArray(manifest.resources)) {\n    return;\n  }\n  manifest.resources = [...manifest.resources].sort((a, b) =>\n    (typeof a === 'string' ? a : a.url) > (typeof b === 'string' ? b : b.url)\n      ? 1\n      : -1,\n  );\n}\n\nexport async function prepareWebPublicationDirectory({\n  outputDir,\n}: {\n  outputDir: string;\n}): Promise<void> {\n  if (fs.existsSync(outputDir)) {\n    Logger.debug('going to remove existing webpub', outputDir);\n    await fs.promises.rm(outputDir, { force: true, recursive: true });\n  }\n  fs.mkdirSync(outputDir, { recursive: true });\n}\n\nfunction transformPublicationManifest(\n  entity: PublicationManifest,\n  transformer: { url: (str: string) => string },\n): PublicationManifest {\n  const { url: transformUrl } = transformer;\n  const transformUrlOrPublicationLinks = (\n    e: PublicationURL | PublicationLinks,\n  ) => {\n    if (typeof e === 'string') {\n      return transformUrl(e);\n    }\n    const ret = { ...e };\n    ret.url = transformUrl(e.url);\n    return ret;\n  };\n  const ret = { ...entity };\n  for (const [key, tr] of Object.entries({\n    conformsTo: transformUrl,\n    url: transformUrl,\n    readingOrder: transformUrlOrPublicationLinks,\n    resources: transformUrlOrPublicationLinks,\n    links: transformUrlOrPublicationLinks,\n  })) {\n    if (key in ret) {\n      ret[key] = Array.isArray(ret[key])\n        ? ret[key].map(tr)\n        : tr(ret[key] as string);\n    }\n  }\n  return ret;\n}\n\nexport function decodePublicationManifest(input: PublicationManifest) {\n  return transformPublicationManifest(input, {\n    url: decodeURI,\n  });\n}\n\nfunction encodePublicationManifest(input: PublicationManifest) {\n  return transformPublicationManifest(input, {\n    url: encodeURI,\n  });\n}\n\n// https://www.w3.org/TR/pub-manifest/\nexport function writePublicationManifest(\n  output: string,\n  options: {\n    title?: string;\n    author?: string;\n    language?: string;\n    readingProgression?: 'ltr' | 'rtl';\n    modified: string;\n    entries: ArticleEntryConfig[];\n    cover?: {\n      url: string;\n      name: string;\n    };\n    links?: (PublicationURL | PublicationLinks)[];\n    resources?: (PublicationURL | PublicationLinks)[];\n  },\n): PublicationManifest {\n  const entries: PublicationLinks[] = options.entries.map((entry) => ({\n    url: entry.path,\n    ...(entry.title && { name: entry.title }),\n    ...(entry.encodingFormat && { encodingFormat: entry.encodingFormat }),\n    ...(entry.rel && { rel: entry.rel }),\n    ...((entry.rel === 'contents' || entry.rel === 'cover') && {\n      type: 'LinkedResource',\n    }),\n  }));\n  const links: (PublicationURL | PublicationLinks)[] = [\n    options.links || [],\n  ].flat();\n  const resources: (PublicationURL | PublicationLinks)[] = [\n    options.resources || [],\n  ].flat();\n\n  if (options.cover) {\n    const mimeType = mime(options.cover.url);\n    if (mimeType) {\n      resources.push({\n        rel: 'cover',\n        url: options.cover.url,\n        name: options.cover.name,\n        encodingFormat: mimeType,\n      });\n    } else {\n      Logger.logWarn(\n        `Cover image \"${options.cover}\" was set in your configuration but couldnâ€™t detect the image metadata. Please check a valid cover file is placed.`,\n      );\n    }\n  }\n\n  const publication: PublicationManifest = {\n    '@context': ['https://schema.org', 'https://www.w3.org/ns/pub-context'],\n    type: 'Book',\n    conformsTo: 'https://github.com/vivliostyle/vivliostyle-cli',\n    ...(options.title && { name: options.title }),\n    ...(options.author && { author: options.author }),\n    ...(options.language && { inLanguage: options.language }),\n    ...(options.readingProgression && {\n      readingProgression: options.readingProgression,\n    }),\n    dateModified: options.modified,\n    readingOrder: entries,\n    resources,\n    links,\n  };\n\n  const encodedManifest = encodePublicationManifest(publication);\n  Logger.debug(\n    'writePublicationManifest path: %s content: %O',\n    output,\n    encodedManifest,\n  );\n  try {\n    assertPubManifestSchema(encodedManifest);\n  } catch (error) {\n    const thrownError = error as Error | string;\n    throw new DetailError(\n      `Validation of publication manifest failed. Please check the schema: ${output}`,\n      typeof thrownError === 'string'\n        ? thrownError\n        : (thrownError.stack ?? thrownError.message),\n    );\n  }\n  fs.mkdirSync(upath.dirname(output), { recursive: true });\n  fs.writeFileSync(output, JSON.stringify(encodedManifest, null, 2));\n  return publication;\n}\n\nexport async function retrieveWebbookEntry({\n  viewerInput,\n  outputDir,\n}: {\n  viewerInput: WebBookEntryConfig;\n  outputDir: string;\n}): Promise<{\n  entryHtmlFile: string;\n  manifest: PublicationManifest | undefined;\n}> {\n  const webbookEntryUrl = viewerInput.webbookPath\n    ? pathToFileURL(viewerInput.webbookPath).href\n    : viewerInput.webbookEntryUrl;\n  if (/^https?:/i.test(webbookEntryUrl)) {\n    Logger.logUpdate('Fetching remote contents');\n  }\n  const resourceLoader = new ResourceLoader();\n  const dom = await getJsdomFromUrlOrFile({\n    src: webbookEntryUrl,\n    resourceLoader,\n  });\n  const entryHtml = viewerInput.webbookPath\n    ? upath.basename(viewerInput.webbookPath)\n    : decodeURI(dom.window.location.pathname);\n\n  const { manifest, manifestUrl } =\n    (await fetchLinkedPublicationManifest({\n      dom,\n      resourceLoader,\n      baseUrl: webbookEntryUrl,\n    })) || {};\n\n  let pathContains: (url: string) => boolean;\n  if (webbookEntryUrl.startsWith('data:')) {\n    pathContains = (url) => false;\n  } else {\n    const rootUrl = /^https?:/i.test(webbookEntryUrl)\n      ? new URL('/', webbookEntryUrl).href\n      : new URL('.', webbookEntryUrl).href;\n    pathContains = (url: string) =>\n      !upath.relative(rootUrl, url).startsWith('..');\n  }\n  const retriever = new Map(resourceLoader.fetcherMap);\n\n  if (manifest && manifestUrl) {\n    [manifest.resources || []].flat().forEach((v) => {\n      const url = typeof v === 'string' ? v : v.url;\n      const fullUrl = new URL(encodeURI(url), manifestUrl).href;\n      if (!pathContains(fullUrl) || retriever.has(fullUrl)) {\n        return;\n      }\n      const fetchPromise = resourceLoader.fetch(fullUrl);\n      if (fetchPromise && !retriever.has(fullUrl)) {\n        retriever.set(fullUrl, fetchPromise);\n      }\n    });\n    for (const v of [manifest.readingOrder || []].flat()) {\n      const url = typeof v === 'string' ? v : v.url;\n      if (\n        !/\\.html?$/.test(url) &&\n        !(typeof v === 'string' || v.encodingFormat === 'text/html')\n      ) {\n        continue;\n      }\n      const fullUrl = new URL(encodeURI(url), manifestUrl).href;\n      if (!pathContains(fullUrl) || fullUrl === webbookEntryUrl) {\n        continue;\n      }\n      const subpathResourceLoader = new ResourceLoader();\n      await getJsdomFromUrlOrFile({\n        src: fullUrl,\n        resourceLoader: subpathResourceLoader,\n        virtualConsole: createVirtualConsole((error) => {\n          Logger.logError(`Failed to fetch webbook resources: ${error.detail}`);\n        }),\n      });\n      subpathResourceLoader.fetcherMap.forEach(\n        (v, k) => !retriever.has(k) && retriever.set(k, v),\n      );\n    }\n  }\n\n  const fetchedResources = await ResourceLoader.saveFetchedResources({\n    fetcherMap: retriever,\n    rootUrl: webbookEntryUrl,\n    outputDir,\n    /* v8 ignore next 4 */\n    onError: (error) => {\n      Logger.debug(error);\n      Logger.logError(`Failed to fetch webbook resources: ${error}`);\n    },\n  });\n\n  if (manifest) {\n    const referencedContents = [\n      ...[manifest.readingOrder || []].flat(),\n      ...[manifest.resources || []].flat(),\n    ].map((v) => (typeof v === 'string' ? v : v.url));\n    manifest.resources = [\n      ...[manifest.resources || []].flat(),\n      ...fetchedResources.filter(\n        ({ url }) => !referencedContents.includes(url),\n      ),\n    ];\n    sortManifestResources(manifest);\n  }\n\n  Logger.debug(\n    'Saved webbook resources',\n    fetchedResources.map((v) => v.url),\n  );\n  Logger.debug(\n    'Publication manifest from webbook',\n    manifest && JSON.stringify(manifest, null, 2),\n  );\n\n  return {\n    entryHtmlFile: upath.join(\n      outputDir,\n      entryHtml,\n      ...(upath.extname(entryHtml) ? [] : ['index.html']),\n    ),\n    manifest,\n  };\n}\n\nexport async function supplyWebPublicationManifestForWebbook({\n  entryHtmlFile,\n  outputDir,\n  ...config\n}: Pick<\n  ResolvedTaskConfig,\n  'language' | 'title' | 'author' | 'readingProgression'\n> & {\n  entryHtmlFile: string;\n  outputDir: string;\n}): Promise<PublicationManifest> {\n  Logger.debug(`Generating publication manifest from HTML: ${entryHtmlFile}`);\n  const dom = await getJsdomFromUrlOrFile({ src: entryHtmlFile });\n  const { document } = dom.window;\n  const language =\n    config.language || document.documentElement.lang || undefined;\n  const title = config.title || document.title || '';\n  const author =\n    config.author ||\n    document.querySelector('meta[name=\"author\"]')?.getAttribute('content') ||\n    '';\n\n  const entry = upath.relative(outputDir, entryHtmlFile);\n  const allFiles = await glob('**', {\n    cwd: outputDir,\n  });\n\n  const manifest = writePublicationManifest(\n    upath.join(outputDir, MANIFEST_FILENAME),\n    {\n      title,\n      author,\n      language,\n      readingProgression: config.readingProgression,\n      modified: new Date().toISOString(),\n      entries: [{ path: entry }],\n      resources: allFiles.filter((f) => f !== entry),\n    },\n  );\n  sortManifestResources(manifest);\n  const link = document.createElement('link');\n  link.setAttribute('rel', 'publication');\n  link.setAttribute('type', 'application/ld+json');\n  link.setAttribute(\n    'href',\n    upath.relative(\n      upath.dirname(entryHtmlFile),\n      upath.join(outputDir, MANIFEST_FILENAME),\n    ),\n  );\n  document.head.appendChild(link);\n  await fs.promises.writeFile(entryHtmlFile, dom.serialize(), 'utf8');\n\n  Logger.debug(\n    'Generated publication manifest from HTML',\n    JSON.stringify(manifest, null, 2),\n  );\n  return manifest;\n}\n\nexport async function copyWebPublicationAssets({\n  exportAliases,\n  outputs,\n  copyAsset,\n  themesDir,\n  manifestPath,\n  input,\n  outputDir,\n  entries,\n}: Pick<\n  ResolvedTaskConfig,\n  'exportAliases' | 'outputs' | 'copyAsset' | 'themesDir' | 'entries'\n> & {\n  input: string;\n  outputDir: string;\n  manifestPath: string;\n}): Promise<{ manifest: PublicationManifest; actualManifestPath: string }> {\n  const relExportAliases = exportAliases\n    .map(({ source, target }) => ({\n      source: upath.relative(input, source),\n      target: upath.relative(input, target),\n    }))\n    .filter(({ source }) => !source.startsWith('..'));\n  const assetMatcher = getAssetMatcher({\n    copyAsset,\n    cwd: input,\n    outputs,\n    themesDir,\n    entries,\n  });\n  const webResourceMatcher = getWebPubResourceMatcher({\n    cwd: input,\n    outputs,\n    themesDir,\n    entries,\n    manifestPath,\n    copyAsset,\n  });\n  const allFiles = new Set([\n    ...(await assetMatcher.glob()),\n    ...(await webResourceMatcher.glob({\n      // follow symbolic links to copy local theme packages\n      followSymbolicLinks: true,\n    })),\n  ]);\n  // Exclude files that will overwrite alias targets\n  for (const alias of relExportAliases) {\n    allFiles.delete(alias.target);\n  }\n\n  Logger.debug(\n    'webbook files',\n    JSON.stringify(\n      [...allFiles].map((file) => {\n        const alias = relExportAliases.find(({ source }) => source === file);\n        return alias ? `${file} (alias: ${alias.target})` : file;\n      }),\n      null,\n      2,\n    ),\n  );\n  const resources: string[] = [];\n  let actualManifestPath = upath.join(\n    outputDir,\n    upath.relative(input, manifestPath),\n  );\n  for (const file of allFiles) {\n    const alias = relExportAliases.find(({ source }) => source === file);\n    const relTarget = alias?.target || file;\n    resources.push(relTarget);\n    const target = upath.join(outputDir, relTarget);\n    fs.mkdirSync(upath.dirname(target), { recursive: true });\n    await copy(upath.join(input, file), target);\n    if (alias && pathEquals(upath.join(input, alias.source), manifestPath)) {\n      actualManifestPath = target;\n    }\n  }\n\n  Logger.debug('webbook publication.json', actualManifestPath);\n  // Overwrite copied publication.json\n  const manifest = decodePublicationManifest(\n    JSON.parse(fs.readFileSync(actualManifestPath, 'utf8')),\n  );\n  for (const entry of relExportAliases) {\n    const rewriteAliasPath = (e: PublicationLinks | string) => {\n      if (typeof e === 'string') {\n        return pathEquals(e, entry.source) ? entry.source : e;\n      }\n      if (pathEquals(e.url, entry.source)) {\n        e.url = entry.target;\n      }\n      return e;\n    };\n    if (manifest.links) {\n      manifest.links = Array.isArray(manifest.links)\n        ? manifest.links.map(rewriteAliasPath)\n        : rewriteAliasPath(manifest.links);\n    }\n    if (manifest.readingOrder) {\n      manifest.readingOrder = Array.isArray(manifest.readingOrder)\n        ? manifest.readingOrder.map(rewriteAliasPath)\n        : rewriteAliasPath(manifest.readingOrder);\n    }\n    if (manifest.resources) {\n      manifest.resources = Array.isArray(manifest.resources)\n        ? manifest.resources.map(rewriteAliasPath)\n        : rewriteAliasPath(manifest.resources);\n    }\n  }\n\n  // List copied files to resources field\n  const normalizeToUrl = (val?: ResourceCategorization) =>\n    [val || []].flat().map((e) => (typeof e === 'string' ? e : e.url));\n  const preDefinedResources = [\n    ...normalizeToUrl(manifest.links),\n    ...normalizeToUrl(manifest.readingOrder),\n    ...normalizeToUrl(manifest.resources),\n  ];\n  manifest.resources = [\n    ...[manifest.resources || []].flat(),\n    ...resources.flatMap((file) => {\n      if (\n        preDefinedResources.includes(file) ||\n        // Omit publication.json itself\n        pathEquals(file, upath.relative(outputDir, actualManifestPath))\n      ) {\n        return [];\n      }\n      return file;\n    }),\n  ];\n  sortManifestResources(manifest);\n  fs.writeFileSync(\n    actualManifestPath,\n    JSON.stringify(encodePublicationManifest(manifest), null, 2),\n  );\n  return { manifest, actualManifestPath };\n}\n\nexport async function buildWebPublication({\n  target,\n  config,\n}: {\n  target: WebPublicationOutput | EpubOutput;\n  config: ResolvedTaskConfig;\n}): Promise<string> {\n  let outputDir: string;\n  if (target.format === 'webpub') {\n    outputDir = target.path;\n    await prepareWebPublicationDirectory({ outputDir });\n  } else {\n    [outputDir] = await useTmpDirectory();\n  }\n\n  let entryHtmlFile: string | undefined;\n  let manifest: PublicationManifest;\n  let actualManifestPath: string | undefined;\n  if (config.viewerInput.type === 'webpub') {\n    const ret = await copyWebPublicationAssets({\n      ...config,\n      input: config.workspaceDir,\n      outputDir,\n      manifestPath: config.viewerInput.manifestPath,\n    });\n    manifest = ret.manifest;\n    actualManifestPath = ret.actualManifestPath;\n    if (config.input.format === 'markdown') {\n      const entry = [manifest.readingOrder].flat()[0];\n      if (entry) {\n        entryHtmlFile = upath.join(\n          outputDir,\n          typeof entry === 'string' ? entry : entry.url,\n        );\n      }\n    }\n  } else if (isWebbookConfig(config)) {\n    const ret = await retrieveWebbookEntry({\n      viewerInput: config.viewerInput,\n      outputDir,\n    });\n    entryHtmlFile = ret.entryHtmlFile;\n    manifest =\n      ret.manifest ||\n      (await supplyWebPublicationManifestForWebbook({\n        ...config,\n        entryHtmlFile: ret.entryHtmlFile,\n        outputDir,\n      }));\n  } else {\n    throw new Error('No entry specified');\n  }\n\n  if (target.format === 'epub') {\n    await exportEpub({\n      webpubDir: outputDir,\n      entryHtmlFile,\n      manifest,\n      relManifestPath:\n        actualManifestPath && upath.relative(outputDir, actualManifestPath),\n      target: target.path,\n      epubVersion: target.version,\n    });\n  }\n  return target.path;\n}\n","import jsdom, {\n  type AbortablePromise,\n  ResourceLoader as BaseResourceLoader,\n  JSDOM,\n  VirtualConsole,\n} from '@vivliostyle/jsdom';\nimport DOMPurify, { type WindowLike } from 'dompurify';\nimport { toHtml } from 'hast-util-to-html';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport upath from 'upath';\nimport MIMEType from 'whatwg-mimetype';\nimport type { ManuscriptEntry } from '../config/resolve.js';\nimport type {\n  StructuredDocument,\n  StructuredDocumentSection,\n} from '../config/schema.js';\nimport { Logger } from '../logger.js';\nimport { decodePublicationManifest } from '../output/webbook.js';\nimport type { PublicationManifest } from '../schema/publication.schema.js';\nimport {\n  DetailError,\n  assertPubManifestSchema,\n  isValidUri,\n  writeFileIfChanged,\n} from '../util.js';\n\nexport const createVirtualConsole = (onError: (error: DetailError) => void) => {\n  const virtualConsole = new jsdom.VirtualConsole();\n  /* v8 ignore start */\n  virtualConsole.on('error', (message) => {\n    Logger.debug('[JSDOM Console] error:', message);\n  });\n  virtualConsole.on('warn', (message) => {\n    Logger.debug('[JSDOM Console] warn:', message);\n  });\n  virtualConsole.on('log', (message) => {\n    Logger.debug('[JSDOM Console] log:', message);\n  });\n  virtualConsole.on('info', (message) => {\n    Logger.debug('[JSDOM Console] info:', message);\n  });\n  virtualConsole.on('dir', (message) => {\n    Logger.debug('[JSDOM Console] dir:', message);\n  });\n  virtualConsole.on('jsdomError', (error) => {\n    // Most of CSS using Paged media will be failed to run CSS parser of JSDOM.\n    // We just ignore it because we don't use CSS parse results.\n    // https://github.com/jsdom/jsdom/blob/a39e0ec4ce9a8806692d986a7ed0cd565ec7498a/lib/jsdom/living/helpers/stylesheets.js#L33-L44\n    // see also: https://github.com/jsdom/jsdom/issues/2005\n    if (error.message === 'Could not parse CSS stylesheet') {\n      return;\n    }\n    onError(\n      new DetailError(\n        'Error occurred when loading content',\n        error.stack ?? error.message,\n      ),\n    );\n  });\n  /* v8 ignore stop */\n  return virtualConsole;\n};\n\nexport const htmlPurify = DOMPurify(\n  // @ts-expect-error: jsdom.DOMWindow should have trustedTypes property\n  new JSDOM('').window as WindowLike,\n);\n\nexport class ResourceLoader extends BaseResourceLoader {\n  static dataUrlOrigin = 'http://localhost/' as const;\n\n  fetcherMap = new Map<string, jsdom.AbortablePromise<Buffer>>();\n\n  fetch(url: string, options?: jsdom.FetchOptions) {\n    Logger.debug(`[JSDOM] Fetching resource: ${url}`);\n    const fetcher = super.fetch(url, options);\n    if (fetcher) {\n      this.fetcherMap.set(url, fetcher);\n    }\n    return fetcher;\n  }\n\n  static async saveFetchedResources({\n    fetcherMap,\n    rootUrl,\n    outputDir,\n    onError,\n  }: {\n    fetcherMap: Map<string, jsdom.AbortablePromise<Buffer>>;\n    rootUrl: string;\n    outputDir: string;\n    onError?: (error: Error) => void;\n  }) {\n    const rootHref = rootUrl.startsWith('data:')\n      ? ResourceLoader.dataUrlOrigin\n      : /^https?:/i.test(rootUrl)\n        ? new URL('/', rootUrl).href\n        : new URL('.', rootUrl).href;\n\n    const normalizeToLocalPath = (urlString: string, mimeType?: string) => {\n      let url = new URL(urlString);\n      url.hash = '';\n      if (mimeType === 'text/html' && !/\\.html?$/.test(url.pathname)) {\n        url.pathname = `${url.pathname.replace(/\\/$/, '')}/index.html`;\n      }\n      let relTarget = upath.relative(rootHref, url.href);\n      return decodeURI(relTarget);\n    };\n\n    const fetchedResources: { url: string; encodingFormat?: string }[] = [];\n    await Promise.allSettled(\n      [...fetcherMap.entries()].flatMap(async ([url, fetcher]) => {\n        if (!url.startsWith(rootHref)) {\n          return [];\n        }\n        return (\n          fetcher\n            .then(async (buffer) => {\n              let encodingFormat: string | undefined;\n              try {\n                const contentType = fetcher.response?.headers['content-type'];\n                if (contentType) {\n                  encodingFormat = new MIMEType(contentType).essence;\n                }\n                /* v8 ignore next 3 */\n              } catch (e) {\n                /* NOOP */\n              }\n              const relTarget = normalizeToLocalPath(url, encodingFormat);\n              const target = upath.join(outputDir, relTarget);\n              fetchedResources.push({ url: relTarget, encodingFormat });\n              writeFileIfChanged(target, buffer);\n            })\n            /* v8 ignore next */\n            .catch(onError)\n        );\n      }),\n    );\n    return fetchedResources;\n  }\n}\n\nexport async function getJsdomFromUrlOrFile({\n  src,\n  resourceLoader,\n  virtualConsole = createVirtualConsole((error) => {\n    throw error;\n  }),\n}: {\n  src: string;\n  resourceLoader?: ResourceLoader;\n  virtualConsole?: VirtualConsole;\n}) {\n  const url = isValidUri(src) ? new URL(src) : pathToFileURL(src);\n  let dom: JSDOM;\n  if (url.protocol === 'http:' || url.protocol === 'https:') {\n    dom = await JSDOM.fromURL(src, {\n      virtualConsole,\n      resources: resourceLoader,\n    });\n  } else if (url.protocol === 'file:') {\n    if (resourceLoader) {\n      const file = resourceLoader._readFile(fileURLToPath(url));\n      resourceLoader.fetcherMap.set(url.href, file);\n    }\n    dom = await JSDOM.fromFile(fileURLToPath(url), {\n      virtualConsole,\n      resources: resourceLoader,\n      contentType:\n        src.endsWith('.xhtml') || src.endsWith('.xml')\n          ? 'application/xhtml+xml; charset=UTF-8'\n          : 'text/html; charset=UTF-8',\n    });\n  } else if (url.protocol === 'data:') {\n    const [head, body] = url.href.split(',', 2);\n    const data = decodeURIComponent(body);\n    const buffer = Buffer.from(\n      data,\n      /;base64$/i.test(head) ? 'base64' : 'utf8',\n    );\n    const dummyUrl = `${ResourceLoader.dataUrlOrigin}index.html`;\n    if (resourceLoader) {\n      let timeoutId: ReturnType<typeof setTimeout>;\n      const promise = new Promise((resolve) => {\n        timeoutId = setTimeout(resolve, 0, buffer);\n      }) as AbortablePromise<Buffer>;\n      promise.abort = () => {\n        if (timeoutId !== undefined) {\n          clearTimeout(timeoutId);\n        }\n      };\n      resourceLoader.fetcherMap.set(dummyUrl, promise);\n    }\n    dom = new JSDOM(buffer.toString(), {\n      virtualConsole,\n      resources: resourceLoader,\n      contentType: 'text/html; charset=UTF-8',\n      url: dummyUrl,\n    });\n  } else {\n    throw new Error(`Unsupported protocol: ${url.protocol}`);\n  }\n  return dom;\n}\n\nexport function getJsdomFromString({\n  html,\n  virtualConsole = createVirtualConsole((error) => {\n    throw error;\n  }),\n}: {\n  html: string;\n  virtualConsole?: VirtualConsole;\n}) {\n  return new JSDOM(html, {\n    virtualConsole,\n  });\n}\n\nexport async function getStructuredSectionFromHtml(\n  htmlPath: string,\n  href?: string,\n) {\n  const dom = await getJsdomFromUrlOrFile({ src: htmlPath });\n  const { document } = dom.window;\n  const allHeadings = [...document.querySelectorAll('h1, h2, h3, h4, h5, h6')]\n    .filter((el) => {\n      // Exclude headings contained by blockquote\n      // TODO: Make customizable\n      return !el.matches('blockquote *');\n    })\n    .sort((a, b) => {\n      const position = a.compareDocumentPosition(b);\n      return position & 2 /* DOCUMENT_POSITION_PRECEDING */\n        ? 1\n        : position & 4 /* DOCUMENT_POSITION_FOLLOWING */\n          ? -1\n          : 0;\n    });\n\n  function traverse(headers: Element[]): StructuredDocumentSection[] {\n    if (headers.length === 0) {\n      return [];\n    }\n    const [head, ...tail] = headers;\n    const section = head.parentElement!;\n    const id = head.id || section.id;\n    const level = Number(head.tagName.slice(1));\n    let i = tail.findIndex((s) => Number(s.tagName.slice(1)) <= level);\n    i = i === -1 ? tail.length : i;\n    return [\n      {\n        headingHtml: htmlPurify.sanitize(head.innerHTML),\n        headingText: head.textContent?.trim().replace(/\\s+/g, ' ') || '',\n        level,\n        ...(href && id && { href: `${href}#${encodeURIComponent(id)}` }),\n        ...(id && { id }),\n        children: traverse(tail.slice(0, i)),\n      },\n      ...traverse(tail.slice(i)),\n    ];\n  }\n  return traverse(allHeadings);\n}\n\nconst getTocHtmlStyle = ({\n  pageBreakBefore,\n  pageCounterReset,\n}: {\n  pageBreakBefore?: 'recto' | 'verso' | 'left' | 'right';\n  pageCounterReset?: number;\n}) => {\n  if (!pageBreakBefore && typeof pageCounterReset !== 'number') {\n    return null;\n  }\n  return /* css */ `\n${\n  pageBreakBefore\n    ? /* css */ `:root {\n  break-before: ${pageBreakBefore};\n}`\n    : ''\n}\n${\n  // Note: `--vs-document-first-page-counter-reset` is reserved variable name in Vivliostyle base themes\n  typeof pageCounterReset === 'number'\n    ? /* css */ `@page :nth(1) {\n  --vs-document-first-page-counter-reset: page ${Math.floor(pageCounterReset - 1)};\n  counter-reset: var(--vs-document-first-page-counter-reset);\n}`\n    : ''\n}\n`;\n};\n\ntype HastElement = import('hast').ElementContent | import('hast').Root;\n\nexport const defaultTocTransform = {\n  transformDocumentList:\n    (nodeList: StructuredDocument[]) =>\n    (propsList: { children: HastElement | HastElement[] }[]): HastElement => {\n      return (\n        <ol>\n          {nodeList\n            .map((a, i) => [a, propsList[i]] as const)\n            .flatMap(\n              ([{ href, title, sections }, { children, ...otherProps }]) => {\n                // don't display the document title if it has only one top-level H1 heading\n                if (sections?.length === 1 && sections[0].level === 1) {\n                  return [children].flat().flatMap((e) => {\n                    if (e.type === 'element' && e.tagName === 'ol') {\n                      return e.children;\n                    }\n                    return e;\n                  });\n                }\n                return (\n                  <li {...otherProps}>\n                    <a {...{ href }}>{title}</a>\n                    {children}\n                  </li>\n                );\n              },\n            )}\n        </ol>\n      );\n    },\n  transformSectionList:\n    (nodeList: StructuredDocumentSection[]) =>\n    (propsList: { children: HastElement | HastElement[] }[]): HastElement => {\n      return (\n        <ol>\n          {nodeList\n            .map((a, i) => [a, propsList[i]] as const)\n            .map(\n              ([{ headingHtml, href, level }, { children, ...otherProps }]) => {\n                const headingContent = {\n                  type: 'raw',\n                  value: headingHtml,\n                };\n                return (\n                  <li {...otherProps} data-section-level={level}>\n                    {href ? (\n                      <a {...{ href }}>{headingContent}</a>\n                    ) : (\n                      <span>{headingContent}</span>\n                    )}\n                    {children}\n                  </li>\n                );\n              },\n            )}\n        </ol>\n      );\n    },\n};\n\nexport function generateDefaultTocHtml({\n  language,\n  title,\n}: {\n  language?: string;\n  title?: string;\n}) {\n  const toc = (\n    <html lang={language}>\n      <head>\n        <meta charset=\"utf-8\" />\n        <title>{title || ''}</title>\n        <style data-vv-style></style>\n      </head>\n      <body>\n        <h1>{title || ''}</h1>\n        <nav id=\"toc\" role=\"doc-toc\" />\n      </body>\n    </html>\n  );\n  return toHtml(toc);\n}\n\nexport async function generateTocListSection({\n  entries,\n  distDir,\n  sectionDepth,\n  transform = {},\n}: {\n  entries: Pick<ManuscriptEntry, 'target' | 'title'>[];\n  distDir: string;\n  sectionDepth: number;\n  transform?: Partial<typeof defaultTocTransform>;\n}): Promise<string> {\n  const {\n    transformDocumentList = defaultTocTransform.transformDocumentList,\n    transformSectionList = defaultTocTransform.transformSectionList,\n  } = transform;\n\n  const structure = await Promise.all(\n    entries.map(async (entry) => {\n      const href = encodeURI(upath.relative(distDir, entry.target));\n      const sections =\n        sectionDepth >= 1\n          ? await getStructuredSectionFromHtml(entry.target, href)\n          : [];\n      return {\n        title: entry.title || upath.basename(entry.target, '.html'),\n        href: encodeURI(upath.relative(distDir, entry.target)),\n        sections,\n        children: [], // TODO\n      };\n    }),\n  );\n  const docToc = transformDocumentList(structure)(\n    structure.map((doc) => {\n      function renderSectionList(\n        sections: StructuredDocumentSection[],\n      ): HastElement | HastElement[] {\n        const nodeList = sections.flatMap((section) => {\n          if (section.level > sectionDepth) {\n            return [];\n          }\n          return section;\n        });\n        if (nodeList.length === 0) {\n          return [];\n        }\n        return transformSectionList(nodeList)(\n          nodeList.map((node) => ({\n            children: [renderSectionList(node.children || [])].flat(),\n          })),\n        );\n      }\n      return {\n        children: [renderSectionList(doc.sections || [])].flat(),\n      };\n    }),\n  );\n\n  return toHtml(docToc, { allowDangerousHtml: true });\n}\n\nexport async function processTocHtml(\n  dom: JSDOM,\n  {\n    manifestPath,\n    tocTitle,\n    styleOptions = {},\n    entries,\n    distDir,\n    sectionDepth,\n    transform,\n  }: Parameters<typeof generateTocListSection>[0] & {\n    manifestPath: string;\n    tocTitle: string;\n    styleOptions?: Parameters<typeof getTocHtmlStyle>[0];\n  },\n): Promise<JSDOM> {\n  const { document } = dom.window;\n  if (\n    !document.querySelector(\n      'link[rel=\"publication\"][type=\"application/ld+json\"]',\n    )\n  ) {\n    const l = document.createElement('link');\n    l.setAttribute('rel', 'publication');\n    l.setAttribute('type', 'application/ld+json');\n    l.setAttribute('href', encodeURI(upath.relative(distDir, manifestPath)));\n    document.head.appendChild(l);\n  }\n\n  const style = document.querySelector('style[data-vv-style]');\n  if (style) {\n    const textContent = getTocHtmlStyle(styleOptions);\n    if (textContent) {\n      style.textContent = textContent;\n    } else {\n      style.remove();\n    }\n  }\n\n  const nav = document.querySelector('nav, [role=\"doc-toc\"]');\n  if (nav && !nav.hasChildNodes()) {\n    const h2 = document.createElement('h2');\n    h2.textContent = tocTitle;\n    nav.appendChild(h2);\n    nav.innerHTML += await generateTocListSection({\n      entries,\n      distDir,\n      sectionDepth,\n      transform,\n    });\n  }\n  return dom;\n}\n\nconst getCoverHtmlStyle = ({\n  pageBreakBefore,\n}: {\n  pageBreakBefore?: 'recto' | 'verso' | 'left' | 'right';\n}) => /* css */ `\n${\n  pageBreakBefore\n    ? `:root {\n  break-before: ${pageBreakBefore};\n}`\n    : ''\n}\nbody {\n  margin: 0;\n}\n[role=\"doc-cover\"] {\n  display: block;\n  width: 100vw;\n  height: 100vh;\n  object-fit: contain;\n}\n@page {\n  margin: 0;\n}\n`;\n\nexport function generateDefaultCoverHtml({\n  language,\n  title,\n}: {\n  language?: string;\n  title?: string;\n}) {\n  const toc = (\n    <html lang={language}>\n      <head>\n        <meta charset=\"utf-8\" />\n        <title>{title || ''}</title>\n        <style data-vv-style></style>\n      </head>\n      <body>\n        <section role=\"region\" aria-label=\"Cover\">\n          <img role=\"doc-cover\" />\n        </section>\n      </body>\n    </html>\n  );\n  return toHtml(toc);\n}\n\nexport async function processCoverHtml(\n  dom: JSDOM,\n  {\n    imageSrc,\n    imageAlt,\n    styleOptions = {},\n  }: {\n    imageSrc: string;\n    imageAlt: string;\n    styleOptions?: Parameters<typeof getCoverHtmlStyle>[0];\n  },\n): Promise<JSDOM> {\n  const { document } = dom.window;\n  const style = document.querySelector('style[data-vv-style]');\n  if (style) {\n    const textContent = getCoverHtmlStyle(styleOptions);\n    if (textContent) {\n      style.textContent = textContent;\n    } else {\n      style.remove();\n    }\n  }\n\n  const cover = document.querySelector('img[role=\"doc-cover\"]');\n  if (cover && !cover.hasAttribute('src')) {\n    cover.setAttribute('src', encodeURI(imageSrc));\n  }\n  if (cover && !cover.hasAttribute('alt')) {\n    cover.setAttribute('alt', imageAlt);\n  }\n  return dom;\n}\n\nexport async function processManuscriptHtml(\n  dom: JSDOM,\n  {\n    title,\n    style,\n    contentType,\n    language,\n  }: {\n    title?: string;\n    style?: string[];\n    contentType?: 'text/html' | 'application/xhtml+xml';\n    language?: string | null;\n  },\n): Promise<JSDOM> {\n  const { document } = dom.window;\n  if (title) {\n    if (!document.querySelector('title')) {\n      const t = document.createElement('title');\n      document.head.appendChild(t);\n    }\n    document.title = title;\n  }\n  for (const s of style ?? []) {\n    const l = document.createElement('link');\n    l.setAttribute('rel', 'stylesheet');\n    l.setAttribute('type', 'text/css');\n    l.setAttribute('href', encodeURI(s));\n    document.head.appendChild(l);\n  }\n  if (language) {\n    if (contentType === 'application/xhtml+xml') {\n      if (!document.documentElement.getAttribute('xml:lang')) {\n        document.documentElement.setAttribute('lang', language);\n        document.documentElement.setAttribute('xml:lang', language);\n      }\n    } else {\n      if (!document.documentElement.getAttribute('lang')) {\n        document.documentElement.setAttribute('lang', language);\n      }\n    }\n  }\n  return dom;\n}\n\nexport async function fetchLinkedPublicationManifest({\n  dom,\n  resourceLoader,\n  baseUrl,\n}: {\n  dom: JSDOM;\n  resourceLoader: ResourceLoader;\n  baseUrl: string;\n}): Promise<{ manifest: PublicationManifest; manifestUrl: string } | null> {\n  const { document } = dom.window;\n\n  const linkEl = document.querySelector('link[href][rel=\"publication\"]');\n  if (!linkEl) {\n    return null;\n  }\n  const href = linkEl.getAttribute('href')!.trim();\n  let manifest: PublicationManifest;\n  let manifestUrl = baseUrl;\n  if (href.startsWith('#')) {\n    const scriptEl = document.getElementById(href.slice(1));\n    if (scriptEl?.getAttribute('type') !== 'application/ld+json') {\n      return null;\n    }\n    Logger.debug(`Found embedded publication manifest: ${href}`);\n    try {\n      manifest = JSON.parse(scriptEl.innerHTML);\n    } catch (error) {\n      const thrownError = error as Error;\n      throw new DetailError(\n        'Failed to parse manifest data',\n        typeof thrownError.stack,\n      );\n    }\n  } else {\n    Logger.debug(`Found linked publication manifest: ${href}`);\n    const url = new URL(href, baseUrl);\n    manifestUrl = url.href;\n    const buffer = await resourceLoader.fetch(url.href);\n    if (!buffer) {\n      throw new Error(`Failed to fetch manifest JSON file: ${url.href}`);\n    }\n    const manifestJson = buffer.toString();\n    try {\n      manifest = JSON.parse(manifestJson);\n    } catch (error) {\n      const thrownError = error as Error;\n      throw new DetailError(\n        'Failed to parse manifest data',\n        typeof thrownError.stack,\n      );\n    }\n  }\n\n  try {\n    assertPubManifestSchema(manifest);\n  } catch (error) {\n    Logger.logWarn(\n      `Publication manifest validation failed. Processing continues, but some problems may occur.\\n${error}`,\n    );\n  }\n  return {\n    manifest: decodePublicationManifest(manifest),\n    manifestUrl,\n  };\n}\n\nexport type TocResourceTreeItem = {\n  element: HTMLElement;\n  label: HTMLElement;\n  children?: TocResourceTreeItem[];\n};\nexport type TocResourceTreeRoot = {\n  element: HTMLElement;\n  heading?: HTMLElement;\n  children: TocResourceTreeItem[];\n};\n\nexport function parseTocDocument(dom: JSDOM): TocResourceTreeRoot | null {\n  const { document } = dom.window;\n\n  const docTocEl = document.querySelectorAll('[role=\"doc-toc\"]');\n  if (docTocEl.length === 0) {\n    return null;\n  }\n  const tocRoot = docTocEl.item(0);\n\n  const parseTocItem = (element: Element): TocResourceTreeItem | null => {\n    if (element.tagName !== 'LI') {\n      return null;\n    }\n    const label = element.children.item(0);\n    const ol = element.children.item(1);\n    if (!label || (label.tagName !== 'A' && label.tagName !== 'SPAN')) {\n      return null;\n    }\n    if (!ol || ol.tagName !== 'OL') {\n      return { element: element as HTMLElement, label: label as HTMLElement };\n    }\n    const children = Array.from(ol.children).reduce<\n      TocResourceTreeItem[] | null\n    >((acc, val) => {\n      if (!acc) {\n        return acc;\n      }\n      const res = parseTocItem(val);\n      return res && [...acc, res];\n    }, []);\n    return (\n      children && {\n        element: element as HTMLElement,\n        label: label as HTMLElement,\n        children,\n      }\n    );\n  };\n\n  let heading: HTMLElement | undefined;\n  for (let child of Array.from(tocRoot.children)) {\n    if (child.tagName === 'OL') {\n      const children = Array.from(child.children).reduce<\n        TocResourceTreeItem[] | null\n      >((acc, val) => {\n        if (!acc) {\n          return acc;\n        }\n        const res = parseTocItem(val);\n        return res && [...acc, res];\n      }, []);\n      return children && { element: tocRoot as HTMLElement, heading, children };\n    } else if (\n      ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HGROUP'].includes(child.tagName)\n    ) {\n      heading = child as HTMLElement;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\nexport type PageListResourceTreeItem = {\n  element: HTMLElement;\n};\nexport type PageListResourceTreeRoot = {\n  element: HTMLElement;\n  heading?: HTMLElement;\n  children: PageListResourceTreeItem[];\n};\n\nexport function parsePageListDocument(\n  dom: JSDOM,\n): PageListResourceTreeRoot | null {\n  const { document } = dom.window;\n\n  const docPageListEl = document.querySelectorAll('[role=\"doc-pagelist\"]');\n  if (docPageListEl.length === 0) {\n    return null;\n  }\n  const pageListRoot = docPageListEl.item(0);\n\n  let heading: HTMLElement | undefined;\n  for (let child of Array.from(pageListRoot.children)) {\n    if (child.tagName === 'OL') {\n      const children = Array.from(child.children).reduce<\n        PageListResourceTreeItem[] | null\n      >((acc, element) => {\n        return (\n          acc &&\n          (element.tagName === 'LI'\n            ? [...acc, { element: element as HTMLElement }]\n            : null)\n        );\n      }, []);\n      return (\n        children && { element: pageListRoot as HTMLElement, heading, children }\n      );\n    } else if (\n      ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HGROUP'].includes(child.tagName)\n    ) {\n      heading = child as HTMLElement;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n","import type { JSDOM } from '@vivliostyle/jsdom';\nimport archiver from 'archiver';\nimport { lookup as lookupLanguage } from 'bcp-47-match';\nimport { XMLBuilder } from 'fast-xml-parser';\nimport { copy } from 'fs-extra/esm';\nimport GithubSlugger from 'github-slugger';\nimport { lookup as mime } from 'mime-types';\nimport fs from 'node:fs';\nimport { pathToFileURL } from 'node:url';\nimport upath from 'upath';\nimport { v4 as uuid } from 'uuid';\nimport serializeToXml from 'w3c-xmlserializer';\nimport {\n  EPUB_CONTAINER_XML,\n  EPUB_LANDMARKS_COVER_ENTRY,\n  EPUB_LANDMARKS_TITLE,\n  EPUB_LANDMARKS_TOC_ENTRY,\n  EPUB_NS,\n  TOC_TITLE,\n  XML_DECLARATION,\n} from '../const.js';\nimport { Logger } from '../logger.js';\nimport {\n  type PageListResourceTreeRoot,\n  type TocResourceTreeRoot,\n  getJsdomFromUrlOrFile,\n  parsePageListDocument,\n  parseTocDocument,\n} from '../processor/html.js';\nimport type {\n  Contributor,\n  LocalizableStringObject,\n  LocalizableStringOrObject,\n  PublicationLinks,\n  PublicationManifest,\n  ResourceCategorization,\n} from '../schema/publication.schema.js';\nimport { DetailError, useTmpDirectory } from '../util.js';\n\ninterface ManifestEntry {\n  href: string;\n  mediaType: string;\n  properties?: string;\n}\n\ninterface LandmarkEntry {\n  type: string;\n  href: string;\n  text: string;\n}\n\ninterface SpineEntry {\n  href: string;\n}\n\nconst TOC_ID = 'toc';\nconst LANDMARKS_ID = 'landmarks';\nconst PAGELIST_ID = 'page-list';\nconst COVER_IMAGE_MIMETYPES = [\n  'image/gif',\n  'image/jpeg',\n  'image/png',\n  'image/svg+xml',\n  'image/webp',\n];\n\nconst changeExtname = (filepath: string, newExt: string) => {\n  let ext = upath.extname(filepath);\n  return `${filepath.slice(0, -ext.length)}${newExt}`;\n};\n\nconst getRelativeHref = (target: string, baseUrl: string, rootUrl: string) => {\n  const absBasePath = upath.join('/', baseUrl);\n  const absRootPath = upath.join('/', rootUrl);\n  const hrefUrl = new URL(encodeURI(target), pathToFileURL(absBasePath));\n  if (hrefUrl.protocol !== 'file:') {\n    return target;\n  }\n  if (/\\.html?$/.test(hrefUrl.pathname)) {\n    hrefUrl.pathname = changeExtname(hrefUrl.pathname, '.xhtml');\n  }\n  const pathname = upath.posix.relative(\n    pathToFileURL(upath.dirname(absRootPath)).pathname,\n    hrefUrl.pathname,\n  );\n  return `${pathname}${hrefUrl.search}${hrefUrl.hash}`;\n};\n\nconst normalizeLocalizableString = (\n  value: LocalizableStringOrObject | undefined,\n  availableLanguages: string[],\n): string | undefined => {\n  if (!value) {\n    return;\n  }\n  const values = [value]\n    .flat()\n    .map((value) => (typeof value === 'string' ? { value } : value));\n  const localizedValues = values.filter(\n    (v): v is LocalizableStringObject & { language: string } => !!v.language,\n  );\n  const preferredLang = lookupLanguage(\n    localizedValues.map((v) => v.language),\n    availableLanguages,\n  );\n  if (preferredLang) {\n    return localizedValues[\n      localizedValues.findIndex((v) => v.language === preferredLang)\n    ].value;\n  }\n  return values.find((v) => !v.language)?.value;\n};\n\nconst appendManifestProperty = (entry: ManifestEntry, newProperty: string) => {\n  entry.properties = entry.properties\n    ? Array.from(new Set([...entry.properties.split(' '), newProperty])).join(\n        ' ',\n      )\n    : newProperty;\n};\n\nexport async function exportEpub({\n  webpubDir,\n  entryHtmlFile,\n  manifest,\n  relManifestPath,\n  target,\n  epubVersion,\n}: {\n  webpubDir: string;\n  entryHtmlFile?: string;\n  manifest: PublicationManifest;\n  relManifestPath?: string;\n  target: string;\n  epubVersion: '3.0';\n}) {\n  Logger.debug('Export EPUB', {\n    webpubDir,\n    entryHtmlFile,\n    relManifestPath,\n    target,\n    epubVersion,\n  });\n\n  const [tmpDir] = await useTmpDirectory();\n  fs.mkdirSync(upath.join(tmpDir, 'META-INF'), { recursive: true });\n  await copy(webpubDir, upath.join(tmpDir, 'EPUB'));\n\n  const uid = `urn:uuid:${uuid()}`;\n  const entryHtmlRelPath =\n    entryHtmlFile &&\n    upath.relative(webpubDir, upath.resolve(webpubDir, entryHtmlFile));\n\n  const findPublicationLink = (\n    relType: string,\n    list?: ResourceCategorization,\n    filter?: (e: PublicationLinks) => boolean,\n  ) =>\n    [list]\n      .flat()\n      .find(\n        (e): e is PublicationLinks =>\n          typeof e === 'object' && e.rel === relType && (!filter || filter(e)),\n      );\n  const tocResource = findPublicationLink('contents', [\n    ...[manifest.readingOrder || []].flat(),\n    ...[manifest.resources || []].flat(),\n  ]);\n  const pageListResource = findPublicationLink('pagelist', [\n    ...[manifest.readingOrder || []].flat(),\n    ...[manifest.resources || []].flat(),\n  ]);\n  // NOTE: EPUB allows one cover-image item unlike web publication\n  // vivliostyle-cli takes the first cover resource.\n  const pictureCoverResource = findPublicationLink(\n    'cover',\n    manifest.resources,\n    (e) =>\n      COVER_IMAGE_MIMETYPES.includes(e.encodingFormat || mime(e.url) || ''),\n  );\n  const htmlCoverResource = findPublicationLink(\n    'cover',\n    [\n      ...[manifest.readingOrder || []].flat(),\n      ...[manifest.resources || []].flat(),\n    ],\n    (e) => /\\.html?$/.test(e.url),\n  );\n\n  const manifestItem = [\n    ...[manifest.links || []].flat(),\n    ...[manifest.readingOrder || []].flat(),\n    ...[manifest.resources || []].flat(),\n  ].reduce(\n    (acc, val) => {\n      const { url, encodingFormat } =\n        typeof val === 'string' ? ({ url: val } as PublicationLinks) : val;\n      // Only accepts path-like url\n      try {\n        new URL(url);\n        return acc;\n      } catch (e) {\n        /* NOOP */\n      }\n      if (!fs.existsSync(upath.join(tmpDir, 'EPUB', url))) {\n        return acc;\n      }\n      const mediaType = encodingFormat || mime(url) || 'text/plain';\n      acc[url] = {\n        href: url,\n        mediaType,\n      };\n      if (/\\.html?$/.test(url)) {\n        acc[url].href = changeExtname(url, '.xhtml');\n        acc[url].mediaType = 'application/xhtml+xml';\n      }\n      if (url === pictureCoverResource?.url) {\n        acc[url].properties = 'cover-image';\n      }\n      return acc;\n    },\n    {} as Record<string, ManifestEntry>,\n  );\n\n  const htmlFiles = Object.keys(manifestItem).filter((url) =>\n    /\\.html?$/.test(url),\n  );\n  let tocHtml = htmlFiles.find((f) => f === tocResource?.url);\n  const readingOrder = [manifest.readingOrder || entryHtmlRelPath]\n    .flat()\n    .flatMap((v) => (v ? (typeof v === 'string' ? { url: v } : v) : []));\n  if (!tocHtml) {\n    Logger.logWarn(\n      'No table of contents document was found. for EPUB output, we recommend to enable `toc` option in your Vivliostyle config file to generate a table of contents document.',\n    );\n    tocHtml =\n      htmlFiles.find((f) => f === entryHtmlRelPath) || readingOrder[0].url;\n  }\n  const spineItems = readingOrder.map<SpineEntry>(({ url }) => ({\n    href: changeExtname(url, '.xhtml'),\n  }));\n  if (!(tocHtml in manifestItem)) {\n    manifestItem[tocHtml] = {\n      href: changeExtname(tocHtml, '.xhtml'),\n      mediaType: 'application/xhtml+xml',\n    };\n  }\n  appendManifestProperty(manifestItem[tocHtml], 'nav');\n\n  const landmarks: LandmarkEntry[] = [\n    {\n      type: 'toc',\n      href: `${manifestItem[tocHtml].href}#${TOC_ID}`,\n      text: EPUB_LANDMARKS_TOC_ENTRY,\n    },\n  ];\n  if (htmlCoverResource) {\n    landmarks.push({\n      type: 'cover',\n      href: changeExtname(htmlCoverResource.url, '.xhtml'),\n      text: EPUB_LANDMARKS_COVER_ENTRY,\n    });\n  }\n\n  const contextDir = upath.join(tmpDir, 'EPUB');\n  type XhtmlEntry = Resolved<ReturnType<typeof transpileHtmlToXhtml>>;\n  const processHtml = async (target: string) => {\n    let parseResult: XhtmlEntry;\n    try {\n      parseResult = await transpileHtmlToXhtml({\n        target,\n        contextDir,\n      });\n    } catch (error) {\n      const thrownError = error as Error;\n      throw new DetailError(\n        `Failed to transpile document to XHTML: ${target}`,\n        thrownError.stack ?? thrownError.message,\n      );\n    }\n    if (parseResult.hasMathmlContent) {\n      appendManifestProperty(manifestItem[target], 'mathml');\n    }\n    if (parseResult.hasRemoteResources) {\n      appendManifestProperty(manifestItem[target], 'remote-resources');\n    }\n    if (parseResult.hasScriptedContent) {\n      appendManifestProperty(manifestItem[target], 'scripted');\n    }\n    if (parseResult.hasSvgContent) {\n      appendManifestProperty(manifestItem[target], 'svg');\n    }\n    return parseResult;\n  };\n\n  const processResult: Record<string, XhtmlEntry> = {};\n  Logger.debug(`Transpiling ToC HTML to XHTML: ${tocHtml}`);\n  processResult[tocHtml] = await processHtml(tocHtml);\n  for (const target of htmlFiles.filter((f) => f !== tocHtml)) {\n    Logger.debug(`Transpiling HTML to XHTML: ${target}`);\n    processResult[target] = await processHtml(target);\n  }\n\n  // Process ToC document\n  const { document: entryDocument } = processResult[tocHtml].dom.window;\n  const docLanguages = [manifest.inLanguage]\n    .flat()\n    .filter((v): v is string => Boolean(v));\n  if (docLanguages.length === 0) {\n    docLanguages.push(entryDocument.documentElement.lang || 'en');\n  }\n  const docTitle =\n    normalizeLocalizableString(manifest.name, docLanguages) ||\n    entryDocument.title;\n  if (!docTitle) {\n    throw new Error('EPUB must have a title of one or more characters');\n  }\n  const { tocResourceTree } = await processTocDocument({\n    dom: processResult[tocHtml].dom,\n    target: tocHtml,\n    contextDir,\n    readingOrder,\n    docLanguages,\n    landmarks,\n  });\n\n  // Process PageList document\n  const pageListHtml = pageListResource?.url || entryHtmlRelPath;\n  if (pageListHtml && pageListHtml in processResult) {\n    await processPagelistDocument({\n      dom: processResult[pageListHtml].dom,\n      target: pageListHtml,\n      contextDir,\n    });\n  }\n\n  if (relManifestPath) {\n    await fs.promises.rm(upath.join(tmpDir, 'EPUB', relManifestPath), {\n      force: true,\n      recursive: true,\n    });\n    delete manifestItem[relManifestPath];\n  }\n\n  // META-INF/container.xml\n  fs.writeFileSync(\n    upath.join(tmpDir, 'META-INF/container.xml'),\n    EPUB_CONTAINER_XML,\n    'utf8',\n  );\n\n  // EPUB/content.opf\n  Logger.debug(`Generating content.opf`);\n  fs.writeFileSync(\n    upath.join(tmpDir, 'EPUB/content.opf'),\n    buildEpubPackageDocument({\n      epubVersion,\n      uid,\n      docTitle,\n      docLanguages,\n      manifest,\n      spineItems,\n      manifestItems: Object.values(manifestItem),\n    }),\n    'utf8',\n  );\n\n  await compressEpub({ target, sourceDir: tmpDir });\n}\n\nasync function writeAsXhtml(dom: JSDOM, absPath: string) {\n  const xhtml = `${XML_DECLARATION}\\n${serializeToXml(dom.window.document)}`;\n  await fs.promises.writeFile(changeExtname(absPath, '.xhtml'), xhtml, 'utf8');\n}\n\nasync function transpileHtmlToXhtml({\n  target,\n  contextDir,\n}: {\n  target: string;\n  contextDir: string;\n}): Promise<{\n  dom: JSDOM;\n  hasMathmlContent: boolean;\n  hasRemoteResources: boolean;\n  hasScriptedContent: boolean;\n  hasSvgContent: boolean;\n}> {\n  const absPath = upath.join(contextDir, target);\n  const dom = await getJsdomFromUrlOrFile({ src: absPath });\n  const { document } = dom.window;\n  // `xmlns` will be supplied in later serialization process\n  document.documentElement.removeAttribute('xmlns');\n  document.documentElement.setAttribute('xmlns:epub', EPUB_NS);\n\n  document.querySelectorAll('a[href]').forEach((el) => {\n    const href = decodeURI(el.getAttribute('href')!);\n    el.setAttribute('href', getRelativeHref(href, target, target));\n  });\n\n  await writeAsXhtml(dom, absPath);\n  await fs.promises.unlink(absPath);\n  return {\n    dom,\n    // FIXME: Yes, I recognize this implementation is inadequate.\n    hasMathmlContent: !!document.querySelector('math'),\n    hasRemoteResources: !!document.querySelector(\n      '[src^=\"http://\"], [src^=\"https://\"]',\n    ),\n    hasScriptedContent: !!document.querySelector('script, form'),\n    hasSvgContent: !!document.querySelector('svg'),\n  };\n}\n\nfunction replaceWithNavElement(dom: JSDOM, el: Element) {\n  const nav = dom.window.document.createElement('nav');\n  while (el.firstChild) {\n    nav.appendChild(el.firstChild);\n  }\n  for (let i = 0; i < el.attributes.length; i++) {\n    nav.attributes.setNamedItem(el.attributes[i].cloneNode() as Attr);\n  }\n  el.parentNode?.replaceChild(nav, el);\n  return nav;\n}\n\nasync function processTocDocument({\n  dom,\n  target,\n  contextDir,\n  readingOrder,\n  docLanguages,\n  landmarks,\n}: {\n  dom: JSDOM;\n  target: string;\n  contextDir: string;\n  readingOrder: PublicationLinks[];\n  docLanguages: string[];\n  landmarks: LandmarkEntry[];\n}): Promise<{ tocResourceTree: TocResourceTreeRoot | null }> {\n  const { document } = dom.window;\n\n  let tocResourceTree: TocResourceTreeRoot | null = null;\n  if (!document.querySelector('nav[epub:type]')) {\n    tocResourceTree = parseTocDocument(dom);\n    if (tocResourceTree) {\n      const nav = replaceWithNavElement(dom, tocResourceTree.element);\n      nav.setAttribute('id', TOC_ID);\n      nav.setAttribute('epub:type', 'toc');\n    } else {\n      Logger.debug(`Generating toc nav element: ${target}`);\n\n      const nav = document.createElement('nav');\n      nav.setAttribute('id', TOC_ID);\n      nav.setAttribute('role', 'doc-toc');\n      nav.setAttribute('epub:type', 'toc');\n      nav.setAttribute('hidden', '');\n      const h2 = document.createElement('h2');\n      h2.textContent = TOC_TITLE;\n      nav.appendChild(h2);\n      const ol = document.createElement('ol');\n      tocResourceTree = {\n        element: nav,\n        children: [],\n      };\n\n      for (const content of readingOrder) {\n        let name = normalizeLocalizableString(content.name, docLanguages);\n        if (!name) {\n          const dom = await getJsdomFromUrlOrFile({\n            src: upath.join(contextDir, changeExtname(content.url, '.xhtml')),\n          });\n          name = dom.window.document.title;\n        }\n        const li = document.createElement('li');\n        const a = document.createElement('a');\n        a.textContent = name;\n        a.href = getRelativeHref(content.url, '', target);\n        li.appendChild(a);\n        ol.appendChild(li);\n        tocResourceTree.children.push({ element: li, label: a });\n      }\n\n      nav.appendChild(ol);\n      document.body.appendChild(nav);\n      Logger.debug('Generated toc nav element', nav.outerHTML);\n    }\n\n    if (landmarks.length > 0) {\n      Logger.debug(`Generating landmark nav element: ${target}`);\n      const nav = document.createElement('nav');\n      nav.setAttribute('epub:type', 'landmarks');\n      nav.setAttribute('id', LANDMARKS_ID);\n      nav.setAttribute('hidden', '');\n      const h2 = document.createElement('h2');\n      h2.textContent = EPUB_LANDMARKS_TITLE;\n      nav.appendChild(h2);\n      const ol = document.createElement('ol');\n      for (const { type, href, text } of landmarks) {\n        const li = document.createElement('li');\n        const a = document.createElement('a');\n        a.setAttribute('epub:type', type);\n        a.setAttribute('href', getRelativeHref(href, '', target));\n        a.text = text;\n        li.appendChild(a);\n        ol.appendChild(li);\n      }\n      nav.appendChild(ol);\n      document.body.appendChild(nav);\n      Logger.debug('Generated landmark nav element', nav.outerHTML);\n    }\n  }\n\n  // Remove a publication manifest linked to ToC html.\n  // When converting to EPUB, HTML files are converted to XHTML files\n  // and no longer conform to Web publication, so we need to\n  // explicitly remove the publication manifest.\n  const publicationLinkEl = document.querySelector(\n    'link[href][rel=\"publication\"]',\n  );\n  if (publicationLinkEl) {\n    const href = publicationLinkEl.getAttribute('href')!.trim();\n    if (href.startsWith('#')) {\n      const scriptEl = document.getElementById(href.slice(1));\n      if (scriptEl?.getAttribute('type') === 'application/ld+json') {\n        scriptEl.parentNode?.removeChild(scriptEl);\n      }\n    }\n    publicationLinkEl.parentNode?.removeChild(publicationLinkEl);\n  }\n\n  const absPath = upath.join(contextDir, target);\n  await writeAsXhtml(dom, absPath);\n  return { tocResourceTree };\n}\n\nasync function processPagelistDocument({\n  dom,\n  target,\n  contextDir,\n}: {\n  dom: JSDOM;\n  target: string;\n  contextDir: string;\n}): Promise<{ pageListResourceTree: PageListResourceTreeRoot | null }> {\n  const pageListResourceTree = parsePageListDocument(dom);\n  if (pageListResourceTree) {\n    const nav = replaceWithNavElement(dom, pageListResourceTree.element);\n    nav.setAttribute('id', PAGELIST_ID);\n    nav.setAttribute('epub:type', 'page-list');\n  }\n\n  const absPath = upath.join(contextDir, target);\n  await writeAsXhtml(dom, absPath);\n  return { pageListResourceTree };\n}\n\nfunction buildEpubPackageDocument({\n  epubVersion,\n  manifest,\n  uid,\n  docTitle,\n  docLanguages,\n  spineItems,\n  manifestItems,\n}: Pick<Parameters<typeof exportEpub>[0], 'epubVersion'> & {\n  manifest: PublicationManifest;\n  uid: string;\n  docTitle: string;\n  docLanguages: string[];\n  spineItems: SpineEntry[];\n  manifestItems: ManifestEntry[];\n}): string {\n  const slugger = new GithubSlugger();\n  slugger.reset();\n\n  const bookIdentifier = slugger.slug('bookid');\n  const normalizeDate = (value: string | number | undefined) =>\n    value && `${new Date(value).toISOString().split('.')[0]}Z`;\n\n  const transformToGenericTextNode = <T = {}>(value: unknown, attributes?: T) =>\n    [value]\n      .flat()\n      .filter(Boolean)\n      .map((v) => ({ ...(attributes || {}), '#text': `${value}` }));\n  const transformContributor = (\n    contributorMap: Record<string, Contributor | undefined>,\n  ) =>\n    Object.entries(contributorMap).flatMap(([type, contributor]) =>\n      contributor\n        ? [contributor].flat().map((entry, index) => ({\n            _id: slugger.slug(`${type}-${index + 1}`),\n            '#text':\n              typeof entry === 'string'\n                ? entry\n                : normalizeLocalizableString(entry.name, docLanguages),\n          }))\n        : [],\n    );\n\n  const itemIdMap = new Map<string, string>();\n  manifestItems.forEach(({ href }) => {\n    itemIdMap.set(href, slugger.slug(href));\n  });\n\n  const builder = new XMLBuilder({\n    format: true,\n    ignoreAttributes: false,\n    attributeNamePrefix: '_',\n  });\n  return builder.build({\n    '?xml': {\n      _version: '1.0',\n      _encoding: 'UTF-8',\n    },\n    package: {\n      _xmlns: 'http://www.idpf.org/2007/opf',\n      _version: epubVersion,\n      '_unique-identifier': bookIdentifier,\n      '_xml:lang': docLanguages[0],\n      metadata: {\n        '_xmlns:dc': 'http://purl.org/dc/elements/1.1/',\n        'dc:identifier': {\n          _id: bookIdentifier,\n          '#text': uid,\n        },\n        'dc:title': docTitle,\n        'dc:language': docLanguages,\n        'dc:creator': transformContributor({\n          // TODO: Define proper order\n          author: manifest.author,\n          creator: manifest.creator,\n          editor: manifest.editor,\n          artist: manifest.artist,\n          illustrator: manifest.illustrator,\n          colorist: manifest.colorist,\n          penciler: manifest.penciler,\n          inker: manifest.inker,\n          letterer: manifest.letterer,\n          translator: manifest.translator,\n          readBy: manifest.readBy,\n        }),\n        'dc:publisher': transformContributor({\n          publisher: manifest.publisher,\n        }),\n        'dc:contributor': transformContributor({\n          contributor: manifest.contributor,\n        }),\n        'dc:date': transformToGenericTextNode(\n          normalizeDate(manifest.datePublished),\n        ),\n        'dc:rights': transformToGenericTextNode(\n          manifest.copyrightHolder &&\n            `Â© ${manifest.copyrightYear ? `${manifest.copyrightYear} ` : ''}${\n              manifest.copyrightHolder\n            }`,\n        ),\n        'dc:subject': transformToGenericTextNode(\n          manifest['dc:subject'] || manifest.subject,\n        ),\n        meta: [\n          ...transformToGenericTextNode(\n            normalizeDate(manifest.dateModified || Date.now()),\n            {\n              _property: 'dcterms:modified',\n            },\n          ),\n          ...(() => {\n            const coverImage = manifestItems.find(\n              (it) => it.properties === 'cover-image',\n            );\n            return coverImage\n              ? [{ _name: 'cover', _content: itemIdMap.get(coverImage.href) }]\n              : [];\n          })(),\n        ],\n      },\n      manifest: {\n        item: manifestItems.map(({ href, mediaType, properties }) => ({\n          _id: itemIdMap.get(href),\n          _href: encodeURI(href),\n          '_media-type': mediaType,\n          ...(properties ? { _properties: properties } : {}),\n        })),\n      },\n      spine: {\n        ...(manifest.readingProgression\n          ? { '_page-progression-direction': manifest.readingProgression }\n          : {}),\n        itemref: [\n          ...spineItems.map(({ href }) => ({\n            _idref: itemIdMap.get(href),\n          })),\n        ],\n      },\n    },\n  });\n}\n\nasync function compressEpub({\n  target,\n  sourceDir,\n}: {\n  target: string;\n  sourceDir: string;\n}): Promise<void> {\n  Logger.debug(`Compressing EPUB: ${target}`);\n  const output = fs.createWriteStream(target);\n  const archive = archiver('zip', {\n    zlib: { level: 9 }, // Compression level\n  });\n  return new Promise((resolve, reject) => {\n    output.on('close', () => {\n      Logger.debug(`Compressed EPUB: ${target}`);\n      resolve();\n    });\n    output.on('error', reject);\n    archive.on('warning', reject);\n    archive.on('error', reject);\n    archive.pipe(output);\n\n    archive.append('application/epub+zip', {\n      name: 'mimetype',\n      // mimetype should not be compressed\n      // https://www.w3.org/TR/epub-33/#sec-zip-container-mime\n      store: true,\n    });\n    archive.directory(upath.join(sourceDir, 'META-INF'), 'META-INF');\n    archive.directory(upath.join(sourceDir, 'EPUB'), 'EPUB');\n    archive.finalize();\n  });\n}\n","import Arborist from '@npmcli/arborist';\nimport fs from 'node:fs';\nimport type { ResolvedTaskConfig } from '../config/resolve.js';\nimport { DetailError } from '../util.js';\n\nexport async function checkThemeInstallationNecessity({\n  themesDir,\n  themeIndexes,\n}: Pick<ResolvedTaskConfig, 'themesDir' | 'themeIndexes'>): Promise<boolean> {\n  if (!fs.existsSync(themesDir)) {\n    return [...themeIndexes].some((theme) => theme.type === 'package');\n  }\n\n  const commonOpt = {\n    path: themesDir,\n    lockfileVersion: 3,\n    installLinks: true,\n  };\n  const arb = new Arborist(commonOpt);\n  const tree = await arb.loadActual();\n  const pkgs = Array.from(tree.children.keys());\n  return [...themeIndexes].some(\n    (theme) => theme.type === 'package' && !pkgs.includes(theme.name),\n  );\n}\n\nexport async function installThemeDependencies({\n  themesDir,\n  themeIndexes,\n}: Pick<ResolvedTaskConfig, 'themesDir' | 'themeIndexes'>): Promise<void> {\n  fs.mkdirSync(themesDir, { recursive: true });\n\n  try {\n    const commonOpt = {\n      path: themesDir,\n      lockfileVersion: 3,\n      installLinks: true,\n    };\n    const tree = await new Arborist(commonOpt).buildIdealTree();\n    const existing = Array.from(tree.children.keys());\n    const add = [\n      ...new Set(\n        [...themeIndexes].flatMap((theme) =>\n          theme.type === 'package' ? [theme.specifier] : [],\n        ),\n      ),\n    ];\n    const rm = existing.filter((v) => !add.includes(v));\n\n    // Install dependencies\n    const opt = { ...commonOpt, rm, add };\n    const arb = new Arborist(opt);\n    await arb.reify(opt);\n\n    return;\n  } catch (error) {\n    const thrownError = error as Error;\n    throw new DetailError(\n      'An error occurred during the installation of the theme',\n      thrownError.stack ?? thrownError.message,\n    );\n  }\n}\n","import type { ResolvedConfig as ResolvedViteConfig } from 'vite';\nimport { setupConfigFromFlags } from '../commands/cli-flags.js';\nimport { loadVivliostyleConfig } from '../config/load.js';\nimport { mergeConfig, mergeInlineConfig } from '../config/merge.js';\nimport {\n  type ResolvedTaskConfig,\n  resolveTaskConfig,\n} from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\n\nconst headStartTagRe = /<head[^>]*>/i;\nexport const prependToHead = (html: string, content: string) =>\n  html.replace(headStartTagRe, (match) => `${match}\\n${content}`);\n\nexport async function reloadConfig(\n  prevConfig: ResolvedTaskConfig,\n  inlineConfig: ParsedVivliostyleInlineConfig,\n  resolvedViteConfig?: ResolvedViteConfig,\n) {\n  let config =\n    (await loadVivliostyleConfig(inlineConfig)) ??\n    setupConfigFromFlags(inlineConfig);\n  config = mergeInlineConfig(config, inlineConfig);\n  config = mergeConfig(config, {\n    temporaryFilePrefix: prevConfig.temporaryFilePrefix,\n    server: resolvedViteConfig?.server,\n  });\n  const taskConfig = resolveTaskConfig(config.tasks[0], config.inlineOptions);\n  return taskConfig;\n}\n","import sirv from 'sirv';\nimport upath from 'upath';\nimport * as vite from 'vite';\nimport type { ResolvedTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\n\nexport function vsStaticServePlugin({\n  config: _config,\n  inlineConfig,\n}: {\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): vite.Plugin {\n  let config = _config;\n\n  const createMiddlewares = () => {\n    if (typeof config.serverRootDir !== 'string') {\n      return [];\n    }\n    return Object.entries(config.static).flatMap(([base, dirs]) =>\n      dirs.map(\n        (dir) =>\n          [\n            base,\n            sirv(upath.resolve(config.serverRootDir, dir), {\n              dev: true,\n              etag: false,\n            }),\n          ] as const,\n      ),\n    );\n  };\n\n  return {\n    name: 'vivliostyle:static-serve',\n    apply: () => Boolean(inlineConfig.enableStaticServe),\n    configureServer(viteServer) {\n      return () => {\n        createMiddlewares().forEach(([base, middleware]) => {\n          viteServer.middlewares.use(base, middleware);\n        });\n      };\n    },\n\n    configurePreviewServer(viteServer) {\n      return () => {\n        createMiddlewares().forEach(([base, middleware]) => {\n          viteServer.middlewares.use(base, middleware);\n        });\n      };\n    },\n  };\n}\n","import type { NextHandleFunction } from 'connect';\nimport fs from 'node:fs';\nimport sirv from 'sirv';\nimport upath from 'upath';\nimport * as vite from 'vite';\nimport type { ResolvedTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { VIEWER_ROOT_PATH, viewerRoot } from '../const.js';\nimport { prependToHead } from './plugin-util.js';\n\nconst viewerClientId = '@vivliostyle:viewer:client';\nconst viewerClientRequestPath = `/${viewerClientId}`;\nconst viewerClientContent = /* js */ `\nif (import.meta.hot) {\n  import.meta.hot.on('vite:beforeFullReload', (e) => {\n    location.reload();\n  });\n}`;\n\nexport function vsViewerPlugin(_: {\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): vite.Plugin {\n  const serveRootDir = upath.join(viewerRoot, 'lib');\n  const serve = sirv(serveRootDir, { dev: false, etag: true });\n  let cachedIndexHtml: string;\n\n  const middleware = async function vivliostyleViewerMiddleware(\n    req,\n    res,\n    next,\n  ) {\n    if (req.url === '/' || req.url === '/index.html') {\n      cachedIndexHtml ??= prependToHead(\n        fs.readFileSync(upath.join(serveRootDir, 'index.html'), 'utf-8'),\n        `<script type=\"module\" src=\"${viewerClientRequestPath}\"></script>`,\n      );\n      res.statusCode = 200;\n      res.setHeader('Content-Type', 'text/html;charset=utf-8');\n      res.setHeader('Cache-Control', 'no-cache');\n      return res.end(cachedIndexHtml);\n    } else {\n      return serve(req, res, next);\n    }\n  } satisfies NextHandleFunction;\n\n  return {\n    name: 'vivliostyle:viewer',\n    config() {\n      return {\n        optimizeDeps: {\n          exclude: ['@vivliostyle/viewer'],\n        },\n      } satisfies vite.UserConfig;\n    },\n    configureServer(viteServer) {\n      viteServer.middlewares.use(VIEWER_ROOT_PATH, middleware);\n    },\n    configurePreviewServer(viteServer) {\n      viteServer.middlewares.use(VIEWER_ROOT_PATH, serve);\n    },\n    load(id) {\n      if (id === viewerClientRequestPath) {\n        return viewerClientContent;\n      }\n    },\n  };\n}\n"],"mappings":"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","names":["require","cwd","vite","fs","pathToFileURL","upath","fs","upath","cwd","fs","pathToFileURL","fs","upath","upath","fs","_","fs","URL","upath","pathToFileURL","upath","copy","fs","upath","serializeToXml","MIMEType","copy","mime","fs","pathToFileURL","upath","fileURLToPath","pathToFileURL","upath","upath","pathToFileURL","fileURLToPath","document","mime","fs","pathToFileURL","upath","upath","pathToFileURL","value","v","fs","mime","target","document","dom","fs","ret","mime","upath","pathToFileURL","pathContains","v","document","copy","fs","fs","v","upath","fs","copy","vfile","MIMEType","serializeToXml","cwd","upath","pathToFileURL","entry","next","sirv","upath","fs","sirv","upath","upath","sirv","fs","upath","fs","URL","page","locale","server"]}
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-BYT766IR.js b/package/dist/chunk-BYT766IR.js
--- a/package/dist/chunk-BYT766IR.js	1970-01-01 09:00:00.000000000 +0900
+++ b/package/dist/chunk-BYT766IR.js	1985-10-26 17:15:00.000000000 +0900
@@ -0,0 +1,4069 @@
+import {
+  importNodeModule
+} from "./chunk-E6QVHS6D.js";
+import {
+  DetailError,
+  GlobMatcher,
+  Logger,
+  assertPubManifestSchema,
+  cwd,
+  debounce,
+  detectBrowserPlatform,
+  getAssetMatcher,
+  getCacheDir,
+  getDefaultBrowserTag,
+  getDefaultEpubOpfPath,
+  getEpubRootDir,
+  getFormattedError,
+  getOsLocale,
+  getWebPubResourceMatcher,
+  isInContainer,
+  isRunningOnWSL,
+  isValidUri,
+  openEpub,
+  parseJsonc,
+  pathContains,
+  pathEquals,
+  prettifySchemaError,
+  readJSON,
+  registerExitHandler,
+  runExitHandlers,
+  setupConfigFromFlags,
+  statFileSync,
+  touchTmpFile,
+  useTmpDirectory,
+  writeFileIfChanged
+} from "./chunk-T2VWLU2I.js";
+import {
+  VivliostyleConfigSchema
+} from "./chunk-CKXFRCPH.js";
+import {
+  CONTAINER_LOCAL_HOSTNAME,
+  CONTAINER_URL,
+  COVER_HTML_FILENAME,
+  COVER_HTML_IMAGE_ALT,
+  DEFAULT_BROWSER_VERSIONS,
+  EMPTY_DATA_URI,
+  EPUB_CONTAINER_XML,
+  EPUB_LANDMARKS_COVER_ENTRY,
+  EPUB_LANDMARKS_TITLE,
+  EPUB_LANDMARKS_TOC_ENTRY,
+  EPUB_NS,
+  EPUB_OUTPUT_VERSION,
+  MANIFEST_FILENAME,
+  TOC_FILENAME,
+  TOC_TITLE,
+  VIEWER_ROOT_PATH,
+  XML_DECLARATION,
+  cliVersion,
+  viewerRoot
+} from "./chunk-ZEBXHUJX.js";
+import {
+  __callDispose,
+  __using
+} from "./chunk-I7BWSAN6.js";
+
+// src/config/load.ts
+import fs from "node:fs";
+import { createRequire } from "node:module";
+import { pathToFileURL } from "node:url";
+import upath from "upath";
+import * as v from "valibot";
+var require2 = createRequire(import.meta.url);
+function locateVivliostyleConfig({
+  config,
+  cwd: cwd2 = cwd
+}) {
+  if (config) {
+    return upath.resolve(cwd2, config);
+  }
+  return [".js", ".mjs", ".cjs", ".json"].map((ext) => upath.join(cwd2, `vivliostyle.config${ext}`)).find((p) => fs.existsSync(p));
+}
+async function loadVivliostyleConfig({
+  config,
+  configData,
+  cwd: cwd2
+}) {
+  if (configData) {
+    return v.parse(VivliostyleConfigSchema, configData);
+  }
+  const absPath = locateVivliostyleConfig({ config, cwd: cwd2 });
+  if (!absPath) {
+    return;
+  }
+  let parsedConfig;
+  let jsonRaw;
+  try {
+    if (upath.extname(absPath) === ".json") {
+      jsonRaw = fs.readFileSync(absPath, "utf8");
+      parsedConfig = parseJsonc(jsonRaw);
+    } else {
+      delete require2.cache[require2.resolve(absPath)];
+      const url = pathToFileURL(absPath);
+      url.search = `version=${Date.now()}`;
+      parsedConfig = (await import(
+        /* @vite-ignore */
+        url.href
+      )).default;
+      jsonRaw = JSON.stringify(parsedConfig, null, 2);
+    }
+  } catch (error) {
+    const thrownError = error;
+    throw new DetailError(
+      `An error occurred on loading a config file: ${absPath}`,
+      thrownError.stack ?? thrownError.message
+    );
+  }
+  const result = v.safeParse(VivliostyleConfigSchema, parsedConfig);
+  if (result.success) {
+    const { tasks, inlineOptions } = result.output;
+    return {
+      tasks,
+      inlineOptions: {
+        ...inlineOptions,
+        cwd: cwd2 ?? cwd,
+        config: absPath
+      }
+    };
+  } else {
+    const errorString = prettifySchemaError(jsonRaw, result.issues);
+    throw new DetailError(
+      `Validation of vivliostyle config failed. Please check the schema: ${config}`,
+      errorString
+    );
+  }
+}
+function warnDeprecatedConfig(config) {
+  if (config.tasks.some((task) => task.includeAssets)) {
+    Logger.logWarn(
+      "'includeAssets' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'copyAsset.includes' property instead."
+    );
+  }
+  if (config.tasks.some((task) => task.tocTitle)) {
+    Logger.logWarn(
+      "'tocTitle' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'toc.title' property instead."
+    );
+  }
+  if (config.tasks.some((task) => task.http)) {
+    Logger.logWarn(
+      "'http' property of Vivliostyle config was deprecated and will be removed in a future release. This option is enabled by default, and the file protocol is no longer supported."
+    );
+  }
+}
+
+// src/config/merge.ts
+var pruneObject = (obj) => {
+  const ret = { ...obj };
+  for (const key in ret) {
+    if (ret[key] === void 0 || ret[key] === null) {
+      delete ret[key];
+    }
+  }
+  return ret;
+};
+function mergeConfig(base, override) {
+  return {
+    tasks: base.tasks.map((task, i) => ({
+      ...pruneObject(task),
+      ...pruneObject(override)
+    })),
+    inlineOptions: base.inlineOptions
+  };
+}
+function mergeInlineConfig({ tasks, inlineOptions }, inlineConfig) {
+  const {
+    theme,
+    size,
+    pressReady,
+    title,
+    author,
+    language,
+    readingProgression,
+    timeout,
+    image,
+    viewer,
+    viewerParam,
+    browser,
+    output,
+    renderMode,
+    preflight,
+    preflightOption,
+    vite: vite5,
+    viteConfigFile,
+    host,
+    port,
+    ...overrideInlineOptions
+  } = inlineConfig;
+  return {
+    tasks: tasks.map((task) => ({
+      ...pruneObject(task),
+      ...pruneObject({
+        theme,
+        size,
+        pressReady,
+        title,
+        author,
+        language,
+        readingProgression,
+        timeout,
+        image,
+        viewer,
+        viewerParam,
+        browser,
+        vite: vite5,
+        viteConfigFile
+      }),
+      output: (output?.length ? output : task.output)?.map((o) => ({
+        ...pruneObject(o),
+        ...pruneObject({
+          renderMode,
+          preflight,
+          preflightOption
+        })
+      })),
+      server: {
+        ...pruneObject(task.server ?? {}),
+        ...pruneObject({ host, port })
+      }
+    })),
+    inlineOptions: {
+      ...pruneObject(inlineOptions),
+      ...pruneObject({
+        renderMode,
+        preflight,
+        preflightOption
+      }),
+      ...pruneObject(
+        overrideInlineOptions
+      )
+    }
+  };
+}
+
+// src/config/resolve.ts
+import {
+  readMetadata,
+  VFM
+} from "@vivliostyle/vfm";
+import { lookup as mime } from "mime-types";
+import fs3 from "node:fs";
+import { fileURLToPath, pathToFileURL as pathToFileURL2 } from "node:url";
+import npa from "npm-package-arg";
+import upath2 from "upath";
+
+// src/processor/markdown.ts
+import fs2 from "node:fs";
+import vfile from "vfile";
+async function processMarkdown(documentProcessorFactory, documentMetadataReader, filepath, options = {}) {
+  const markdownString = fs2.readFileSync(filepath, "utf8");
+  const processor = documentProcessorFactory(
+    options,
+    documentMetadataReader(markdownString)
+  );
+  const processed = await processor.process(
+    vfile({ path: filepath, contents: markdownString })
+  );
+  return processed;
+}
+function readMarkdownMetadata(filepath, documentMetadataReader) {
+  return documentMetadataReader(fs2.readFileSync(filepath, "utf8"));
+}
+
+// src/config/resolve.ts
+var manuscriptMediaTypes = [
+  "text/markdown",
+  "text/html",
+  "text/plain",
+  "application/xhtml+xml",
+  // a special MIME type indicates that a custom processor is used
+  "text/x-vivliostyle-custom"
+];
+var UseTemporaryServerRoot = Symbol("UseTemporaryServerRoot");
+var DEFAULT_ASSET_EXTENSIONS = [
+  "css",
+  "css.map",
+  "png",
+  "jpg",
+  "jpeg",
+  "svg",
+  "gif",
+  "webp",
+  "apng",
+  "ttf",
+  "otf",
+  "woff",
+  "woff2"
+];
+function isManuscriptMediaType(mediaType) {
+  return !!(mediaType && manuscriptMediaTypes.includes(mediaType));
+}
+var htmlExtensions = [".html", ".htm", ".xhtml", ".xht"];
+function toHtmlExtension(filename) {
+  const ext = upath2.extname(filename).toLowerCase();
+  if (htmlExtensions.includes(
+    // @ts-expect-error check membership
+    ext
+  )) {
+    return filename;
+  }
+  return `${filename.slice(0, -ext.length)}.html`;
+}
+function isWebPubConfig(config) {
+  return config.viewerInput.type === "webpub";
+}
+function isWebbookConfig(config) {
+  return config.viewerInput.type === "webbook";
+}
+function parsePackageName(specifier, cwd2) {
+  try {
+    let result = npa(specifier, cwd2);
+    if (result.type === "git" && result.saveSpec?.startsWith("github:")) {
+      result = npa(`file:${specifier}`, cwd2);
+    }
+    return result;
+  } catch (error) {
+    return null;
+  }
+}
+function parseTheme({
+  theme,
+  context,
+  workspaceDir,
+  themesDir
+}) {
+  const { specifier, import: importPath } = typeof theme === "string" ? { specifier: theme, import: void 0 } : theme;
+  if (isValidUri(specifier)) {
+    return {
+      type: "uri",
+      name: upath2.basename(specifier),
+      location: specifier
+    };
+  }
+  const stylePath = upath2.resolve(context, specifier);
+  if (fs3.existsSync(stylePath) && stylePath.endsWith(".css")) {
+    const sourceRelPath = upath2.relative(context, stylePath);
+    return {
+      type: "file",
+      name: upath2.basename(specifier),
+      source: stylePath,
+      location: upath2.resolve(workspaceDir, sourceRelPath)
+    };
+  }
+  const parsed = parsePackageName(specifier, context);
+  if (!parsed) {
+    throw new Error(`Invalid package name: ${specifier}`);
+  }
+  if (!parsed.registry && parsed.type !== "directory") {
+    throw new Error(`This package specifier is not allowed: ${specifier}`);
+  }
+  let name = parsed.name;
+  let resolvedSpecifier = specifier;
+  if (parsed.type === "directory" && parsed.fetchSpec) {
+    const pkgJsonPath = upath2.join(parsed.fetchSpec, "package.json");
+    if (fs3.existsSync(pkgJsonPath)) {
+      const packageJson = JSON.parse(fs3.readFileSync(pkgJsonPath, "utf8"));
+      name = packageJson.name;
+      resolvedSpecifier = parsed.fetchSpec;
+    }
+  }
+  if (!name) {
+    throw new Error(`Could not determine the package name: ${specifier}`);
+  }
+  return {
+    type: "package",
+    name,
+    specifier: resolvedSpecifier,
+    location: upath2.join(themesDir, "node_modules", name),
+    registry: Boolean(parsed.registry),
+    importPath
+  };
+}
+function parsePageSize(size) {
+  const [width, height, ...others] = `${size}`.split(",");
+  if (!width || others.length) {
+    throw new Error(`Cannot parse size: ${size}`);
+  } else if (width && height) {
+    return {
+      width,
+      height
+    };
+  } else {
+    return {
+      format: width
+    };
+  }
+}
+function parseFileMetadata({
+  contentType,
+  sourcePath,
+  workspaceDir,
+  themesDir,
+  documentMetadataReader
+}) {
+  const sourceDir = upath2.dirname(sourcePath);
+  let title;
+  let themes;
+  if (documentMetadataReader) {
+    const metadata = readMarkdownMetadata(sourcePath, documentMetadataReader);
+    title = metadata.title;
+    if (metadata.vfm?.theme && themesDir) {
+      themes = [metadata.vfm.theme].flat().filter(
+        (entry) => !!entry && (typeof entry === "string" || typeof entry === "object")
+      ).map(
+        (theme) => parseTheme({
+          theme,
+          context: sourceDir,
+          workspaceDir,
+          themesDir
+        })
+      );
+    }
+  } else if (contentType === "text/html" || contentType === "application/xhtml+xml") {
+    const content = fs3.readFileSync(sourcePath, "utf8");
+    title = content.match(/<title>([^<]*)<\/title>/)?.[1] || void 0;
+  }
+  return { title, themes };
+}
+function parseCustomStyle({
+  customStyle,
+  entryContextDir
+}) {
+  if (isValidUri(customStyle)) {
+    return customStyle;
+  }
+  const stylePath = upath2.resolve(entryContextDir, customStyle);
+  if (!pathContains(entryContextDir, stylePath)) {
+    throw Error(
+      `Custom style file ${customStyle} is not in ${entryContextDir}. Make sure the file is located in the context directory or a subdirectory.`
+    );
+  }
+  if (!fs3.existsSync(stylePath)) {
+    throw new Error(`Custom style file not found: ${customStyle}`);
+  }
+  return pathToFileURL2(stylePath).href.slice(
+    pathToFileURL2(entryContextDir).href.replace(/\/$/, "").length + 1
+  );
+}
+function resolveTaskConfig(config, options) {
+  const context = options.cwd ?? cwd;
+  Logger.debug("resolveTaskConfig > context %s", context);
+  const entryContextDir = config.entryContext ? upath2.resolve(context, config.entryContext) : context;
+  const language = config.language;
+  const readingProgression = config.readingProgression;
+  const size = config.size ? parsePageSize(config.size) : void 0;
+  const cropMarks = options.cropMarks ?? false;
+  const bleed = options.bleed;
+  const cropOffset = options.cropOffset;
+  const css = options.css;
+  const singleDoc = options.singleDoc ?? false;
+  const quick = options.quick ?? false;
+  const temporaryFilePrefix = config.temporaryFilePrefix ?? `.vs-${Date.now()}.`;
+  const vfmOptions = {
+    ...config?.vfm,
+    hardLineBreaks: config?.vfm?.hardLineBreaks ?? false,
+    disableFormatHtml: config?.vfm?.disableFormatHtml ?? false
+  };
+  const timeout = config.timeout ?? 3e5;
+  const sandbox = options.sandbox ?? false;
+  const browser = (() => {
+    const type = config.browser?.type ?? "chrome";
+    const platform = detectBrowserPlatform();
+    return {
+      type,
+      tag: config.browser?.tag ?? (platform ? DEFAULT_BROWSER_VERSIONS[type][platform] : "latest"),
+      executablePath: options.executableBrowser
+    };
+  })();
+  const proxyServer = options.proxyServer ?? process.env.HTTP_PROXY ?? void 0;
+  const proxy = proxyServer ? {
+    server: proxyServer,
+    bypass: options.proxyBypass ?? process.env.NOPROXY ?? void 0,
+    username: options.proxyUser,
+    password: options.proxyPass
+  } : void 0;
+  const image = config.image ?? `${CONTAINER_URL}:${cliVersion}`;
+  const viewer = config.viewer ?? void 0;
+  const viewerParam = config.viewerParam ?? void 0;
+  const logLevel = options.logLevel ?? "silent";
+  const ignoreHttpsErrors = options.ignoreHttpsErrors ?? false;
+  const base = config.base ?? "/vivliostyle";
+  const staticRoutes = config.static ?? {};
+  const viteConfig = config.vite;
+  const viteConfigFile = config.viteConfigFile ?? true;
+  const customStyle = options.style && parseCustomStyle({ customStyle: options.style, entryContextDir }) || void 0;
+  const customUserStyle = options.userStyle && parseCustomStyle({ customStyle: options.userStyle, entryContextDir }) || void 0;
+  const outputs = (() => {
+    const defaultPdfOptions = {
+      format: "pdf",
+      renderMode: options.renderMode ?? "local",
+      preflight: options.preflight ?? (config.pressReady ? "press-ready" : void 0),
+      preflightOption: options.preflightOption ?? []
+    };
+    if (config.output) {
+      return config.output.map((target) => {
+        const outputPath = upath2.resolve(context, target.path);
+        const format = target.format;
+        switch (format) {
+          case "pdf":
+            return {
+              ...defaultPdfOptions,
+              ...target,
+              format,
+              path: outputPath
+            };
+          case "epub":
+            return {
+              ...target,
+              format,
+              path: outputPath,
+              version: EPUB_OUTPUT_VERSION
+            };
+          case "webpub":
+            return {
+              ...target,
+              format,
+              path: outputPath
+            };
+          default:
+            return format;
+        }
+      });
+    }
+    const filename = config.title ? `${config.title}.pdf` : "output.pdf";
+    return [
+      {
+        ...defaultPdfOptions,
+        path: upath2.resolve(context, filename)
+      }
+    ];
+  })();
+  const { server, rootUrl } = (() => {
+    let host = config.server?.host ?? false;
+    let allowedHosts = config.server?.allowedHosts || [];
+    const port = config.server?.port ?? 13e3;
+    if (outputs.some(
+      (target) => target.format === "pdf" && target.renderMode === "docker"
+    ) && !isInContainer()) {
+      host = true;
+      if (Array.isArray(allowedHosts) && !allowedHosts.includes(CONTAINER_LOCAL_HOSTNAME)) {
+        allowedHosts.push(CONTAINER_LOCAL_HOSTNAME);
+      }
+    }
+    const rootHostname = !host ? "localhost" : host === true ? "0.0.0.0" : host;
+    return {
+      server: {
+        host,
+        port,
+        proxy: config.server?.proxy ?? {},
+        allowedHosts
+      },
+      rootUrl: `http://${rootHostname}:${port}`
+    };
+  })();
+  const cover = config.cover && {
+    src: upath2.resolve(entryContextDir, config.cover.src),
+    name: config.cover.name || COVER_HTML_IMAGE_ALT
+  };
+  const copyAsset = {
+    includes: config.copyAsset?.includes ?? config.includeAssets ?? [],
+    excludes: config.copyAsset?.excludes ?? [],
+    fileExtensions: [
+      .../* @__PURE__ */ new Set([
+        ...DEFAULT_ASSET_EXTENSIONS,
+        ...config.copyAsset?.includeFileExtensions ?? []
+      ])
+    ].filter(
+      (ext) => !(config.copyAsset?.excludeFileExtensions ?? []).includes(ext)
+    )
+  };
+  const themeIndexes = /* @__PURE__ */ new Set();
+  const projectConfig = !options.config && options.input ? resolveSingleInputConfig({
+    config,
+    input: options.input,
+    context,
+    temporaryFilePrefix,
+    themeIndexes,
+    base
+  }) : resolveComposedProjectConfig({
+    config,
+    context,
+    entryContextDir,
+    outputs,
+    temporaryFilePrefix,
+    themeIndexes,
+    cover
+  });
+  for (const output of outputs) {
+    const relPath = upath2.relative(context, output.path);
+    if (pathContains(output.path, entryContextDir) || pathEquals(output.path, entryContextDir)) {
+      throw new Error(
+        `The output path is set to "${relPath}", but this will overwrite the original manuscript file. Please specify a different path.`
+      );
+    }
+    if (pathContains(output.path, projectConfig.workspaceDir) || pathEquals(output.path, projectConfig.workspaceDir)) {
+      throw new Error(
+        `The output path is set to "${relPath}", but this will overwrite the working directory of Vivliostyle. Please specify a different path.`
+      );
+    }
+  }
+  const { entries, workspaceDir } = projectConfig;
+  const duplicatedTarget = entries.find(
+    (v1, i) => entries.findLastIndex((v2) => v1.target === v2.target) !== i
+  )?.target;
+  if (duplicatedTarget) {
+    const sourceFile = entries.find(
+      (entry) => entry.target === duplicatedTarget && entry.source?.type === "file"
+    )?.source;
+    throw new Error(
+      `The output path "${upath2.relative(workspaceDir, duplicatedTarget)}" will overwrite existing content.` + (sourceFile ? ` Please choose a different name for the source file: ${sourceFile.pathname}` : "")
+    );
+  }
+  const resolvedConfig = {
+    ...projectConfig,
+    entryContextDir,
+    outputs,
+    themeIndexes,
+    copyAsset,
+    temporaryFilePrefix,
+    size,
+    cropMarks,
+    bleed,
+    cropOffset,
+    css,
+    customStyle,
+    customUserStyle,
+    singleDoc,
+    quick,
+    language,
+    readingProgression,
+    vfmOptions,
+    cover,
+    timeout,
+    sandbox,
+    browser,
+    proxy,
+    image,
+    viewer,
+    viewerParam,
+    logLevel,
+    ignoreHttpsErrors,
+    base,
+    server,
+    static: staticRoutes,
+    rootUrl,
+    viteConfig,
+    viteConfigFile
+  };
+  return resolvedConfig;
+}
+function resolveSingleInputConfig({
+  config,
+  input,
+  context,
+  temporaryFilePrefix,
+  themeIndexes,
+  base
+}) {
+  Logger.debug("entering single entry config mode");
+  let serverRootDir;
+  let sourcePath;
+  let workspaceDir;
+  const inputFormat = input.format;
+  const title = config?.title;
+  const author = config?.author;
+  const entries = [];
+  const exportAliases = [];
+  let isLocalResource = true;
+  if (isValidUri(input.entry)) {
+    const url = new URL(input.entry);
+    if (url.protocol === "file:") {
+      sourcePath = fileURLToPath(url);
+    } else {
+      isLocalResource = false;
+      sourcePath = input.entry;
+    }
+  } else {
+    sourcePath = upath2.resolve(context, input.entry);
+  }
+  if (isLocalResource) {
+    statFileSync(sourcePath);
+    switch (input.format) {
+      case "webbook":
+      case "markdown":
+      case "pub-manifest":
+      case "epub":
+        workspaceDir = upath2.dirname(sourcePath);
+        break;
+      case "epub-opf": {
+        const rootDir = getEpubRootDir(sourcePath);
+        if (!rootDir) {
+          throw new Error(
+            `Could not determine the EPUB root directory for the OPF file: ${sourcePath}`
+          );
+        }
+        workspaceDir = rootDir;
+        break;
+      }
+      default:
+        return input.format;
+    }
+    serverRootDir = workspaceDir;
+  } else {
+    serverRootDir = UseTemporaryServerRoot;
+    workspaceDir = context;
+  }
+  const themesDir = upath2.resolve(workspaceDir, "themes");
+  if (input.format === "markdown") {
+    const contentType = "text/markdown";
+    const documentProcessor = {
+      processorFactory: config.documentProcessor ?? VFM,
+      metadataReader: config.documentMetadataReader ?? readMetadata
+    };
+    const metadata = parseFileMetadata({
+      contentType,
+      sourcePath,
+      workspaceDir,
+      documentMetadataReader: documentProcessor.metadataReader
+    });
+    const target = toHtmlExtension(
+      upath2.resolve(
+        workspaceDir,
+        `${temporaryFilePrefix}${upath2.basename(sourcePath)}`
+      )
+    );
+    touchTmpFile(target);
+    const themes = metadata.themes ?? config.theme?.map(
+      (theme) => parseTheme({
+        theme,
+        context,
+        workspaceDir,
+        themesDir
+      })
+    ) ?? [];
+    themes.forEach((t) => themeIndexes.add(t));
+    entries.push({
+      contentType,
+      source: {
+        type: "file",
+        pathname: sourcePath,
+        contentType,
+        documentProcessor
+      },
+      target,
+      title: metadata.title,
+      themes
+    });
+    exportAliases.push({
+      source: target,
+      target: upath2.resolve(
+        upath2.dirname(target),
+        toHtmlExtension(upath2.basename(sourcePath))
+      )
+    });
+  }
+  let fallbackTitle;
+  let viewerInput;
+  if (inputFormat === "markdown") {
+    const manifestPath = upath2.resolve(
+      workspaceDir,
+      `${temporaryFilePrefix}${MANIFEST_FILENAME}`
+    );
+    touchTmpFile(manifestPath);
+    exportAliases.push({
+      source: manifestPath,
+      target: upath2.resolve(workspaceDir, MANIFEST_FILENAME)
+    });
+    fallbackTitle = entries.length === 1 && entries[0].title ? entries[0].title : upath2.basename(sourcePath);
+    viewerInput = {
+      type: "webpub",
+      manifestPath,
+      needToGenerateManifest: true
+    };
+  } else if (inputFormat === "webbook") {
+    let webbookEntryUrl;
+    let webbookPath;
+    if (isValidUri(sourcePath)) {
+      const url = new URL(sourcePath);
+      webbookEntryUrl = url.href;
+    } else {
+      const rootFileUrl = pathToFileURL2(workspaceDir).href;
+      const urlPath = pathToFileURL2(sourcePath).href.slice(rootFileUrl.length);
+      webbookEntryUrl = `${base}${urlPath}`;
+      webbookPath = sourcePath;
+    }
+    viewerInput = { type: "webbook", webbookEntryUrl, webbookPath };
+  } else if (inputFormat === "pub-manifest") {
+    viewerInput = {
+      type: "webpub",
+      manifestPath: sourcePath,
+      needToGenerateManifest: false
+    };
+  } else if (inputFormat === "epub-opf") {
+    viewerInput = { type: "epub-opf", epubOpfPath: sourcePath };
+  } else if (inputFormat === "epub") {
+    viewerInput = {
+      type: "epub",
+      epubPath: sourcePath,
+      epubTmpOutputDir: upath2.join(
+        sourcePath,
+        `../${temporaryFilePrefix}${upath2.basename(sourcePath)}`
+      )
+    };
+  } else {
+    return inputFormat;
+  }
+  return {
+    serverRootDir,
+    workspaceDir,
+    themesDir,
+    entries,
+    input: {
+      format: inputFormat,
+      entry: sourcePath
+    },
+    viewerInput,
+    exportAliases,
+    title: title || fallbackTitle,
+    author
+  };
+}
+function resolveComposedProjectConfig({
+  config,
+  context,
+  entryContextDir,
+  outputs,
+  temporaryFilePrefix,
+  themeIndexes,
+  cover
+}) {
+  Logger.debug("entering composed project config mode");
+  const workspaceDir = upath2.resolve(
+    context,
+    config.workspaceDir ?? ".vivliostyle"
+  );
+  const themesDir = upath2.resolve(workspaceDir, "themes");
+  const pkgJsonPath = upath2.resolve(context, "package.json");
+  const pkgJson = fs3.existsSync(pkgJsonPath) ? readJSON(pkgJsonPath) : void 0;
+  if (pkgJson) {
+    Logger.debug("located package.json path", pkgJsonPath);
+  }
+  const exportAliases = [];
+  const rootThemes = config.theme?.map(
+    (theme) => parseTheme({
+      theme,
+      context,
+      workspaceDir,
+      themesDir
+    })
+  ) ?? [];
+  rootThemes.forEach((t) => themeIndexes.add(t));
+  const tocConfig = {
+    tocTitle: config.toc?.title ?? config?.tocTitle ?? TOC_TITLE,
+    target: upath2.resolve(workspaceDir, config.toc?.htmlPath ?? TOC_FILENAME),
+    sectionDepth: config.toc?.sectionDepth ?? 0,
+    transform: {
+      transformDocumentList: config.toc?.transformDocumentList,
+      transformSectionList: config.toc?.transformSectionList
+    }
+  };
+  const coverHtml = config.cover && ("htmlPath" in config.cover && !config.cover.htmlPath ? void 0 : upath2.resolve(
+    workspaceDir,
+    config.cover?.htmlPath || COVER_HTML_FILENAME
+  ));
+  const ensureCoverImage = (src) => {
+    const absPath = src && upath2.resolve(entryContextDir, src);
+    if (absPath) {
+      statFileSync(absPath, {
+        errorMessage: "Specified cover image does not exist"
+      });
+    }
+    return absPath;
+  };
+  const projectTitle = config?.title ?? pkgJson?.name;
+  const projectAuthor = config?.author ?? pkgJson?.author;
+  const rootDocumentProcessor = {
+    processorFactory: config.documentProcessor ?? VFM,
+    metadataReader: config.documentMetadataReader ?? readMetadata
+  };
+  const isContentsEntry = (entry) => entry.rel === "contents";
+  const isCoverEntry = (entry) => entry.rel === "cover";
+  const isArticleEntry = (entry) => !isContentsEntry(entry) && !isCoverEntry(entry);
+  function parseEntry(entry) {
+    const getInputInfo = (entryPath) => {
+      if (/^https?:/.test(entryPath)) {
+        return {
+          type: "uri",
+          href: entryPath,
+          rootDir: upath2.join(workspaceDir, new URL(entryPath).host)
+        };
+      } else if (entryPath.startsWith("/")) {
+        return {
+          type: "uri",
+          href: entryPath,
+          rootDir: upath2.join(workspaceDir, "localhost")
+        };
+      }
+      const pathname = upath2.resolve(entryContextDir, entryPath);
+      statFileSync(pathname);
+      const rawContentType = mime(pathname);
+      const documentProcessor = {
+        processorFactory: "documentProcessor" in entry && entry.documentProcessor || rootDocumentProcessor.processorFactory,
+        metadataReader: "documentMetadataReader" in entry && entry.documentMetadataReader || rootDocumentProcessor.metadataReader
+      };
+      const hasCustomProcessor = !!(documentProcessor.processorFactory !== VFM || documentProcessor.metadataReader !== readMetadata);
+      const contentType = hasCustomProcessor && rawContentType !== "text/markdown" ? "text/x-vivliostyle-custom" : rawContentType;
+      if (!isManuscriptMediaType(contentType) || contentType === "text/plain") {
+        throw new Error(
+          `Invalid manuscript type ${rawContentType} detected: ${entry}`
+        );
+      }
+      const useDocumentProcessor = contentType === "text/markdown" || contentType === "text/x-vivliostyle-custom";
+      return {
+        type: "file",
+        pathname,
+        contentType,
+        metadata: parseFileMetadata({
+          contentType,
+          sourcePath: pathname,
+          workspaceDir,
+          themesDir,
+          documentMetadataReader: useDocumentProcessor ? documentProcessor.metadataReader : void 0
+        }),
+        ...useDocumentProcessor && { documentProcessor }
+      };
+    };
+    const getTargetPath = (source) => {
+      switch (source.type) {
+        case "file":
+          return upath2.resolve(
+            workspaceDir,
+            toHtmlExtension(upath2.relative(entryContextDir, source.pathname))
+          );
+        case "uri": {
+          const url = new URL(source.href, "a://dummy");
+          let pathname = url.pathname;
+          if (!/\.\w+$/.test(pathname)) {
+            pathname = `${pathname.replace(/\/$/, "")}/index.html`;
+          }
+          return upath2.join(source.rootDir, pathname);
+        }
+        default:
+          return source;
+      }
+    };
+    if ((isContentsEntry(entry) || isCoverEntry(entry)) && entry.path) {
+      const source = upath2.resolve(entryContextDir, entry.path);
+      try {
+        statFileSync(source);
+      } catch (error) {
+        Logger.logWarn(
+          `The "path" option is set but the file does not exist: ${source}
+Maybe you want to set the "output" field instead.`
+        );
+        entry.output = entry.path;
+        entry.path = void 0;
+      }
+    }
+    if (isContentsEntry(entry)) {
+      const inputInfo = entry.path ? getInputInfo(entry.path) : void 0;
+      const { metadata, ...template } = inputInfo || {};
+      let target = entry.output ? upath2.resolve(workspaceDir, entry.output) : inputInfo && getTargetPath(inputInfo);
+      const themes = entry.theme ? [entry.theme].flat().map(
+        (theme) => parseTheme({
+          theme,
+          context,
+          workspaceDir,
+          themesDir
+        })
+      ) : metadata?.themes ?? [...rootThemes];
+      themes.forEach((t) => themeIndexes.add(t));
+      target ??= tocConfig.target;
+      if (inputInfo?.type === "file" && pathEquals(inputInfo.pathname, target)) {
+        const tmpPath = upath2.resolve(
+          upath2.dirname(target),
+          `${temporaryFilePrefix}${upath2.basename(target)}`
+        );
+        exportAliases.push({ source: tmpPath, target });
+        touchTmpFile(tmpPath);
+        target = tmpPath;
+      }
+      const parsedEntry = {
+        rel: "contents",
+        ...tocConfig,
+        target,
+        title: entry.title ?? metadata?.title ?? projectTitle,
+        themes,
+        pageBreakBefore: entry.pageBreakBefore,
+        pageCounterReset: entry.pageCounterReset,
+        ..."type" in template && { template }
+      };
+      return parsedEntry;
+    }
+    if (isCoverEntry(entry)) {
+      const inputInfo = entry.path ? getInputInfo(entry.path) : void 0;
+      const { metadata, ...template } = inputInfo || {};
+      let target = entry.output ? upath2.resolve(workspaceDir, entry.output) : inputInfo && getTargetPath(inputInfo);
+      const themes = entry.theme ? [entry.theme].flat().map(
+        (theme) => parseTheme({
+          theme,
+          context,
+          workspaceDir,
+          themesDir
+        })
+      ) : metadata?.themes ?? [];
+      themes.forEach((t) => themeIndexes.add(t));
+      const coverImageSrc = ensureCoverImage(entry.imageSrc || cover?.src);
+      if (!coverImageSrc) {
+        throw new Error(
+          `A CoverEntryConfig is set in the entry list but a location of cover file is not set. Please set 'cover' property in your config file.`
+        );
+      }
+      target ??= upath2.resolve(
+        workspaceDir,
+        entry.path || coverHtml || COVER_HTML_FILENAME
+      );
+      if (inputInfo?.type === "file" && pathEquals(inputInfo.pathname, target)) {
+        const tmpPath = upath2.resolve(
+          upath2.dirname(target),
+          `${temporaryFilePrefix}${upath2.basename(target)}`
+        );
+        exportAliases.push({ source: tmpPath, target });
+        touchTmpFile(tmpPath);
+        target = tmpPath;
+      }
+      const parsedEntry = {
+        rel: "cover",
+        target,
+        title: entry.title ?? metadata?.title ?? projectTitle,
+        themes,
+        coverImageSrc,
+        coverImageAlt: entry.imageAlt || cover?.name || COVER_HTML_IMAGE_ALT,
+        pageBreakBefore: entry.pageBreakBefore,
+        ..."type" in template && { template }
+      };
+      return parsedEntry;
+    }
+    if (isArticleEntry(entry)) {
+      const inputInfo = getInputInfo(entry.path);
+      const { metadata, ...source } = inputInfo;
+      const target = entry.output ? upath2.resolve(workspaceDir, entry.output) : getTargetPath(inputInfo);
+      const themes = entry.theme ? [entry.theme].flat().map(
+        (theme) => parseTheme({ theme, context, workspaceDir, themesDir })
+      ) : metadata?.themes ?? [...rootThemes];
+      themes.forEach((t) => themeIndexes.add(t));
+      const parsedEntry = {
+        contentType: inputInfo.type === "file" ? inputInfo.contentType : "text/html",
+        source,
+        target,
+        title: entry.title ?? metadata?.title ?? projectTitle,
+        themes,
+        ...entry.rel && { rel: entry.rel }
+      };
+      return parsedEntry;
+    }
+    return entry;
+  }
+  const entries = config.entry.map(parseEntry);
+  let fallbackProjectTitle;
+  if (!projectTitle) {
+    if (entries.length === 1 && entries[0].title) {
+      fallbackProjectTitle = entries[0].title;
+    } else {
+      fallbackProjectTitle = upath2.basename(outputs[0].path);
+    }
+  }
+  if (!!config?.toc && !entries.find(({ rel }) => rel === "contents")) {
+    entries.unshift({
+      rel: "contents",
+      ...tocConfig,
+      themes: [...rootThemes]
+    });
+  }
+  if (cover && coverHtml && !entries.find(({ rel }) => rel === "cover")) {
+    entries.unshift({
+      rel: "cover",
+      target: coverHtml,
+      title: projectTitle,
+      themes: [],
+      // Don't inherit rootThemes for cover documents
+      coverImageSrc: ensureCoverImage(cover.src),
+      coverImageAlt: cover.name
+    });
+  }
+  return {
+    serverRootDir: context,
+    workspaceDir,
+    themesDir,
+    entries,
+    input: {
+      format: "pub-manifest",
+      entry: upath2.join(workspaceDir, MANIFEST_FILENAME)
+    },
+    viewerInput: {
+      type: "webpub",
+      manifestPath: upath2.join(workspaceDir, MANIFEST_FILENAME),
+      needToGenerateManifest: true
+    },
+    exportAliases,
+    title: projectTitle || fallbackProjectTitle,
+    author: projectAuthor
+  };
+}
+
+// src/vite/vite-plugin-browser.ts
+import "vite";
+
+// src/browser.ts
+import fs4 from "node:fs";
+import upath3 from "upath";
+var browserEnumMap = {
+  chrome: "chrome",
+  chromium: "chromium",
+  firefox: "firefox"
+};
+async function launchBrowser({
+  browserType,
+  proxy,
+  executablePath,
+  headless,
+  noSandbox,
+  disableDevShmUsage,
+  ignoreHttpsErrors
+}) {
+  const puppeteer = await importNodeModule("puppeteer-core");
+  const args = [];
+  if (browserType === "chrome" || browserType === "chromium") {
+    args.push(
+      "--disable-field-trial-config",
+      "--disable-back-forward-cache",
+      "--disable-component-update",
+      "--no-default-browser-check",
+      "--disable-features=AcceptCHFrame,AvoidUnnecessaryBeforeUnloadCheckSync,DestroyProfileOnBrowserClose,DialMediaRouteProvider,GlobalMediaControls,HttpsUpgrades,LensOverlay,MediaRouter,PaintHolding,ThirdPartyStoragePartitioning,Translate,AutoDeElevate,RenderDocument",
+      "--enable-features=CDPScreenshotNewSurface",
+      "--no-service-autorun",
+      "--unsafely-disable-devtools-self-xss-warnings",
+      "--edge-skip-compat-layer-relaunch"
+    );
+    if (process.platform === "darwin") {
+      args.push("--enable-unsafe-swiftshader");
+    }
+    if (noSandbox) {
+      args.push("--no-sandbox");
+    }
+    if (headless) {
+      args.push(
+        "--hide-scrollbars",
+        "--mute-audio",
+        "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4"
+      );
+    }
+    if (proxy?.server) {
+      const proxyURL = new URL(proxy.server);
+      const isSocks = proxyURL.protocol === "socks5:";
+      if (isSocks) {
+        args.push(
+          `--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`
+        );
+      }
+      args.push(`--proxy-server=${proxy.server}`);
+      const proxyBypassRules = [];
+      if (proxy.bypass) {
+        proxyBypassRules.push(
+          ...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t)
+        );
+      }
+      proxyBypassRules.push("<-loopback>");
+      args.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
+    }
+    args.push("--disable-web-security");
+    if (disableDevShmUsage) {
+      args.push("--disable-dev-shm-usage");
+    }
+    if (headless) {
+      args.push("--force-device-scale-factor=1");
+    }
+    if (isRunningOnWSL()) {
+      args.push("--disable-gpu");
+    }
+    args.push("--lang=en");
+    if (!headless && process.platform === "darwin") {
+      args.push("-AppleLanguages", "(en)");
+    }
+    args.push("--no-startup-window");
+  }
+  const launchOptions = {
+    executablePath,
+    args,
+    browser: browserType === "chromium" ? "chrome" : browserType,
+    headless,
+    acceptInsecureCerts: ignoreHttpsErrors,
+    waitForInitialPage: false
+  };
+  Logger.debug("launchOptions %O", launchOptions);
+  const browser = await puppeteer.launch({
+    ...launchOptions,
+    env: { ...process.env, LANG: "en.UTF-8" }
+  });
+  registerExitHandler("Closing browser", () => {
+    browser.close();
+  });
+  const [browserContext] = browser.browserContexts();
+  return { browser, browserContext };
+}
+function getPuppeteerCacheDir() {
+  if (isInContainer()) {
+    return "/opt/puppeteer";
+  }
+  return upath3.join(getCacheDir(), "browsers");
+}
+async function resolveBuildId({
+  type,
+  tag,
+  browsers
+}) {
+  const cacheDataFilename = upath3.join(
+    getPuppeteerCacheDir(),
+    "build-ids.json"
+  );
+  let cacheData;
+  try {
+    cacheData = JSON.parse(fs4.readFileSync(cacheDataFilename, "utf-8"));
+    if (Date.now() - cacheData.createdAt > 24 * 60 * 60 * 1e3) {
+      cacheData = { createdAt: Date.now(), buildIds: {} };
+    }
+  } catch (_) {
+    cacheData = { createdAt: Date.now(), buildIds: {} };
+  }
+  if (cacheData.buildIds[type]?.[tag]) {
+    return cacheData.buildIds[type][tag];
+  }
+  const platform = detectBrowserPlatform();
+  if (!platform) {
+    throw new Error("The current platform is not supported.");
+  }
+  const buildId = await browsers.resolveBuildId(
+    browserEnumMap[type],
+    platform,
+    tag
+  );
+  (cacheData.buildIds[type] ??= {})[tag] = buildId;
+  fs4.mkdirSync(upath3.dirname(cacheDataFilename), { recursive: true });
+  fs4.writeFileSync(cacheDataFilename, JSON.stringify(cacheData));
+  return buildId;
+}
+async function cleanupOutdatedBrowsers() {
+  for (const browser of Object.values(browserEnumMap)) {
+    const browsersDir = upath3.join(getPuppeteerCacheDir(), browser);
+    if (!fs4.existsSync(browsersDir)) {
+      continue;
+    }
+    const entries = fs4.readdirSync(browsersDir);
+    for (const entry of entries) {
+      const entryPath = upath3.join(browsersDir, entry);
+      const stat = fs4.statSync(entryPath);
+      if (!stat.isDirectory() || Date.now() - stat.mtimeMs > 7 * 24 * 60 * 60 * 1e3) {
+        Logger.debug(`Removing outdated browser at ${entryPath}`);
+        await fs4.promises.rm(entryPath, { recursive: true, force: true });
+      }
+    }
+  }
+}
+async function getExecutableBrowserPath({
+  type,
+  tag
+}) {
+  const browsers = await importNodeModule("@puppeteer/browsers");
+  const buildId = await resolveBuildId({ type, tag, browsers });
+  return browsers.computeExecutablePath({
+    cacheDir: getPuppeteerCacheDir(),
+    browser: browserEnumMap[type],
+    buildId
+  });
+}
+function checkBrowserAvailability(path) {
+  return fs4.existsSync(path);
+}
+async function downloadBrowser({
+  type,
+  tag
+}) {
+  const browsers = await importNodeModule("@puppeteer/browsers");
+  const buildId = await resolveBuildId({ type, tag, browsers });
+  let installedBrowser;
+  if (isInContainer()) {
+    const defaultBrowserVersion = getDefaultBrowserTag("chrome");
+    Logger.logWarn(
+      `The container you are using already includes a browser (chrome@${defaultBrowserVersion}); however, the specified browser ${type}@${tag} was not found. Downloading the browser inside the container may take a long time. Consider using a container image that includes the required browser version.`
+    );
+  }
+  {
+    var _stack = [];
+    try {
+      const _2 = __using(_stack, Logger.suspendLogging(
+        "Rendering browser is not installed yet. Downloading now."
+      ));
+      installedBrowser = await browsers.install({
+        cacheDir: getPuppeteerCacheDir(),
+        browser: browserEnumMap[type],
+        buildId,
+        downloadProgressCallback: "default"
+      });
+    } catch (_) {
+      var _error = _, _hasError = true;
+    } finally {
+      __callDispose(_stack, _error, _hasError);
+    }
+  }
+  return installedBrowser.executablePath;
+}
+async function launchPreview({
+  mode,
+  url,
+  onBrowserOpen,
+  onPageOpen,
+  config: { browser: browserConfig, proxy, sandbox, ignoreHttpsErrors }
+}) {
+  let executableBrowser = browserConfig.executablePath;
+  Logger.debug(`Specified browser path: ${executableBrowser}`);
+  if (executableBrowser) {
+    if (!checkBrowserAvailability(executableBrowser)) {
+      throw new Error(
+        `Cannot find the browser. Please check the executable browser path: ${executableBrowser}`
+      );
+    }
+  } else if (detectBrowserPlatform() === "linux_arm" && (browserConfig.type === "chrome" || browserConfig.type === "chromium")) {
+    Logger.logInfo(
+      "The official Chrome/Chromium binaries are not available for ARM64 Linux. Using the system-installed Chromium browser instead."
+    );
+    executableBrowser = "/usr/bin/chromium";
+  } else {
+    executableBrowser = await getExecutableBrowserPath(browserConfig);
+    Logger.debug(`Using default browser: ${executableBrowser}`);
+    if (!checkBrowserAvailability(executableBrowser)) {
+      await cleanupOutdatedBrowsers();
+      await downloadBrowser(browserConfig);
+    }
+  }
+  const { browser, browserContext } = await launchBrowser({
+    browserType: browserConfig.type,
+    proxy,
+    executablePath: executableBrowser,
+    headless: mode === "build",
+    noSandbox: !sandbox,
+    disableDevShmUsage: isInContainer(),
+    ignoreHttpsErrors
+  });
+  await onBrowserOpen?.(browser);
+  const page = (await browserContext.pages())[0] ?? await browserContext.newPage();
+  await page.setViewport(
+    mode === "build" ? (
+      // This viewport size is important to detect headless environment in Vivliostyle viewer
+      // https://github.com/vivliostyle/vivliostyle.js/blob/73bcf323adcad80126b0175630609451ccd09d8a/packages/core/src/vivliostyle/vgen.ts#L2489-L2500
+      { width: 800, height: 600 }
+    ) : null
+  );
+  await onPageOpen?.(page);
+  page.on("dialog", () => {
+  });
+  if (proxy?.username && proxy?.password) {
+    await page.authenticate({
+      username: proxy.username,
+      password: proxy.password
+    });
+  }
+  await page.goto(url);
+  return { browser, page };
+}
+
+// src/server.ts
+import fs10 from "node:fs";
+import { URL as URL2 } from "node:url";
+import upath12 from "upath";
+import {
+  createServer,
+  preview
+} from "vite";
+
+// src/vite/vite-plugin-dev-server.ts
+import escapeRe from "escape-string-regexp";
+import { pathToFileURL as pathToFileURL6 } from "node:url";
+import sirv from "sirv";
+import upath9 from "upath";
+import "vite";
+
+// src/processor/compile.ts
+import "@vivliostyle/jsdom";
+import { copy as copy3, move } from "fs-extra/esm";
+import fs8 from "node:fs";
+import upath8 from "upath";
+import serializeToXml2 from "w3c-xmlserializer";
+import MIMEType2 from "whatwg-mimetype";
+
+// src/output/webbook.ts
+import { copy as copy2 } from "fs-extra/esm";
+import { lookup as mime3 } from "mime-types";
+import fs6 from "node:fs";
+import { pathToFileURL as pathToFileURL5 } from "node:url";
+import { glob } from "tinyglobby";
+import upath6 from "upath";
+
+// src/processor/html.tsx
+import jsdom, {
+  ResourceLoader as BaseResourceLoader,
+  JSDOM
+} from "@vivliostyle/jsdom";
+import DOMPurify from "dompurify";
+import { toHtml } from "hast-util-to-html";
+import { fileURLToPath as fileURLToPath2, pathToFileURL as pathToFileURL3 } from "node:url";
+import upath4 from "upath";
+import MIMEType from "whatwg-mimetype";
+import { jsx, jsxs } from "hastscript/jsx-runtime";
+var createVirtualConsole = (onError) => {
+  const virtualConsole = new jsdom.VirtualConsole();
+  virtualConsole.on("error", (message) => {
+    Logger.debug("[JSDOM Console] error:", message);
+  });
+  virtualConsole.on("warn", (message) => {
+    Logger.debug("[JSDOM Console] warn:", message);
+  });
+  virtualConsole.on("log", (message) => {
+    Logger.debug("[JSDOM Console] log:", message);
+  });
+  virtualConsole.on("info", (message) => {
+    Logger.debug("[JSDOM Console] info:", message);
+  });
+  virtualConsole.on("dir", (message) => {
+    Logger.debug("[JSDOM Console] dir:", message);
+  });
+  virtualConsole.on("jsdomError", (error) => {
+    if (error.message === "Could not parse CSS stylesheet") {
+      return;
+    }
+    onError(
+      new DetailError(
+        "Error occurred when loading content",
+        error.stack ?? error.message
+      )
+    );
+  });
+  return virtualConsole;
+};
+var htmlPurify = DOMPurify(
+  // @ts-expect-error: jsdom.DOMWindow should have trustedTypes property
+  new JSDOM("").window
+);
+var ResourceLoader = class _ResourceLoader extends BaseResourceLoader {
+  static dataUrlOrigin = "http://localhost/";
+  fetcherMap = /* @__PURE__ */ new Map();
+  fetch(url, options) {
+    Logger.debug(`[JSDOM] Fetching resource: ${url}`);
+    const fetcher = super.fetch(url, options);
+    if (fetcher) {
+      this.fetcherMap.set(url, fetcher);
+    }
+    return fetcher;
+  }
+  static async saveFetchedResources({
+    fetcherMap,
+    rootUrl,
+    outputDir,
+    onError
+  }) {
+    const rootHref = rootUrl.startsWith("data:") ? _ResourceLoader.dataUrlOrigin : /^https?:/i.test(rootUrl) ? new URL("/", rootUrl).href : new URL(".", rootUrl).href;
+    const normalizeToLocalPath = (urlString, mimeType) => {
+      let url = new URL(urlString);
+      url.hash = "";
+      if (mimeType === "text/html" && !/\.html?$/.test(url.pathname)) {
+        url.pathname = `${url.pathname.replace(/\/$/, "")}/index.html`;
+      }
+      let relTarget = upath4.relative(rootHref, url.href);
+      return decodeURI(relTarget);
+    };
+    const fetchedResources = [];
+    await Promise.allSettled(
+      [...fetcherMap.entries()].flatMap(async ([url, fetcher]) => {
+        if (!url.startsWith(rootHref)) {
+          return [];
+        }
+        return fetcher.then(async (buffer) => {
+          let encodingFormat;
+          try {
+            const contentType = fetcher.response?.headers["content-type"];
+            if (contentType) {
+              encodingFormat = new MIMEType(contentType).essence;
+            }
+          } catch (e) {
+          }
+          const relTarget = normalizeToLocalPath(url, encodingFormat);
+          const target = upath4.join(outputDir, relTarget);
+          fetchedResources.push({ url: relTarget, encodingFormat });
+          writeFileIfChanged(target, buffer);
+        }).catch(onError);
+      })
+    );
+    return fetchedResources;
+  }
+};
+async function getJsdomFromUrlOrFile({
+  src,
+  resourceLoader,
+  virtualConsole = createVirtualConsole((error) => {
+    throw error;
+  })
+}) {
+  const url = isValidUri(src) ? new URL(src) : pathToFileURL3(src);
+  let dom;
+  if (url.protocol === "http:" || url.protocol === "https:") {
+    dom = await JSDOM.fromURL(src, {
+      virtualConsole,
+      resources: resourceLoader
+    });
+  } else if (url.protocol === "file:") {
+    if (resourceLoader) {
+      const file = resourceLoader._readFile(fileURLToPath2(url));
+      resourceLoader.fetcherMap.set(url.href, file);
+    }
+    dom = await JSDOM.fromFile(fileURLToPath2(url), {
+      virtualConsole,
+      resources: resourceLoader,
+      contentType: src.endsWith(".xhtml") || src.endsWith(".xml") ? "application/xhtml+xml; charset=UTF-8" : "text/html; charset=UTF-8"
+    });
+  } else if (url.protocol === "data:") {
+    const [head, body] = url.href.split(",", 2);
+    const data = decodeURIComponent(body);
+    const buffer = Buffer.from(
+      data,
+      /;base64$/i.test(head) ? "base64" : "utf8"
+    );
+    const dummyUrl = `${ResourceLoader.dataUrlOrigin}index.html`;
+    if (resourceLoader) {
+      let timeoutId;
+      const promise = new Promise((resolve) => {
+        timeoutId = setTimeout(resolve, 0, buffer);
+      });
+      promise.abort = () => {
+        if (timeoutId !== void 0) {
+          clearTimeout(timeoutId);
+        }
+      };
+      resourceLoader.fetcherMap.set(dummyUrl, promise);
+    }
+    dom = new JSDOM(buffer.toString(), {
+      virtualConsole,
+      resources: resourceLoader,
+      contentType: "text/html; charset=UTF-8",
+      url: dummyUrl
+    });
+  } else {
+    throw new Error(`Unsupported protocol: ${url.protocol}`);
+  }
+  return dom;
+}
+function getJsdomFromString({
+  html,
+  virtualConsole = createVirtualConsole((error) => {
+    throw error;
+  })
+}) {
+  return new JSDOM(html, {
+    virtualConsole
+  });
+}
+async function getStructuredSectionFromHtml(htmlPath, href) {
+  const dom = await getJsdomFromUrlOrFile({ src: htmlPath });
+  const { document: document2 } = dom.window;
+  const allHeadings = [...document2.querySelectorAll("h1, h2, h3, h4, h5, h6")].filter((el) => {
+    return !el.matches("blockquote *");
+  }).sort((a, b) => {
+    const position = a.compareDocumentPosition(b);
+    return position & 2 ? 1 : position & 4 ? -1 : 0;
+  });
+  function traverse(headers) {
+    if (headers.length === 0) {
+      return [];
+    }
+    const [head, ...tail] = headers;
+    const section = head.parentElement;
+    const id = head.id || section.id;
+    const level = Number(head.tagName.slice(1));
+    let i = tail.findIndex((s) => Number(s.tagName.slice(1)) <= level);
+    i = i === -1 ? tail.length : i;
+    return [
+      {
+        headingHtml: htmlPurify.sanitize(head.innerHTML),
+        headingText: head.textContent?.trim().replace(/\s+/g, " ") || "",
+        level,
+        ...href && id && { href: `${href}#${encodeURIComponent(id)}` },
+        ...id && { id },
+        children: traverse(tail.slice(0, i))
+      },
+      ...traverse(tail.slice(i))
+    ];
+  }
+  return traverse(allHeadings);
+}
+var getTocHtmlStyle = ({
+  pageBreakBefore,
+  pageCounterReset
+}) => {
+  if (!pageBreakBefore && typeof pageCounterReset !== "number") {
+    return null;
+  }
+  return (
+    /* css */
+    `
+${pageBreakBefore ? (
+      /* css */
+      `:root {
+  break-before: ${pageBreakBefore};
+}`
+    ) : ""}
+${// Note: `--vs-document-first-page-counter-reset` is reserved variable name in Vivliostyle base themes
+    typeof pageCounterReset === "number" ? (
+      /* css */
+      `@page :nth(1) {
+  --vs-document-first-page-counter-reset: page ${Math.floor(pageCounterReset - 1)};
+  counter-reset: var(--vs-document-first-page-counter-reset);
+}`
+    ) : ""}
+`
+  );
+};
+var defaultTocTransform = {
+  transformDocumentList: (nodeList) => (propsList) => {
+    return /* @__PURE__ */ jsx("ol", { children: nodeList.map((a, i) => [a, propsList[i]]).flatMap(
+      ([{ href, title, sections }, { children, ...otherProps }]) => {
+        if (sections?.length === 1 && sections[0].level === 1) {
+          return [children].flat().flatMap((e) => {
+            if (e.type === "element" && e.tagName === "ol") {
+              return e.children;
+            }
+            return e;
+          });
+        }
+        return /* @__PURE__ */ jsxs("li", { ...otherProps, children: [
+          /* @__PURE__ */ jsx("a", { ...{ href }, children: title }),
+          children
+        ] });
+      }
+    ) });
+  },
+  transformSectionList: (nodeList) => (propsList) => {
+    return /* @__PURE__ */ jsx("ol", { children: nodeList.map((a, i) => [a, propsList[i]]).map(
+      ([{ headingHtml, href, level }, { children, ...otherProps }]) => {
+        const headingContent = {
+          type: "raw",
+          value: headingHtml
+        };
+        return /* @__PURE__ */ jsxs("li", { ...otherProps, "data-section-level": level, children: [
+          href ? /* @__PURE__ */ jsx("a", { ...{ href }, children: headingContent }) : /* @__PURE__ */ jsx("span", { children: headingContent }),
+          children
+        ] });
+      }
+    ) });
+  }
+};
+function generateDefaultTocHtml({
+  language,
+  title
+}) {
+  const toc = /* @__PURE__ */ jsxs("html", { lang: language, children: [
+    /* @__PURE__ */ jsxs("head", { children: [
+      /* @__PURE__ */ jsx("meta", { charset: "utf-8" }),
+      /* @__PURE__ */ jsx("title", { children: title || "" }),
+      /* @__PURE__ */ jsx("style", { "data-vv-style": true })
+    ] }),
+    /* @__PURE__ */ jsxs("body", { children: [
+      /* @__PURE__ */ jsx("h1", { children: title || "" }),
+      /* @__PURE__ */ jsx("nav", { id: "toc", role: "doc-toc" })
+    ] })
+  ] });
+  return toHtml(toc);
+}
+async function generateTocListSection({
+  entries,
+  distDir,
+  sectionDepth,
+  transform = {}
+}) {
+  const {
+    transformDocumentList = defaultTocTransform.transformDocumentList,
+    transformSectionList = defaultTocTransform.transformSectionList
+  } = transform;
+  const structure = await Promise.all(
+    entries.map(async (entry) => {
+      const href = encodeURI(upath4.relative(distDir, entry.target));
+      const sections = sectionDepth >= 1 ? await getStructuredSectionFromHtml(entry.target, href) : [];
+      return {
+        title: entry.title || upath4.basename(entry.target, ".html"),
+        href: encodeURI(upath4.relative(distDir, entry.target)),
+        sections,
+        children: []
+        // TODO
+      };
+    })
+  );
+  const docToc = transformDocumentList(structure)(
+    structure.map((doc) => {
+      function renderSectionList(sections) {
+        const nodeList = sections.flatMap((section) => {
+          if (section.level > sectionDepth) {
+            return [];
+          }
+          return section;
+        });
+        if (nodeList.length === 0) {
+          return [];
+        }
+        return transformSectionList(nodeList)(
+          nodeList.map((node) => ({
+            children: [renderSectionList(node.children || [])].flat()
+          }))
+        );
+      }
+      return {
+        children: [renderSectionList(doc.sections || [])].flat()
+      };
+    })
+  );
+  return toHtml(docToc, { allowDangerousHtml: true });
+}
+async function processTocHtml(dom, {
+  manifestPath,
+  tocTitle,
+  styleOptions = {},
+  entries,
+  distDir,
+  sectionDepth,
+  transform
+}) {
+  const { document: document2 } = dom.window;
+  if (!document2.querySelector(
+    'link[rel="publication"][type="application/ld+json"]'
+  )) {
+    const l = document2.createElement("link");
+    l.setAttribute("rel", "publication");
+    l.setAttribute("type", "application/ld+json");
+    l.setAttribute("href", encodeURI(upath4.relative(distDir, manifestPath)));
+    document2.head.appendChild(l);
+  }
+  const style = document2.querySelector("style[data-vv-style]");
+  if (style) {
+    const textContent = getTocHtmlStyle(styleOptions);
+    if (textContent) {
+      style.textContent = textContent;
+    } else {
+      style.remove();
+    }
+  }
+  const nav = document2.querySelector('nav, [role="doc-toc"]');
+  if (nav && !nav.hasChildNodes()) {
+    const h2 = document2.createElement("h2");
+    h2.textContent = tocTitle;
+    nav.appendChild(h2);
+    nav.innerHTML += await generateTocListSection({
+      entries,
+      distDir,
+      sectionDepth,
+      transform
+    });
+  }
+  return dom;
+}
+var getCoverHtmlStyle = ({
+  pageBreakBefore
+}) => (
+  /* css */
+  `
+${pageBreakBefore ? `:root {
+  break-before: ${pageBreakBefore};
+}` : ""}
+body {
+  margin: 0;
+}
+[role="doc-cover"] {
+  display: block;
+  width: 100vw;
+  height: 100vh;
+  object-fit: contain;
+}
+@page {
+  margin: 0;
+}
+`
+);
+function generateDefaultCoverHtml({
+  language,
+  title
+}) {
+  const toc = /* @__PURE__ */ jsxs("html", { lang: language, children: [
+    /* @__PURE__ */ jsxs("head", { children: [
+      /* @__PURE__ */ jsx("meta", { charset: "utf-8" }),
+      /* @__PURE__ */ jsx("title", { children: title || "" }),
+      /* @__PURE__ */ jsx("style", { "data-vv-style": true })
+    ] }),
+    /* @__PURE__ */ jsx("body", { children: /* @__PURE__ */ jsx("section", { role: "region", "aria-label": "Cover", children: /* @__PURE__ */ jsx("img", { role: "doc-cover" }) }) })
+  ] });
+  return toHtml(toc);
+}
+async function processCoverHtml(dom, {
+  imageSrc,
+  imageAlt,
+  styleOptions = {}
+}) {
+  const { document: document2 } = dom.window;
+  const style = document2.querySelector("style[data-vv-style]");
+  if (style) {
+    const textContent = getCoverHtmlStyle(styleOptions);
+    if (textContent) {
+      style.textContent = textContent;
+    } else {
+      style.remove();
+    }
+  }
+  const cover = document2.querySelector('img[role="doc-cover"]');
+  if (cover && !cover.hasAttribute("src")) {
+    cover.setAttribute("src", encodeURI(imageSrc));
+  }
+  if (cover && !cover.hasAttribute("alt")) {
+    cover.setAttribute("alt", imageAlt);
+  }
+  return dom;
+}
+async function processManuscriptHtml(dom, {
+  title,
+  style,
+  contentType,
+  language
+}) {
+  const { document: document2 } = dom.window;
+  if (title) {
+    if (!document2.querySelector("title")) {
+      const t = document2.createElement("title");
+      document2.head.appendChild(t);
+    }
+    document2.title = title;
+  }
+  for (const s of style ?? []) {
+    const l = document2.createElement("link");
+    l.setAttribute("rel", "stylesheet");
+    l.setAttribute("type", "text/css");
+    l.setAttribute("href", encodeURI(s));
+    document2.head.appendChild(l);
+  }
+  if (language) {
+    if (contentType === "application/xhtml+xml") {
+      if (!document2.documentElement.getAttribute("xml:lang")) {
+        document2.documentElement.setAttribute("lang", language);
+        document2.documentElement.setAttribute("xml:lang", language);
+      }
+    } else {
+      if (!document2.documentElement.getAttribute("lang")) {
+        document2.documentElement.setAttribute("lang", language);
+      }
+    }
+  }
+  return dom;
+}
+async function fetchLinkedPublicationManifest({
+  dom,
+  resourceLoader,
+  baseUrl
+}) {
+  const { document: document2 } = dom.window;
+  const linkEl = document2.querySelector('link[href][rel="publication"]');
+  if (!linkEl) {
+    return null;
+  }
+  const href = linkEl.getAttribute("href").trim();
+  let manifest;
+  let manifestUrl = baseUrl;
+  if (href.startsWith("#")) {
+    const scriptEl = document2.getElementById(href.slice(1));
+    if (scriptEl?.getAttribute("type") !== "application/ld+json") {
+      return null;
+    }
+    Logger.debug(`Found embedded publication manifest: ${href}`);
+    try {
+      manifest = JSON.parse(scriptEl.innerHTML);
+    } catch (error) {
+      const thrownError = error;
+      throw new DetailError(
+        "Failed to parse manifest data",
+        typeof thrownError.stack
+      );
+    }
+  } else {
+    Logger.debug(`Found linked publication manifest: ${href}`);
+    const url = new URL(href, baseUrl);
+    manifestUrl = url.href;
+    const buffer = await resourceLoader.fetch(url.href);
+    if (!buffer) {
+      throw new Error(`Failed to fetch manifest JSON file: ${url.href}`);
+    }
+    const manifestJson = buffer.toString();
+    try {
+      manifest = JSON.parse(manifestJson);
+    } catch (error) {
+      const thrownError = error;
+      throw new DetailError(
+        "Failed to parse manifest data",
+        typeof thrownError.stack
+      );
+    }
+  }
+  try {
+    assertPubManifestSchema(manifest);
+  } catch (error) {
+    Logger.logWarn(
+      `Publication manifest validation failed. Processing continues, but some problems may occur.
+${error}`
+    );
+  }
+  return {
+    manifest: decodePublicationManifest(manifest),
+    manifestUrl
+  };
+}
+function parseTocDocument(dom) {
+  const { document: document2 } = dom.window;
+  const docTocEl = document2.querySelectorAll('[role="doc-toc"]');
+  if (docTocEl.length === 0) {
+    return null;
+  }
+  const tocRoot = docTocEl.item(0);
+  const parseTocItem = (element) => {
+    if (element.tagName !== "LI") {
+      return null;
+    }
+    const label = element.children.item(0);
+    const ol = element.children.item(1);
+    if (!label || label.tagName !== "A" && label.tagName !== "SPAN") {
+      return null;
+    }
+    if (!ol || ol.tagName !== "OL") {
+      return { element, label };
+    }
+    const children = Array.from(ol.children).reduce((acc, val) => {
+      if (!acc) {
+        return acc;
+      }
+      const res = parseTocItem(val);
+      return res && [...acc, res];
+    }, []);
+    return children && {
+      element,
+      label,
+      children
+    };
+  };
+  let heading;
+  for (let child of Array.from(tocRoot.children)) {
+    if (child.tagName === "OL") {
+      const children = Array.from(child.children).reduce((acc, val) => {
+        if (!acc) {
+          return acc;
+        }
+        const res = parseTocItem(val);
+        return res && [...acc, res];
+      }, []);
+      return children && { element: tocRoot, heading, children };
+    } else if (["H1", "H2", "H3", "H4", "H5", "H6", "HGROUP"].includes(child.tagName)) {
+      heading = child;
+    } else {
+      return null;
+    }
+  }
+  return null;
+}
+function parsePageListDocument(dom) {
+  const { document: document2 } = dom.window;
+  const docPageListEl = document2.querySelectorAll('[role="doc-pagelist"]');
+  if (docPageListEl.length === 0) {
+    return null;
+  }
+  const pageListRoot = docPageListEl.item(0);
+  let heading;
+  for (let child of Array.from(pageListRoot.children)) {
+    if (child.tagName === "OL") {
+      const children = Array.from(child.children).reduce((acc, element) => {
+        return acc && (element.tagName === "LI" ? [...acc, { element }] : null);
+      }, []);
+      return children && { element: pageListRoot, heading, children };
+    } else if (["H1", "H2", "H3", "H4", "H5", "H6", "HGROUP"].includes(child.tagName)) {
+      heading = child;
+    } else {
+      return null;
+    }
+  }
+  return null;
+}
+
+// src/output/epub.ts
+import archiver from "archiver";
+import { lookup as lookupLanguage } from "bcp-47-match";
+import { XMLBuilder } from "fast-xml-parser";
+import { copy } from "fs-extra/esm";
+import GithubSlugger from "github-slugger";
+import { lookup as mime2 } from "mime-types";
+import fs5 from "node:fs";
+import { pathToFileURL as pathToFileURL4 } from "node:url";
+import upath5 from "upath";
+import { v4 as uuid } from "uuid";
+import serializeToXml from "w3c-xmlserializer";
+var TOC_ID = "toc";
+var LANDMARKS_ID = "landmarks";
+var PAGELIST_ID = "page-list";
+var COVER_IMAGE_MIMETYPES = [
+  "image/gif",
+  "image/jpeg",
+  "image/png",
+  "image/svg+xml",
+  "image/webp"
+];
+var changeExtname = (filepath, newExt) => {
+  let ext = upath5.extname(filepath);
+  return `${filepath.slice(0, -ext.length)}${newExt}`;
+};
+var getRelativeHref = (target, baseUrl, rootUrl) => {
+  const absBasePath = upath5.join("/", baseUrl);
+  const absRootPath = upath5.join("/", rootUrl);
+  const hrefUrl = new URL(encodeURI(target), pathToFileURL4(absBasePath));
+  if (hrefUrl.protocol !== "file:") {
+    return target;
+  }
+  if (/\.html?$/.test(hrefUrl.pathname)) {
+    hrefUrl.pathname = changeExtname(hrefUrl.pathname, ".xhtml");
+  }
+  const pathname = upath5.posix.relative(
+    pathToFileURL4(upath5.dirname(absRootPath)).pathname,
+    hrefUrl.pathname
+  );
+  return `${pathname}${hrefUrl.search}${hrefUrl.hash}`;
+};
+var normalizeLocalizableString = (value, availableLanguages) => {
+  if (!value) {
+    return;
+  }
+  const values = [value].flat().map((value2) => typeof value2 === "string" ? { value: value2 } : value2);
+  const localizedValues = values.filter(
+    (v2) => !!v2.language
+  );
+  const preferredLang = lookupLanguage(
+    localizedValues.map((v2) => v2.language),
+    availableLanguages
+  );
+  if (preferredLang) {
+    return localizedValues[localizedValues.findIndex((v2) => v2.language === preferredLang)].value;
+  }
+  return values.find((v2) => !v2.language)?.value;
+};
+var appendManifestProperty = (entry, newProperty) => {
+  entry.properties = entry.properties ? Array.from(/* @__PURE__ */ new Set([...entry.properties.split(" "), newProperty])).join(
+    " "
+  ) : newProperty;
+};
+async function exportEpub({
+  webpubDir,
+  entryHtmlFile,
+  manifest,
+  relManifestPath,
+  target,
+  epubVersion
+}) {
+  Logger.debug("Export EPUB", {
+    webpubDir,
+    entryHtmlFile,
+    relManifestPath,
+    target,
+    epubVersion
+  });
+  const [tmpDir] = await useTmpDirectory();
+  fs5.mkdirSync(upath5.join(tmpDir, "META-INF"), { recursive: true });
+  await copy(webpubDir, upath5.join(tmpDir, "EPUB"));
+  const uid = `urn:uuid:${uuid()}`;
+  const entryHtmlRelPath = entryHtmlFile && upath5.relative(webpubDir, upath5.resolve(webpubDir, entryHtmlFile));
+  const findPublicationLink = (relType, list, filter) => [list].flat().find(
+    (e) => typeof e === "object" && e.rel === relType && (!filter || filter(e))
+  );
+  const tocResource = findPublicationLink("contents", [
+    ...[manifest.readingOrder || []].flat(),
+    ...[manifest.resources || []].flat()
+  ]);
+  const pageListResource = findPublicationLink("pagelist", [
+    ...[manifest.readingOrder || []].flat(),
+    ...[manifest.resources || []].flat()
+  ]);
+  const pictureCoverResource = findPublicationLink(
+    "cover",
+    manifest.resources,
+    (e) => COVER_IMAGE_MIMETYPES.includes(e.encodingFormat || mime2(e.url) || "")
+  );
+  const htmlCoverResource = findPublicationLink(
+    "cover",
+    [
+      ...[manifest.readingOrder || []].flat(),
+      ...[manifest.resources || []].flat()
+    ],
+    (e) => /\.html?$/.test(e.url)
+  );
+  const manifestItem = [
+    ...[manifest.links || []].flat(),
+    ...[manifest.readingOrder || []].flat(),
+    ...[manifest.resources || []].flat()
+  ].reduce(
+    (acc, val) => {
+      const { url, encodingFormat } = typeof val === "string" ? { url: val } : val;
+      try {
+        new URL(url);
+        return acc;
+      } catch (e) {
+      }
+      if (!fs5.existsSync(upath5.join(tmpDir, "EPUB", url))) {
+        return acc;
+      }
+      const mediaType = encodingFormat || mime2(url) || "text/plain";
+      acc[url] = {
+        href: url,
+        mediaType
+      };
+      if (/\.html?$/.test(url)) {
+        acc[url].href = changeExtname(url, ".xhtml");
+        acc[url].mediaType = "application/xhtml+xml";
+      }
+      if (url === pictureCoverResource?.url) {
+        acc[url].properties = "cover-image";
+      }
+      return acc;
+    },
+    {}
+  );
+  const htmlFiles = Object.keys(manifestItem).filter(
+    (url) => /\.html?$/.test(url)
+  );
+  let tocHtml = htmlFiles.find((f) => f === tocResource?.url);
+  const readingOrder = [manifest.readingOrder || entryHtmlRelPath].flat().flatMap((v2) => v2 ? typeof v2 === "string" ? { url: v2 } : v2 : []);
+  if (!tocHtml) {
+    Logger.logWarn(
+      "No table of contents document was found. for EPUB output, we recommend to enable `toc` option in your Vivliostyle config file to generate a table of contents document."
+    );
+    tocHtml = htmlFiles.find((f) => f === entryHtmlRelPath) || readingOrder[0].url;
+  }
+  const spineItems = readingOrder.map(({ url }) => ({
+    href: changeExtname(url, ".xhtml")
+  }));
+  if (!(tocHtml in manifestItem)) {
+    manifestItem[tocHtml] = {
+      href: changeExtname(tocHtml, ".xhtml"),
+      mediaType: "application/xhtml+xml"
+    };
+  }
+  appendManifestProperty(manifestItem[tocHtml], "nav");
+  const landmarks = [
+    {
+      type: "toc",
+      href: `${manifestItem[tocHtml].href}#${TOC_ID}`,
+      text: EPUB_LANDMARKS_TOC_ENTRY
+    }
+  ];
+  if (htmlCoverResource) {
+    landmarks.push({
+      type: "cover",
+      href: changeExtname(htmlCoverResource.url, ".xhtml"),
+      text: EPUB_LANDMARKS_COVER_ENTRY
+    });
+  }
+  const contextDir = upath5.join(tmpDir, "EPUB");
+  const processHtml = async (target2) => {
+    let parseResult;
+    try {
+      parseResult = await transpileHtmlToXhtml({
+        target: target2,
+        contextDir
+      });
+    } catch (error) {
+      const thrownError = error;
+      throw new DetailError(
+        `Failed to transpile document to XHTML: ${target2}`,
+        thrownError.stack ?? thrownError.message
+      );
+    }
+    if (parseResult.hasMathmlContent) {
+      appendManifestProperty(manifestItem[target2], "mathml");
+    }
+    if (parseResult.hasRemoteResources) {
+      appendManifestProperty(manifestItem[target2], "remote-resources");
+    }
+    if (parseResult.hasScriptedContent) {
+      appendManifestProperty(manifestItem[target2], "scripted");
+    }
+    if (parseResult.hasSvgContent) {
+      appendManifestProperty(manifestItem[target2], "svg");
+    }
+    return parseResult;
+  };
+  const processResult = {};
+  Logger.debug(`Transpiling ToC HTML to XHTML: ${tocHtml}`);
+  processResult[tocHtml] = await processHtml(tocHtml);
+  for (const target2 of htmlFiles.filter((f) => f !== tocHtml)) {
+    Logger.debug(`Transpiling HTML to XHTML: ${target2}`);
+    processResult[target2] = await processHtml(target2);
+  }
+  const { document: entryDocument } = processResult[tocHtml].dom.window;
+  const docLanguages = [manifest.inLanguage].flat().filter((v2) => Boolean(v2));
+  if (docLanguages.length === 0) {
+    docLanguages.push(entryDocument.documentElement.lang || "en");
+  }
+  const docTitle = normalizeLocalizableString(manifest.name, docLanguages) || entryDocument.title;
+  if (!docTitle) {
+    throw new Error("EPUB must have a title of one or more characters");
+  }
+  const { tocResourceTree } = await processTocDocument({
+    dom: processResult[tocHtml].dom,
+    target: tocHtml,
+    contextDir,
+    readingOrder,
+    docLanguages,
+    landmarks
+  });
+  const pageListHtml = pageListResource?.url || entryHtmlRelPath;
+  if (pageListHtml && pageListHtml in processResult) {
+    await processPagelistDocument({
+      dom: processResult[pageListHtml].dom,
+      target: pageListHtml,
+      contextDir
+    });
+  }
+  if (relManifestPath) {
+    await fs5.promises.rm(upath5.join(tmpDir, "EPUB", relManifestPath), {
+      force: true,
+      recursive: true
+    });
+    delete manifestItem[relManifestPath];
+  }
+  fs5.writeFileSync(
+    upath5.join(tmpDir, "META-INF/container.xml"),
+    EPUB_CONTAINER_XML,
+    "utf8"
+  );
+  Logger.debug(`Generating content.opf`);
+  fs5.writeFileSync(
+    upath5.join(tmpDir, "EPUB/content.opf"),
+    buildEpubPackageDocument({
+      epubVersion,
+      uid,
+      docTitle,
+      docLanguages,
+      manifest,
+      spineItems,
+      manifestItems: Object.values(manifestItem)
+    }),
+    "utf8"
+  );
+  await compressEpub({ target, sourceDir: tmpDir });
+}
+async function writeAsXhtml(dom, absPath) {
+  const xhtml = `${XML_DECLARATION}
+${serializeToXml(dom.window.document)}`;
+  await fs5.promises.writeFile(changeExtname(absPath, ".xhtml"), xhtml, "utf8");
+}
+async function transpileHtmlToXhtml({
+  target,
+  contextDir
+}) {
+  const absPath = upath5.join(contextDir, target);
+  const dom = await getJsdomFromUrlOrFile({ src: absPath });
+  const { document: document2 } = dom.window;
+  document2.documentElement.removeAttribute("xmlns");
+  document2.documentElement.setAttribute("xmlns:epub", EPUB_NS);
+  document2.querySelectorAll("a[href]").forEach((el) => {
+    const href = decodeURI(el.getAttribute("href"));
+    el.setAttribute("href", getRelativeHref(href, target, target));
+  });
+  await writeAsXhtml(dom, absPath);
+  await fs5.promises.unlink(absPath);
+  return {
+    dom,
+    // FIXME: Yes, I recognize this implementation is inadequate.
+    hasMathmlContent: !!document2.querySelector("math"),
+    hasRemoteResources: !!document2.querySelector(
+      '[src^="http://"], [src^="https://"]'
+    ),
+    hasScriptedContent: !!document2.querySelector("script, form"),
+    hasSvgContent: !!document2.querySelector("svg")
+  };
+}
+function replaceWithNavElement(dom, el) {
+  const nav = dom.window.document.createElement("nav");
+  while (el.firstChild) {
+    nav.appendChild(el.firstChild);
+  }
+  for (let i = 0; i < el.attributes.length; i++) {
+    nav.attributes.setNamedItem(el.attributes[i].cloneNode());
+  }
+  el.parentNode?.replaceChild(nav, el);
+  return nav;
+}
+async function processTocDocument({
+  dom,
+  target,
+  contextDir,
+  readingOrder,
+  docLanguages,
+  landmarks
+}) {
+  const { document: document2 } = dom.window;
+  let tocResourceTree = null;
+  if (!document2.querySelector("nav[epub:type]")) {
+    tocResourceTree = parseTocDocument(dom);
+    if (tocResourceTree) {
+      const nav = replaceWithNavElement(dom, tocResourceTree.element);
+      nav.setAttribute("id", TOC_ID);
+      nav.setAttribute("epub:type", "toc");
+    } else {
+      Logger.debug(`Generating toc nav element: ${target}`);
+      const nav = document2.createElement("nav");
+      nav.setAttribute("id", TOC_ID);
+      nav.setAttribute("role", "doc-toc");
+      nav.setAttribute("epub:type", "toc");
+      nav.setAttribute("hidden", "");
+      const h2 = document2.createElement("h2");
+      h2.textContent = TOC_TITLE;
+      nav.appendChild(h2);
+      const ol = document2.createElement("ol");
+      tocResourceTree = {
+        element: nav,
+        children: []
+      };
+      for (const content of readingOrder) {
+        let name = normalizeLocalizableString(content.name, docLanguages);
+        if (!name) {
+          const dom2 = await getJsdomFromUrlOrFile({
+            src: upath5.join(contextDir, changeExtname(content.url, ".xhtml"))
+          });
+          name = dom2.window.document.title;
+        }
+        const li = document2.createElement("li");
+        const a = document2.createElement("a");
+        a.textContent = name;
+        a.href = getRelativeHref(content.url, "", target);
+        li.appendChild(a);
+        ol.appendChild(li);
+        tocResourceTree.children.push({ element: li, label: a });
+      }
+      nav.appendChild(ol);
+      document2.body.appendChild(nav);
+      Logger.debug("Generated toc nav element", nav.outerHTML);
+    }
+    if (landmarks.length > 0) {
+      Logger.debug(`Generating landmark nav element: ${target}`);
+      const nav = document2.createElement("nav");
+      nav.setAttribute("epub:type", "landmarks");
+      nav.setAttribute("id", LANDMARKS_ID);
+      nav.setAttribute("hidden", "");
+      const h2 = document2.createElement("h2");
+      h2.textContent = EPUB_LANDMARKS_TITLE;
+      nav.appendChild(h2);
+      const ol = document2.createElement("ol");
+      for (const { type, href, text } of landmarks) {
+        const li = document2.createElement("li");
+        const a = document2.createElement("a");
+        a.setAttribute("epub:type", type);
+        a.setAttribute("href", getRelativeHref(href, "", target));
+        a.text = text;
+        li.appendChild(a);
+        ol.appendChild(li);
+      }
+      nav.appendChild(ol);
+      document2.body.appendChild(nav);
+      Logger.debug("Generated landmark nav element", nav.outerHTML);
+    }
+  }
+  const publicationLinkEl = document2.querySelector(
+    'link[href][rel="publication"]'
+  );
+  if (publicationLinkEl) {
+    const href = publicationLinkEl.getAttribute("href").trim();
+    if (href.startsWith("#")) {
+      const scriptEl = document2.getElementById(href.slice(1));
+      if (scriptEl?.getAttribute("type") === "application/ld+json") {
+        scriptEl.parentNode?.removeChild(scriptEl);
+      }
+    }
+    publicationLinkEl.parentNode?.removeChild(publicationLinkEl);
+  }
+  const absPath = upath5.join(contextDir, target);
+  await writeAsXhtml(dom, absPath);
+  return { tocResourceTree };
+}
+async function processPagelistDocument({
+  dom,
+  target,
+  contextDir
+}) {
+  const pageListResourceTree = parsePageListDocument(dom);
+  if (pageListResourceTree) {
+    const nav = replaceWithNavElement(dom, pageListResourceTree.element);
+    nav.setAttribute("id", PAGELIST_ID);
+    nav.setAttribute("epub:type", "page-list");
+  }
+  const absPath = upath5.join(contextDir, target);
+  await writeAsXhtml(dom, absPath);
+  return { pageListResourceTree };
+}
+function buildEpubPackageDocument({
+  epubVersion,
+  manifest,
+  uid,
+  docTitle,
+  docLanguages,
+  spineItems,
+  manifestItems
+}) {
+  const slugger = new GithubSlugger();
+  slugger.reset();
+  const bookIdentifier = slugger.slug("bookid");
+  const normalizeDate = (value) => value && `${new Date(value).toISOString().split(".")[0]}Z`;
+  const transformToGenericTextNode = (value, attributes) => [value].flat().filter(Boolean).map((v2) => ({ ...attributes || {}, "#text": `${value}` }));
+  const transformContributor = (contributorMap) => Object.entries(contributorMap).flatMap(
+    ([type, contributor]) => contributor ? [contributor].flat().map((entry, index) => ({
+      _id: slugger.slug(`${type}-${index + 1}`),
+      "#text": typeof entry === "string" ? entry : normalizeLocalizableString(entry.name, docLanguages)
+    })) : []
+  );
+  const itemIdMap = /* @__PURE__ */ new Map();
+  manifestItems.forEach(({ href }) => {
+    itemIdMap.set(href, slugger.slug(href));
+  });
+  const builder = new XMLBuilder({
+    format: true,
+    ignoreAttributes: false,
+    attributeNamePrefix: "_"
+  });
+  return builder.build({
+    "?xml": {
+      _version: "1.0",
+      _encoding: "UTF-8"
+    },
+    package: {
+      _xmlns: "http://www.idpf.org/2007/opf",
+      _version: epubVersion,
+      "_unique-identifier": bookIdentifier,
+      "_xml:lang": docLanguages[0],
+      metadata: {
+        "_xmlns:dc": "http://purl.org/dc/elements/1.1/",
+        "dc:identifier": {
+          _id: bookIdentifier,
+          "#text": uid
+        },
+        "dc:title": docTitle,
+        "dc:language": docLanguages,
+        "dc:creator": transformContributor({
+          // TODO: Define proper order
+          author: manifest.author,
+          creator: manifest.creator,
+          editor: manifest.editor,
+          artist: manifest.artist,
+          illustrator: manifest.illustrator,
+          colorist: manifest.colorist,
+          penciler: manifest.penciler,
+          inker: manifest.inker,
+          letterer: manifest.letterer,
+          translator: manifest.translator,
+          readBy: manifest.readBy
+        }),
+        "dc:publisher": transformContributor({
+          publisher: manifest.publisher
+        }),
+        "dc:contributor": transformContributor({
+          contributor: manifest.contributor
+        }),
+        "dc:date": transformToGenericTextNode(
+          normalizeDate(manifest.datePublished)
+        ),
+        "dc:rights": transformToGenericTextNode(
+          manifest.copyrightHolder && `\xA9 ${manifest.copyrightYear ? `${manifest.copyrightYear} ` : ""}${manifest.copyrightHolder}`
+        ),
+        "dc:subject": transformToGenericTextNode(
+          manifest["dc:subject"] || manifest.subject
+        ),
+        meta: [
+          ...transformToGenericTextNode(
+            normalizeDate(manifest.dateModified || Date.now()),
+            {
+              _property: "dcterms:modified"
+            }
+          ),
+          ...(() => {
+            const coverImage = manifestItems.find(
+              (it) => it.properties === "cover-image"
+            );
+            return coverImage ? [{ _name: "cover", _content: itemIdMap.get(coverImage.href) }] : [];
+          })()
+        ]
+      },
+      manifest: {
+        item: manifestItems.map(({ href, mediaType, properties }) => ({
+          _id: itemIdMap.get(href),
+          _href: encodeURI(href),
+          "_media-type": mediaType,
+          ...properties ? { _properties: properties } : {}
+        }))
+      },
+      spine: {
+        ...manifest.readingProgression ? { "_page-progression-direction": manifest.readingProgression } : {},
+        itemref: [
+          ...spineItems.map(({ href }) => ({
+            _idref: itemIdMap.get(href)
+          }))
+        ]
+      }
+    }
+  });
+}
+async function compressEpub({
+  target,
+  sourceDir
+}) {
+  Logger.debug(`Compressing EPUB: ${target}`);
+  const output = fs5.createWriteStream(target);
+  const archive = archiver("zip", {
+    zlib: { level: 9 }
+    // Compression level
+  });
+  return new Promise((resolve, reject) => {
+    output.on("close", () => {
+      Logger.debug(`Compressed EPUB: ${target}`);
+      resolve();
+    });
+    output.on("error", reject);
+    archive.on("warning", reject);
+    archive.on("error", reject);
+    archive.pipe(output);
+    archive.append("application/epub+zip", {
+      name: "mimetype",
+      // mimetype should not be compressed
+      // https://www.w3.org/TR/epub-33/#sec-zip-container-mime
+      store: true
+    });
+    archive.directory(upath5.join(sourceDir, "META-INF"), "META-INF");
+    archive.directory(upath5.join(sourceDir, "EPUB"), "EPUB");
+    archive.finalize();
+  });
+}
+
+// src/output/webbook.ts
+function sortManifestResources(manifest) {
+  if (!Array.isArray(manifest.resources)) {
+    return;
+  }
+  manifest.resources = [...manifest.resources].sort(
+    (a, b) => (typeof a === "string" ? a : a.url) > (typeof b === "string" ? b : b.url) ? 1 : -1
+  );
+}
+async function prepareWebPublicationDirectory({
+  outputDir
+}) {
+  if (fs6.existsSync(outputDir)) {
+    Logger.debug("going to remove existing webpub", outputDir);
+    await fs6.promises.rm(outputDir, { force: true, recursive: true });
+  }
+  fs6.mkdirSync(outputDir, { recursive: true });
+}
+function transformPublicationManifest(entity, transformer) {
+  const { url: transformUrl } = transformer;
+  const transformUrlOrPublicationLinks = (e) => {
+    if (typeof e === "string") {
+      return transformUrl(e);
+    }
+    const ret2 = { ...e };
+    ret2.url = transformUrl(e.url);
+    return ret2;
+  };
+  const ret = { ...entity };
+  for (const [key, tr] of Object.entries({
+    conformsTo: transformUrl,
+    url: transformUrl,
+    readingOrder: transformUrlOrPublicationLinks,
+    resources: transformUrlOrPublicationLinks,
+    links: transformUrlOrPublicationLinks
+  })) {
+    if (key in ret) {
+      ret[key] = Array.isArray(ret[key]) ? ret[key].map(tr) : tr(ret[key]);
+    }
+  }
+  return ret;
+}
+function decodePublicationManifest(input) {
+  return transformPublicationManifest(input, {
+    url: decodeURI
+  });
+}
+function encodePublicationManifest(input) {
+  return transformPublicationManifest(input, {
+    url: encodeURI
+  });
+}
+function writePublicationManifest(output, options) {
+  const entries = options.entries.map((entry) => ({
+    url: entry.path,
+    ...entry.title && { name: entry.title },
+    ...entry.encodingFormat && { encodingFormat: entry.encodingFormat },
+    ...entry.rel && { rel: entry.rel },
+    ...(entry.rel === "contents" || entry.rel === "cover") && {
+      type: "LinkedResource"
+    }
+  }));
+  const links = [
+    options.links || []
+  ].flat();
+  const resources = [
+    options.resources || []
+  ].flat();
+  if (options.cover) {
+    const mimeType = mime3(options.cover.url);
+    if (mimeType) {
+      resources.push({
+        rel: "cover",
+        url: options.cover.url,
+        name: options.cover.name,
+        encodingFormat: mimeType
+      });
+    } else {
+      Logger.logWarn(
+        `Cover image "${options.cover}" was set in your configuration but couldn\u2019t detect the image metadata. Please check a valid cover file is placed.`
+      );
+    }
+  }
+  const publication = {
+    "@context": ["https://schema.org", "https://www.w3.org/ns/pub-context"],
+    type: "Book",
+    conformsTo: "https://github.com/vivliostyle/vivliostyle-cli",
+    ...options.title && { name: options.title },
+    ...options.author && { author: options.author },
+    ...options.language && { inLanguage: options.language },
+    ...options.readingProgression && {
+      readingProgression: options.readingProgression
+    },
+    dateModified: options.modified,
+    readingOrder: entries,
+    resources,
+    links
+  };
+  const encodedManifest = encodePublicationManifest(publication);
+  Logger.debug(
+    "writePublicationManifest path: %s content: %O",
+    output,
+    encodedManifest
+  );
+  try {
+    assertPubManifestSchema(encodedManifest);
+  } catch (error) {
+    const thrownError = error;
+    throw new DetailError(
+      `Validation of publication manifest failed. Please check the schema: ${output}`,
+      typeof thrownError === "string" ? thrownError : thrownError.stack ?? thrownError.message
+    );
+  }
+  fs6.mkdirSync(upath6.dirname(output), { recursive: true });
+  fs6.writeFileSync(output, JSON.stringify(encodedManifest, null, 2));
+  return publication;
+}
+async function retrieveWebbookEntry({
+  viewerInput,
+  outputDir
+}) {
+  const webbookEntryUrl = viewerInput.webbookPath ? pathToFileURL5(viewerInput.webbookPath).href : viewerInput.webbookEntryUrl;
+  if (/^https?:/i.test(webbookEntryUrl)) {
+    Logger.logUpdate("Fetching remote contents");
+  }
+  const resourceLoader = new ResourceLoader();
+  const dom = await getJsdomFromUrlOrFile({
+    src: webbookEntryUrl,
+    resourceLoader
+  });
+  const entryHtml = viewerInput.webbookPath ? upath6.basename(viewerInput.webbookPath) : decodeURI(dom.window.location.pathname);
+  const { manifest, manifestUrl } = await fetchLinkedPublicationManifest({
+    dom,
+    resourceLoader,
+    baseUrl: webbookEntryUrl
+  }) || {};
+  let pathContains2;
+  if (webbookEntryUrl.startsWith("data:")) {
+    pathContains2 = (url) => false;
+  } else {
+    const rootUrl = /^https?:/i.test(webbookEntryUrl) ? new URL("/", webbookEntryUrl).href : new URL(".", webbookEntryUrl).href;
+    pathContains2 = (url) => !upath6.relative(rootUrl, url).startsWith("..");
+  }
+  const retriever = new Map(resourceLoader.fetcherMap);
+  if (manifest && manifestUrl) {
+    [manifest.resources || []].flat().forEach((v2) => {
+      const url = typeof v2 === "string" ? v2 : v2.url;
+      const fullUrl = new URL(encodeURI(url), manifestUrl).href;
+      if (!pathContains2(fullUrl) || retriever.has(fullUrl)) {
+        return;
+      }
+      const fetchPromise = resourceLoader.fetch(fullUrl);
+      if (fetchPromise && !retriever.has(fullUrl)) {
+        retriever.set(fullUrl, fetchPromise);
+      }
+    });
+    for (const v2 of [manifest.readingOrder || []].flat()) {
+      const url = typeof v2 === "string" ? v2 : v2.url;
+      if (!/\.html?$/.test(url) && !(typeof v2 === "string" || v2.encodingFormat === "text/html")) {
+        continue;
+      }
+      const fullUrl = new URL(encodeURI(url), manifestUrl).href;
+      if (!pathContains2(fullUrl) || fullUrl === webbookEntryUrl) {
+        continue;
+      }
+      const subpathResourceLoader = new ResourceLoader();
+      await getJsdomFromUrlOrFile({
+        src: fullUrl,
+        resourceLoader: subpathResourceLoader,
+        virtualConsole: createVirtualConsole((error) => {
+          Logger.logError(`Failed to fetch webbook resources: ${error.detail}`);
+        })
+      });
+      subpathResourceLoader.fetcherMap.forEach(
+        (v3, k) => !retriever.has(k) && retriever.set(k, v3)
+      );
+    }
+  }
+  const fetchedResources = await ResourceLoader.saveFetchedResources({
+    fetcherMap: retriever,
+    rootUrl: webbookEntryUrl,
+    outputDir,
+    /* v8 ignore next 4 */
+    onError: (error) => {
+      Logger.debug(error);
+      Logger.logError(`Failed to fetch webbook resources: ${error}`);
+    }
+  });
+  if (manifest) {
+    const referencedContents = [
+      ...[manifest.readingOrder || []].flat(),
+      ...[manifest.resources || []].flat()
+    ].map((v2) => typeof v2 === "string" ? v2 : v2.url);
+    manifest.resources = [
+      ...[manifest.resources || []].flat(),
+      ...fetchedResources.filter(
+        ({ url }) => !referencedContents.includes(url)
+      )
+    ];
+    sortManifestResources(manifest);
+  }
+  Logger.debug(
+    "Saved webbook resources",
+    fetchedResources.map((v2) => v2.url)
+  );
+  Logger.debug(
+    "Publication manifest from webbook",
+    manifest && JSON.stringify(manifest, null, 2)
+  );
+  return {
+    entryHtmlFile: upath6.join(
+      outputDir,
+      entryHtml,
+      ...upath6.extname(entryHtml) ? [] : ["index.html"]
+    ),
+    manifest
+  };
+}
+async function supplyWebPublicationManifestForWebbook({
+  entryHtmlFile,
+  outputDir,
+  ...config
+}) {
+  Logger.debug(`Generating publication manifest from HTML: ${entryHtmlFile}`);
+  const dom = await getJsdomFromUrlOrFile({ src: entryHtmlFile });
+  const { document: document2 } = dom.window;
+  const language = config.language || document2.documentElement.lang || void 0;
+  const title = config.title || document2.title || "";
+  const author = config.author || document2.querySelector('meta[name="author"]')?.getAttribute("content") || "";
+  const entry = upath6.relative(outputDir, entryHtmlFile);
+  const allFiles = await glob("**", {
+    cwd: outputDir
+  });
+  const manifest = writePublicationManifest(
+    upath6.join(outputDir, MANIFEST_FILENAME),
+    {
+      title,
+      author,
+      language,
+      readingProgression: config.readingProgression,
+      modified: (/* @__PURE__ */ new Date()).toISOString(),
+      entries: [{ path: entry }],
+      resources: allFiles.filter((f) => f !== entry)
+    }
+  );
+  sortManifestResources(manifest);
+  const link = document2.createElement("link");
+  link.setAttribute("rel", "publication");
+  link.setAttribute("type", "application/ld+json");
+  link.setAttribute(
+    "href",
+    upath6.relative(
+      upath6.dirname(entryHtmlFile),
+      upath6.join(outputDir, MANIFEST_FILENAME)
+    )
+  );
+  document2.head.appendChild(link);
+  await fs6.promises.writeFile(entryHtmlFile, dom.serialize(), "utf8");
+  Logger.debug(
+    "Generated publication manifest from HTML",
+    JSON.stringify(manifest, null, 2)
+  );
+  return manifest;
+}
+async function copyWebPublicationAssets({
+  exportAliases,
+  outputs,
+  copyAsset,
+  themesDir,
+  manifestPath,
+  input,
+  outputDir,
+  entries
+}) {
+  const relExportAliases = exportAliases.map(({ source, target }) => ({
+    source: upath6.relative(input, source),
+    target: upath6.relative(input, target)
+  })).filter(({ source }) => !source.startsWith(".."));
+  const assetMatcher = getAssetMatcher({
+    copyAsset,
+    cwd: input,
+    outputs,
+    themesDir,
+    entries
+  });
+  const webResourceMatcher = getWebPubResourceMatcher({
+    cwd: input,
+    outputs,
+    themesDir,
+    entries,
+    manifestPath,
+    copyAsset
+  });
+  const allFiles = /* @__PURE__ */ new Set([
+    ...await assetMatcher.glob(),
+    ...await webResourceMatcher.glob({
+      // follow symbolic links to copy local theme packages
+      followSymbolicLinks: true
+    })
+  ]);
+  for (const alias of relExportAliases) {
+    allFiles.delete(alias.target);
+  }
+  Logger.debug(
+    "webbook files",
+    JSON.stringify(
+      [...allFiles].map((file) => {
+        const alias = relExportAliases.find(({ source }) => source === file);
+        return alias ? `${file} (alias: ${alias.target})` : file;
+      }),
+      null,
+      2
+    )
+  );
+  const resources = [];
+  let actualManifestPath = upath6.join(
+    outputDir,
+    upath6.relative(input, manifestPath)
+  );
+  for (const file of allFiles) {
+    const alias = relExportAliases.find(({ source }) => source === file);
+    const relTarget = alias?.target || file;
+    resources.push(relTarget);
+    const target = upath6.join(outputDir, relTarget);
+    fs6.mkdirSync(upath6.dirname(target), { recursive: true });
+    await copy2(upath6.join(input, file), target);
+    if (alias && pathEquals(upath6.join(input, alias.source), manifestPath)) {
+      actualManifestPath = target;
+    }
+  }
+  Logger.debug("webbook publication.json", actualManifestPath);
+  const manifest = decodePublicationManifest(
+    JSON.parse(fs6.readFileSync(actualManifestPath, "utf8"))
+  );
+  for (const entry of relExportAliases) {
+    const rewriteAliasPath = (e) => {
+      if (typeof e === "string") {
+        return pathEquals(e, entry.source) ? entry.source : e;
+      }
+      if (pathEquals(e.url, entry.source)) {
+        e.url = entry.target;
+      }
+      return e;
+    };
+    if (manifest.links) {
+      manifest.links = Array.isArray(manifest.links) ? manifest.links.map(rewriteAliasPath) : rewriteAliasPath(manifest.links);
+    }
+    if (manifest.readingOrder) {
+      manifest.readingOrder = Array.isArray(manifest.readingOrder) ? manifest.readingOrder.map(rewriteAliasPath) : rewriteAliasPath(manifest.readingOrder);
+    }
+    if (manifest.resources) {
+      manifest.resources = Array.isArray(manifest.resources) ? manifest.resources.map(rewriteAliasPath) : rewriteAliasPath(manifest.resources);
+    }
+  }
+  const normalizeToUrl = (val) => [val || []].flat().map((e) => typeof e === "string" ? e : e.url);
+  const preDefinedResources = [
+    ...normalizeToUrl(manifest.links),
+    ...normalizeToUrl(manifest.readingOrder),
+    ...normalizeToUrl(manifest.resources)
+  ];
+  manifest.resources = [
+    ...[manifest.resources || []].flat(),
+    ...resources.flatMap((file) => {
+      if (preDefinedResources.includes(file) || // Omit publication.json itself
+      pathEquals(file, upath6.relative(outputDir, actualManifestPath))) {
+        return [];
+      }
+      return file;
+    })
+  ];
+  sortManifestResources(manifest);
+  fs6.writeFileSync(
+    actualManifestPath,
+    JSON.stringify(encodePublicationManifest(manifest), null, 2)
+  );
+  return { manifest, actualManifestPath };
+}
+async function buildWebPublication({
+  target,
+  config
+}) {
+  let outputDir;
+  if (target.format === "webpub") {
+    outputDir = target.path;
+    await prepareWebPublicationDirectory({ outputDir });
+  } else {
+    [outputDir] = await useTmpDirectory();
+  }
+  let entryHtmlFile;
+  let manifest;
+  let actualManifestPath;
+  if (config.viewerInput.type === "webpub") {
+    const ret = await copyWebPublicationAssets({
+      ...config,
+      input: config.workspaceDir,
+      outputDir,
+      manifestPath: config.viewerInput.manifestPath
+    });
+    manifest = ret.manifest;
+    actualManifestPath = ret.actualManifestPath;
+    if (config.input.format === "markdown") {
+      const entry = [manifest.readingOrder].flat()[0];
+      if (entry) {
+        entryHtmlFile = upath6.join(
+          outputDir,
+          typeof entry === "string" ? entry : entry.url
+        );
+      }
+    }
+  } else if (isWebbookConfig(config)) {
+    const ret = await retrieveWebbookEntry({
+      viewerInput: config.viewerInput,
+      outputDir
+    });
+    entryHtmlFile = ret.entryHtmlFile;
+    manifest = ret.manifest || await supplyWebPublicationManifestForWebbook({
+      ...config,
+      entryHtmlFile: ret.entryHtmlFile,
+      outputDir
+    });
+  } else {
+    throw new Error("No entry specified");
+  }
+  if (target.format === "epub") {
+    await exportEpub({
+      webpubDir: outputDir,
+      entryHtmlFile,
+      manifest,
+      relManifestPath: actualManifestPath && upath6.relative(outputDir, actualManifestPath),
+      target: target.path,
+      epubVersion: target.version
+    });
+  }
+  return target.path;
+}
+
+// src/processor/theme.ts
+import Arborist from "@npmcli/arborist";
+import fs7 from "node:fs";
+import upath7 from "upath";
+async function checkThemeInstallationNecessity({
+  themesDir,
+  themeIndexes
+}) {
+  if (!fs7.existsSync(themesDir)) {
+    return [...themeIndexes].some((theme) => theme.type === "package");
+  }
+  const commonOpt = {
+    path: themesDir,
+    lockfileVersion: 3,
+    installLinks: true
+  };
+  const arb = new Arborist(commonOpt);
+  const tree = await arb.loadActual();
+  const pkgs = Array.from(tree.children.keys());
+  return [...themeIndexes].some(
+    (theme) => theme.type === "package" && !pkgs.includes(theme.name)
+  );
+}
+function getLocalThemePaths({
+  themesDir
+}) {
+  const nodeModulesDir = upath7.join(themesDir, "node_modules");
+  if (!fs7.existsSync(nodeModulesDir)) {
+    return [];
+  }
+  const localPaths = [];
+  for (const entry of fs7.readdirSync(nodeModulesDir, { withFileTypes: true })) {
+    if (entry.isSymbolicLink()) {
+      const linkPath = upath7.join(nodeModulesDir, entry.name);
+      const target = fs7.readlinkSync(linkPath);
+      const absoluteTarget = upath7.resolve(nodeModulesDir, target);
+      localPaths.push(absoluteTarget);
+    }
+  }
+  return localPaths;
+}
+async function installThemeDependencies({
+  themesDir,
+  themeIndexes
+}) {
+  fs7.mkdirSync(themesDir, { recursive: true });
+  try {
+    const commonOpt = {
+      path: themesDir,
+      lockfileVersion: 3,
+      installLinks: true
+    };
+    const tree = await new Arborist(commonOpt).buildIdealTree();
+    const existing = Array.from(tree.children.keys());
+    const add = [
+      ...new Set(
+        [...themeIndexes].flatMap(
+          (theme) => theme.type === "package" ? [theme.specifier] : []
+        )
+      )
+    ];
+    const rm = existing.filter((v2) => !add.includes(v2));
+    const opt = { ...commonOpt, rm, add };
+    const arb = new Arborist(opt);
+    const actualTree = await arb.reify(opt);
+    for (const child of actualTree.children.values()) {
+      if (child.resolved?.startsWith("file:")) {
+        const sourcePath = upath7.resolve(themesDir, child.resolved.slice(5));
+        if (fs7.existsSync(child.path)) {
+          fs7.rmSync(child.path, { recursive: true });
+        }
+        const relPath = upath7.relative(upath7.dirname(child.path), sourcePath);
+        fs7.symlinkSync(relPath, child.path, "junction");
+      }
+    }
+  } catch (error) {
+    const thrownError = error;
+    throw new DetailError(
+      "An error occurred during the installation of the theme",
+      thrownError.stack ?? thrownError.message
+    );
+  }
+}
+
+// src/processor/compile.ts
+function locateThemePath(theme, from) {
+  if (theme.type === "uri") {
+    return theme.location;
+  }
+  if (theme.type === "file") {
+    return upath8.relative(from, theme.location);
+  }
+  if (theme.importPath) {
+    return [theme.importPath].flat().map((locator) => {
+      const resolvedPath = upath8.resolve(theme.location, locator);
+      if (!pathContains(theme.location, resolvedPath) || !fs8.existsSync(resolvedPath)) {
+        throw new Error(
+          `Could not find a style path ${theme.importPath} for the theme: ${theme.name}.`
+        );
+      }
+      return upath8.relative(from, resolvedPath);
+    });
+  } else {
+    const pkgJsonPath = upath8.join(theme.location, "package.json");
+    const packageJson = JSON.parse(fs8.readFileSync(pkgJsonPath, "utf8"));
+    const maybeStyle = packageJson?.vivliostyle?.theme?.style ?? packageJson.style ?? packageJson.main;
+    if (!maybeStyle) {
+      throw new DetailError(
+        `Could not find a style file for the theme: ${theme.name}.`,
+        "Please ensure this package satisfies a `vivliostyle.theme.style` property."
+      );
+    }
+    return upath8.relative(from, upath8.join(theme.location, maybeStyle));
+  }
+}
+async function cleanupWorkspace({
+  entryContextDir,
+  workspaceDir,
+  themesDir,
+  entries
+}) {
+  if (pathEquals(workspaceDir, entryContextDir) || pathContains(workspaceDir, entryContextDir) || entries.some(
+    (entry) => entry.source?.type === "file" && pathContains(workspaceDir, entry.source.pathname)
+  )) {
+    return;
+  }
+  Logger.debug("cleanup workspace files", workspaceDir);
+  let movedWorkspacePath;
+  if (pathContains(workspaceDir, themesDir) && fs8.existsSync(themesDir)) {
+    movedWorkspacePath = upath8.join(
+      upath8.dirname(workspaceDir),
+      `.vs-${Date.now()}`
+    );
+    const movedThemePath = upath8.join(
+      movedWorkspacePath,
+      upath8.relative(workspaceDir, themesDir)
+    );
+    fs8.mkdirSync(upath8.dirname(movedThemePath), { recursive: true });
+    registerExitHandler(
+      `Removing the moved workspace directory: ${movedWorkspacePath}`,
+      () => {
+        if (movedWorkspacePath && fs8.existsSync(movedWorkspacePath)) {
+          fs8.rmSync(movedWorkspacePath, { recursive: true, force: true });
+        }
+      }
+    );
+    await move(themesDir, movedThemePath);
+  }
+  await fs8.promises.rm(workspaceDir, { recursive: true, force: true });
+  if (movedWorkspacePath) {
+    await move(movedWorkspacePath, workspaceDir);
+  }
+}
+async function prepareThemeDirectory({
+  themesDir,
+  themeIndexes
+}) {
+  if (fs8.existsSync(upath8.join(themesDir, "packages")) && !fs8.existsSync(upath8.join(themesDir, "node_modules"))) {
+    fs8.renameSync(
+      upath8.join(themesDir, "packages"),
+      upath8.join(themesDir, "node_modules")
+    );
+  }
+  if (await checkThemeInstallationNecessity({ themesDir, themeIndexes })) {
+    Logger.startLogging("Installing theme files");
+    await installThemeDependencies({ themesDir, themeIndexes });
+  }
+  for (const theme of themeIndexes) {
+    if (theme.type === "file" && !pathEquals(theme.source, theme.location)) {
+      fs8.mkdirSync(upath8.dirname(theme.location), { recursive: true });
+      await copy3(theme.source, theme.location);
+    }
+  }
+  return getLocalThemePaths({ themesDir });
+}
+async function transformManuscript(entry, {
+  entryContextDir,
+  workspaceDir,
+  viewerInput: { manifestPath },
+  title,
+  entries,
+  language,
+  vfmOptions,
+  rootUrl
+}) {
+  const source = entry.rel === "contents" || entry.rel === "cover" ? entry.template : entry.source;
+  let content;
+  let resourceLoader;
+  let resourceUrl;
+  const style = entry.themes.flatMap(
+    (theme) => locateThemePath(theme, upath8.dirname(entry.target))
+  );
+  if (source?.type === "file") {
+    if (source.documentProcessor) {
+      const vfile2 = await processMarkdown(
+        source.documentProcessor.processorFactory,
+        source.documentProcessor.metadataReader,
+        source.pathname,
+        {
+          ...vfmOptions,
+          style,
+          title: entry.title,
+          language: language ?? void 0
+        }
+      );
+      content = getJsdomFromString({ html: String(vfile2) });
+    } else if (source.contentType === "text/html" || source.contentType === "application/xhtml+xml") {
+      content = await getJsdomFromUrlOrFile({ src: source.pathname });
+      content = await processManuscriptHtml(content, {
+        style,
+        title: entry.title,
+        contentType: source.contentType,
+        language
+      });
+    } else {
+      if (!pathEquals(source.pathname, entry.target)) {
+        await copy3(source.pathname, entry.target);
+      }
+    }
+  } else if (source?.type === "uri") {
+    resourceUrl = /^https?:/.test(source.href) ? source.href : `${rootUrl}${source.href}`;
+    resourceLoader = new ResourceLoader();
+    try {
+      await getJsdomFromUrlOrFile({
+        src: resourceUrl,
+        resourceLoader,
+        virtualConsole: createVirtualConsole((error) => {
+          Logger.logError(`Failed to fetch resources: ${error.detail}`);
+        })
+      });
+    } catch (error) {
+      throw new DetailError(
+        `Failed to fetch the content from ${resourceUrl}`,
+        error.stack ?? error.message
+      );
+    }
+    const contentFetcher = resourceLoader.fetcherMap.get(resourceUrl);
+    if (contentFetcher) {
+      const buffer = await contentFetcher;
+      const contentType = contentFetcher.response?.headers["content-type"];
+      if (!contentType || new MIMEType2(contentType).essence !== "text/html") {
+        throw new Error(`The content is not an HTML document: ${resourceUrl}`);
+      }
+      content = getJsdomFromString({ html: buffer.toString("utf8") });
+      content = await processManuscriptHtml(content, {
+        style,
+        title: entry.title,
+        contentType: "text/html",
+        language
+      });
+    }
+  } else if (entry.rel === "contents") {
+    content = getJsdomFromString({
+      html: generateDefaultTocHtml({
+        language,
+        title
+      })
+    });
+    content = await processManuscriptHtml(content, {
+      style,
+      title,
+      contentType: "text/html",
+      language
+    });
+  } else if (entry.rel === "cover") {
+    content = getJsdomFromString({
+      html: generateDefaultCoverHtml({ language, title: entry.title })
+    });
+    content = await processManuscriptHtml(content, {
+      style,
+      title: entry.title,
+      contentType: "text/html",
+      language
+    });
+  }
+  if (!content) {
+    return;
+  }
+  if (entry.rel === "contents") {
+    const contentsEntry = entry;
+    const manuscriptEntries = entries.filter(
+      (e) => "source" in e
+    );
+    content = await processTocHtml(content, {
+      entries: manuscriptEntries,
+      manifestPath,
+      distDir: upath8.dirname(contentsEntry.target),
+      tocTitle: contentsEntry.tocTitle,
+      sectionDepth: contentsEntry.sectionDepth,
+      styleOptions: contentsEntry,
+      transform: contentsEntry.transform
+    });
+  }
+  if (entry.rel === "cover") {
+    const coverEntry = entry;
+    content = await processCoverHtml(content, {
+      imageSrc: upath8.relative(
+        upath8.join(
+          entryContextDir,
+          upath8.relative(workspaceDir, coverEntry.target),
+          ".."
+        ),
+        coverEntry.coverImageSrc
+      ),
+      imageAlt: coverEntry.coverImageAlt,
+      styleOptions: coverEntry
+    });
+  }
+  let html;
+  if (content.window.document.contentType === "application/xhtml+xml") {
+    html = `${XML_DECLARATION}
+${serializeToXml2(content.window.document)}`;
+  } else {
+    html = content.serialize();
+  }
+  const htmlBuffer = Buffer.from(html, "utf8");
+  if (!source || source.type === "file" && !pathEquals(source.pathname, entry.target)) {
+    writeFileIfChanged(entry.target, htmlBuffer);
+  }
+  if (source?.type === "uri" && resourceLoader && resourceUrl) {
+    const { response } = resourceLoader.fetcherMap.get(resourceUrl);
+    const contentFetcher = Promise.resolve(
+      htmlBuffer
+    );
+    contentFetcher.abort = () => {
+    };
+    contentFetcher.response = response;
+    resourceLoader.fetcherMap.set(resourceUrl, contentFetcher);
+    await ResourceLoader.saveFetchedResources({
+      fetcherMap: resourceLoader.fetcherMap,
+      rootUrl: resourceUrl,
+      outputDir: source.rootDir
+    });
+  }
+  return html;
+}
+async function generateManifest({
+  entryContextDir,
+  workspaceDir,
+  viewerInput: { manifestPath },
+  title,
+  author,
+  entries,
+  language,
+  readingProgression,
+  cover
+}) {
+  const manifestEntries = entries.map((entry) => ({
+    title: entry.rel === "contents" && entry.tocTitle || entry.title,
+    path: upath8.relative(workspaceDir, entry.target),
+    encodingFormat: !("contentType" in entry) || entry.contentType === "text/markdown" || entry.contentType === "text/x-vivliostyle-custom" || entry.contentType === "text/html" ? void 0 : entry.contentType,
+    rel: entry.rel
+  }));
+  writePublicationManifest(manifestPath, {
+    title,
+    author,
+    language,
+    readingProgression,
+    cover: cover && {
+      url: upath8.relative(entryContextDir, cover.src),
+      name: cover.name
+    },
+    entries: manifestEntries,
+    modified: (/* @__PURE__ */ new Date()).toISOString()
+  });
+}
+async function compile(config) {
+  const tocEntries = [];
+  for (const entry of config.entries) {
+    if (entry.rel === "contents") {
+      tocEntries.push(entry);
+      continue;
+    }
+    await transformManuscript(entry, config);
+  }
+  for (const entry of tocEntries) {
+    await transformManuscript(entry, config);
+  }
+  if (config.viewerInput.needToGenerateManifest) {
+    await generateManifest(config);
+  }
+}
+
+// src/vite/plugin-util.ts
+var headStartTagRe = /<head[^>]*>/i;
+var prependToHead = (html, content) => html.replace(headStartTagRe, (match) => `${match}
+${content}`);
+async function reloadConfig(prevConfig, inlineConfig, resolvedViteConfig) {
+  let config = await loadVivliostyleConfig(inlineConfig) ?? setupConfigFromFlags(inlineConfig);
+  config = mergeInlineConfig(config, inlineConfig);
+  config = mergeConfig(config, {
+    temporaryFilePrefix: prevConfig.temporaryFilePrefix,
+    server: resolvedViteConfig?.server
+  });
+  const taskConfig = resolveTaskConfig(config.tasks[0], config.inlineOptions);
+  return taskConfig;
+}
+
+// src/vite/vite-plugin-dev-server.ts
+function createEntriesRouteLookup(entries, cwd2) {
+  const extns = ["", "html", "htm"];
+  const toAssume = (uri) => {
+    let i = 0, x, len = uri.length - 1;
+    if (uri.charCodeAt(len) === 47) {
+      uri = uri.substring(0, len);
+    }
+    let arr = [], tmp = `${uri}/index`;
+    for (; i < extns.length; i++) {
+      x = extns[i] ? `.${extns[i]}` : "";
+      if (uri) arr.push(uri + x);
+      arr.push(tmp + x);
+    }
+    return arr;
+  };
+  const cache = entries.reduce((acc, e) => {
+    acc[`/${upath9.relative(cwd2, e.target).normalize().replace(/\\+/g, "/")}`] = e;
+    return acc;
+  }, {});
+  return (uri) => {
+    let i = 0, data, arr = toAssume(uri);
+    for (; i < arr.length; i++) {
+      if (data = cache[arr[i]]) return [data, arr[i]];
+    }
+  };
+}
+function getWorkspaceMatcher({
+  workspaceDir,
+  themesDir,
+  viewerInput,
+  themeIndexes,
+  entries,
+  outputs,
+  copyAsset
+}) {
+  if (viewerInput.type === "webpub") {
+    return getWebPubResourceMatcher({
+      outputs,
+      themesDir,
+      entries,
+      cwd: workspaceDir,
+      manifestPath: viewerInput.manifestPath,
+      copyAsset
+    });
+  }
+  let entryFiles = [];
+  switch (viewerInput.type) {
+    case "epub":
+      entryFiles = [
+        upath9.join(
+          upath9.relative(workspaceDir, viewerInput.epubTmpOutputDir),
+          "**"
+        )
+      ];
+      break;
+    case "epub-opf":
+    case "webbook":
+      entryFiles = ["**"];
+      break;
+    default:
+      entryFiles = viewerInput;
+  }
+  return new GlobMatcher([
+    {
+      patterns: entryFiles,
+      ignore: ["node_modules/**"],
+      dot: true,
+      cwd: workspaceDir
+    }
+  ]);
+}
+function vsDevServerPlugin({
+  config: _config,
+  inlineConfig
+}) {
+  let config = _config;
+  let server;
+  let program;
+  const transformCache = /* @__PURE__ */ new Map();
+  let matchProjectDep;
+  async function reload(forceUpdate = false) {
+    const prevConfig = config;
+    config = await reloadConfig(prevConfig, inlineConfig, server?.config);
+    transformCache.clear();
+    const needToUpdateManifest = forceUpdate || // FIXME: More precise comparison
+    JSON.stringify(prevConfig) !== JSON.stringify(config);
+    if (isWebPubConfig(config) && config.viewerInput.needToGenerateManifest && needToUpdateManifest) {
+      await generateManifest(config);
+    }
+    const localThemePaths = await prepareThemeDirectory(config);
+    const entriesLookup = createEntriesRouteLookup(
+      config.entries,
+      config.workspaceDir
+    );
+    const urlMatchRe = new RegExp(
+      `^${escapeRe(config.base)}(/[^?#]*)([?#].*)?$`
+    );
+    const serveWorkspace = sirv(config.workspaceDir, {
+      dev: true,
+      etag: false,
+      dotfiles: true,
+      extensions: []
+    });
+    const serveWorkspaceMatcher = getWorkspaceMatcher(config);
+    const serveAssets = sirv(config.entryContextDir, {
+      dev: true,
+      etag: false,
+      extensions: []
+    });
+    const serveAssetsMatcher = getAssetMatcher({
+      ...config,
+      cwd: config.entryContextDir
+    });
+    program = {
+      entriesLookup,
+      urlMatchRe,
+      serveWorkspace,
+      serveWorkspaceMatcher,
+      serveAssets,
+      serveAssetsMatcher
+    };
+    if (needToUpdateManifest) {
+      Logger.debug(
+        "dev-server > serveWorkspaceMatcher %O",
+        serveWorkspaceMatcher.matcherConfig
+      );
+      Logger.debug(
+        "dev-server > serveAssetsMatcher %O",
+        serveAssetsMatcher.matcherConfig
+      );
+    }
+    const configPath = locateVivliostyleConfig(inlineConfig);
+    const projectDeps = [];
+    if (configPath) {
+      projectDeps.push(configPath);
+      server?.watcher.add(configPath);
+    }
+    if (config.viewerInput.type === "webpub") {
+      projectDeps.push(config.viewerInput.manifestPath);
+      server?.watcher.add(config.viewerInput.manifestPath);
+    }
+    const flattenWatchTarget = (themes) => [...themes].flatMap((theme) => {
+      if (theme.type === "file") {
+        return [theme.source];
+      }
+      if (theme.type === "package" && !theme.registry) {
+        return [theme.specifier];
+      }
+      return [];
+    });
+    const prevThemeFiles = flattenWatchTarget(prevConfig.themeIndexes);
+    const themeFiles = flattenWatchTarget(config.themeIndexes);
+    server?.watcher.unwatch(
+      prevThemeFiles.filter((target) => !themeFiles.includes(target))
+    );
+    server?.watcher.add(themeFiles);
+    server?.watcher.add(localThemePaths);
+    projectDeps.push(...themeFiles, ...localThemePaths);
+    matchProjectDep = (pathname) => projectDeps.some(
+      (dep) => pathEquals(dep, pathname) || pathContains(dep, pathname)
+    );
+  }
+  async function transform(entry, host) {
+    if (!isWebPubConfig(config)) {
+      return;
+    }
+    const rootUrl = host ? `${server?.config.server.https ? "https" : "http"}://${host}` : config.rootUrl;
+    const promise = (async () => {
+      try {
+        const html = await transformManuscript(entry, { ...config, rootUrl });
+        if (!html) {
+          transformCache.delete(entry.target);
+          return;
+        }
+        const etag = `W/"${Date.now()}"`;
+        if (entry.source?.type === "file") {
+          server?.watcher.add(entry.source.pathname);
+        }
+        return { content: html, etag };
+      } catch (error) {
+        server?.config.logger.error(getFormattedError(error));
+        transformCache.delete(entry.target);
+        return;
+      }
+    })();
+    transformCache.set(entry.target, promise);
+    return await promise;
+  }
+  async function transformAll(host) {
+    const tocEntries = [];
+    for (const entry of config.entries) {
+      if (entry.rel === "contents") {
+        tocEntries.push(entry);
+        continue;
+      }
+      await transform(entry, host);
+    }
+    for (const entry of tocEntries) {
+      await transform(entry, host);
+    }
+  }
+  async function invalidate(entry) {
+    const cwd2 = pathToFileURL6(config.workspaceDir);
+    const target = pathToFileURL6(entry.target);
+    if (target.href.indexOf(cwd2.href) !== 0) {
+      return;
+    }
+    transformCache.delete(entry.target);
+    config.entries.filter((entry2) => entry2.rel === "contents").forEach((entry2) => {
+      transformCache.delete(entry2.target);
+    });
+    server?.ws.send({
+      type: "full-reload",
+      path: target.href.slice(cwd2.href.length)
+    });
+  }
+  const devServerMiddleware = async function vivliostyleDevServerMiddleware(req, res, next) {
+    if (!program) {
+      return next();
+    }
+    const { entriesLookup, urlMatchRe } = program;
+    const [_, pathname, qs] = decodeURI(req.url).match(urlMatchRe) ?? [];
+    const match = pathname && entriesLookup(pathname);
+    if (!match) {
+      return next();
+    }
+    const [entry, expected] = match;
+    if (pathname !== expected) {
+      res.statusCode = 301;
+      res.setHeader("Location", `${expected}${qs || ""}`);
+      return res.end();
+    }
+    Logger.debug("dev-server > request %s", pathname);
+    const cachePromise = transformCache.get(entry.target);
+    if (cachePromise) {
+      const cached = await cachePromise;
+      if (!cached) {
+        return next();
+      }
+      if (req.headers["if-none-match"] === cached.etag) {
+        res.statusCode = 304;
+        return res.end();
+      } else {
+        res.statusCode = 200;
+        res.setHeader("Content-Type", "text/html;charset=utf-8");
+        res.setHeader("Cache-Control", "no-cache");
+        res.setHeader("Etag", cached.etag);
+        return res.end(cached.content);
+      }
+    }
+    const { host } = req.headers;
+    if (entry.rel === "contents") {
+      await transformAll(host);
+    }
+    const result = await transform(entry, host);
+    if (!result) {
+      return next();
+    }
+    res.statusCode = 200;
+    res.setHeader("Content-Type", "text/html;charset=utf-8");
+    res.setHeader("Cache-Control", "no-cache");
+    res.setHeader("Etag", result.etag);
+    return res.end(result.content);
+  };
+  const serveWorkspaceMiddleware = async function vivliostyleServeWorkspaceMiddleware(req, res, next) {
+    if (!config || !program) {
+      return next();
+    }
+    const {
+      urlMatchRe,
+      serveWorkspace,
+      serveWorkspaceMatcher,
+      serveAssets,
+      serveAssetsMatcher
+    } = program;
+    const [_, pathname] = decodeURI(req.url).match(urlMatchRe) ?? [];
+    if (!pathname) {
+      return next();
+    }
+    const handleWorkspace = (next2) => {
+      if (!serveWorkspaceMatcher.match(pathname.slice(1))) {
+        return next2();
+      }
+      Logger.debug("dev-server > serveWorkspace %s", pathname);
+      const url = req.url;
+      req.url = req.url.slice(config.base.length);
+      return serveWorkspace(req, res, () => {
+        req.url = url;
+        next2();
+      });
+    };
+    const handleAssets = (next2) => {
+      if (!serveAssetsMatcher.match(pathname.slice(1))) {
+        return next2();
+      }
+      Logger.debug("dev-server > serveAssets %s", pathname);
+      const url = req.url;
+      req.url = url.slice(config.base.length);
+      return serveAssets(req, res, () => {
+        req.url = url;
+        next2();
+      });
+    };
+    handleWorkspace(() => handleAssets(next));
+  };
+  return {
+    name: "vivliostyle:dev-server",
+    enforce: "pre",
+    configureServer(viteServer) {
+      server = viteServer;
+      const requestReload = debounce(async () => {
+        await reload();
+        viteServer.ws.send({
+          type: "full-reload",
+          path: "*"
+        });
+      }, 200);
+      const handleUpdate = (pathname) => {
+        if (!matchProjectDep?.(pathname)) {
+          return;
+        }
+        requestReload();
+      };
+      viteServer.watcher.on("add", handleUpdate);
+      viteServer.watcher.on("change", handleUpdate);
+      viteServer.watcher.on("unlink", handleUpdate);
+      return () => {
+        viteServer.middlewares.use(devServerMiddleware);
+        viteServer.middlewares.use(serveWorkspaceMiddleware);
+      };
+    },
+    configurePreviewServer(viteServer) {
+      return () => {
+        viteServer.middlewares.use(
+          config.base,
+          sirv(config.workspaceDir, { dev: true, etag: false, extensions: [] })
+        );
+      };
+    },
+    async buildStart() {
+      await reload(true);
+      await transformAll(void 0);
+    },
+    async handleHotUpdate(ctx) {
+      const entry = config?.entries.find(
+        (e) => e.source?.type === "file" && e.source.pathname === ctx.file || !e.source && e.target === ctx.file
+      );
+      if (config && entry) {
+        await invalidate(entry);
+      }
+    }
+  };
+}
+
+// src/vite/vite-plugin-static-serve.ts
+import sirv2 from "sirv";
+import upath10 from "upath";
+import "vite";
+function vsStaticServePlugin({
+  config: _config,
+  inlineConfig
+}) {
+  let config = _config;
+  const createMiddlewares = () => {
+    if (typeof config.serverRootDir !== "string") {
+      return [];
+    }
+    return Object.entries(config.static).flatMap(
+      ([base, dirs]) => dirs.map(
+        (dir) => [
+          base,
+          sirv2(upath10.resolve(config.serverRootDir, dir), {
+            dev: true,
+            etag: false
+          })
+        ]
+      )
+    );
+  };
+  return {
+    name: "vivliostyle:static-serve",
+    apply: () => Boolean(inlineConfig.enableStaticServe),
+    configureServer(viteServer) {
+      return () => {
+        createMiddlewares().forEach(([base, middleware]) => {
+          viteServer.middlewares.use(base, middleware);
+        });
+      };
+    },
+    configurePreviewServer(viteServer) {
+      return () => {
+        createMiddlewares().forEach(([base, middleware]) => {
+          viteServer.middlewares.use(base, middleware);
+        });
+      };
+    }
+  };
+}
+
+// src/vite/vite-plugin-viewer.ts
+import fs9 from "node:fs";
+import sirv3 from "sirv";
+import upath11 from "upath";
+import "vite";
+var viewerClientId = "@vivliostyle:viewer:client";
+var viewerClientRequestPath = `/${viewerClientId}`;
+var viewerClientContent = (
+  /* js */
+  `
+if (import.meta.hot) {
+  import.meta.hot.on('vite:beforeFullReload', (e) => {
+    location.reload();
+  });
+}`
+);
+function vsViewerPlugin(_) {
+  const serveRootDir = upath11.join(viewerRoot, "lib");
+  const serve = sirv3(serveRootDir, { dev: false, etag: true });
+  let cachedIndexHtml;
+  const middleware = async function vivliostyleViewerMiddleware(req, res, next) {
+    if (req.url === "/" || req.url === "/index.html") {
+      cachedIndexHtml ??= prependToHead(
+        fs9.readFileSync(upath11.join(serveRootDir, "index.html"), "utf-8"),
+        `<script type="module" src="${viewerClientRequestPath}"></script>`
+      );
+      res.statusCode = 200;
+      res.setHeader("Content-Type", "text/html;charset=utf-8");
+      res.setHeader("Cache-Control", "no-cache");
+      return res.end(cachedIndexHtml);
+    } else {
+      return serve(req, res, next);
+    }
+  };
+  return {
+    name: "vivliostyle:viewer",
+    config() {
+      return {
+        optimizeDeps: {
+          exclude: ["@vivliostyle/viewer"]
+        }
+      };
+    },
+    configureServer(viteServer) {
+      viteServer.middlewares.use(VIEWER_ROOT_PATH, middleware);
+    },
+    configurePreviewServer(viteServer) {
+      viteServer.middlewares.use(VIEWER_ROOT_PATH, serve);
+    },
+    load(id) {
+      if (id === viewerClientRequestPath) {
+        return viewerClientContent;
+      }
+    }
+  };
+}
+
+// src/server.ts
+function getViewerParams(src, {
+  size,
+  cropMarks,
+  bleed,
+  cropOffset,
+  css,
+  customStyle,
+  customUserStyle,
+  singleDoc,
+  quick,
+  viewerParam,
+  base
+}) {
+  const pageSizeValue = size && ("format" in size ? size.format : `${size.width} ${size.height}`);
+  function escapeParam(url) {
+    return url.replace(/&/g, "%26");
+  }
+  let viewerParams = src ? `src=${escapeParam(src)}` : "";
+  viewerParams += `&bookMode=${!singleDoc}&renderAllPages=${!quick}`;
+  if (customStyle) {
+    const param = isValidUri(customStyle) ? customStyle : upath12.posix.join(base, customStyle);
+    viewerParams += `&style=${escapeParam(param)}`;
+  }
+  if (customUserStyle) {
+    const param = isValidUri(customUserStyle) ? customUserStyle : upath12.posix.join(base, customUserStyle);
+    viewerParams += `&userStyle=${escapeParam(param)}`;
+  }
+  if (pageSizeValue || cropMarks || bleed || cropOffset || css) {
+    let pageStyle = "@page{";
+    if (pageSizeValue) {
+      pageStyle += `size:${pageSizeValue};`;
+    }
+    if (cropMarks) {
+      pageStyle += `marks:crop cross;`;
+    }
+    if (bleed || cropMarks) {
+      pageStyle += `bleed:${bleed ?? "3mm"};`;
+    }
+    if (cropOffset) {
+      pageStyle += `crop-offset:${cropOffset};`;
+    }
+    pageStyle += "}";
+    viewerParams += `&style=data:,/*<viewer>*/${encodeURIComponent(
+      pageStyle
+    )}/*</viewer>*/${encodeURIComponent(css ?? "")}`;
+  }
+  if (viewerParam) {
+    viewerParams += `&${viewerParam}`;
+  }
+  return viewerParams;
+}
+async function getSourceUrl({
+  viewerInput,
+  base,
+  workspaceDir,
+  rootUrl
+}) {
+  let input;
+  switch (viewerInput.type) {
+    case "webpub":
+      input = viewerInput.manifestPath;
+      break;
+    case "webbook":
+      input = viewerInput.webbookEntryUrl;
+      break;
+    case "epub-opf":
+      input = viewerInput.epubOpfPath;
+      break;
+    case "epub": {
+      if (!fs10.existsSync(viewerInput.epubTmpOutputDir)) {
+        await openEpub(viewerInput.epubPath, viewerInput.epubTmpOutputDir);
+      }
+      input = getDefaultEpubOpfPath(viewerInput.epubTmpOutputDir);
+      break;
+    }
+    default:
+      input = viewerInput;
+  }
+  return (isValidUri(input) ? new URL2(input) : new URL2(
+    upath12.posix.join(base, upath12.relative(workspaceDir, input)),
+    rootUrl
+  )).href;
+}
+async function getViewerFullUrl({
+  viewerInput,
+  base,
+  workspaceDir,
+  rootUrl,
+  viewer,
+  ...config
+}) {
+  const viewerUrl = viewer ? new URL2(viewer) : new URL2(`${VIEWER_ROOT_PATH}/index.html`, rootUrl);
+  const sourceUrl = await getSourceUrl({
+    viewerInput,
+    base,
+    workspaceDir,
+    rootUrl
+  });
+  const viewerParams = getViewerParams(
+    sourceUrl === EMPTY_DATA_URI ? void 0 : sourceUrl,
+    { base, ...config }
+  );
+  viewerUrl.hash = "";
+  return `${viewerUrl.href}#${viewerParams}`;
+}
+async function createViteServer({
+  config,
+  viteConfig,
+  inlineConfig,
+  mode
+}) {
+  const viteInlineConfig = {
+    clearScreen: false,
+    configFile: false,
+    appType: "custom",
+    plugins: [
+      vsDevServerPlugin({ config, inlineConfig }),
+      vsViewerPlugin({ config, inlineConfig }),
+      vsBrowserPlugin({ config, inlineConfig }),
+      vsStaticServePlugin({ config, inlineConfig })
+    ],
+    server: viteConfig.server,
+    preview: viteConfig.preview,
+    customLogger: viteConfig.customLogger,
+    cacheDir: viteConfig.cacheDir,
+    root: viteConfig.root
+  };
+  Logger.debug("createViteServer > viteInlineConfig %O", viteInlineConfig);
+  if (config.serverRootDir === config.workspaceDir) {
+    const { cacheDir } = viteInlineConfig;
+    registerExitHandler("Removing the Vite cacheDir", () => {
+      if (fs10.existsSync(cacheDir)) {
+        fs10.rmSync(cacheDir, { recursive: true });
+      }
+    });
+  }
+  if (mode === "preview") {
+    return await createServer(viteInlineConfig);
+  } else {
+    return await preview(viteInlineConfig);
+  }
+}
+
+// src/vite/vite-plugin-browser.ts
+function vsBrowserPlugin({
+  config: _config,
+  inlineConfig
+}) {
+  let config = _config;
+  let server;
+  let closeBrowser;
+  async function handlePageClose() {
+    await server?.close();
+    runExitHandlers();
+  }
+  async function openPreviewPage() {
+    const locale = await getOsLocale();
+    const url = await getViewerFullUrl(config);
+    const { page, browser } = await launchPreview({
+      mode: "preview",
+      url,
+      config,
+      /* v8 ignore next 4 */
+      onPageOpen: async (page2) => {
+        page2.on("close", handlePageClose);
+      }
+    });
+    if (!import.meta.env?.VITEST) {
+      await page.evaluate((locale2) => {
+        window.localStorage.setItem("i18nextLng", locale2);
+      }, locale);
+    }
+    await page.bringToFront();
+    if (!import.meta.env?.VITEST) {
+      await page.evaluate(() => {
+        document.querySelector("#vivliostyle-input-url")?.focus();
+      });
+    }
+    closeBrowser = () => {
+      page.off("close", handlePageClose);
+      browser.close();
+    };
+  }
+  return {
+    name: "vivliostyle:browser",
+    apply: () => Boolean(inlineConfig.openViewer),
+    configureServer(viteServer) {
+      server = viteServer;
+      const _listen = viteServer.listen;
+      viteServer.listen = async (...args) => {
+        const server2 = await _listen(...args);
+        config = await reloadConfig(config, inlineConfig, server2.config);
+        await openPreviewPage();
+        return server2;
+      };
+    },
+    closeBundle() {
+      closeBrowser?.();
+    }
+  };
+}
+
+export {
+  loadVivliostyleConfig,
+  warnDeprecatedConfig,
+  mergeConfig,
+  mergeInlineConfig,
+  isWebPubConfig,
+  resolveTaskConfig,
+  launchPreview,
+  vsBrowserPlugin,
+  buildWebPublication,
+  cleanupWorkspace,
+  prepareThemeDirectory,
+  compile,
+  vsDevServerPlugin,
+  vsStaticServePlugin,
+  vsViewerPlugin,
+  getSourceUrl,
+  getViewerFullUrl,
+  createViteServer
+};
+//# sourceMappingURL=chunk-BYT766IR.js.map
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-BYT766IR.js.map b/package/dist/chunk-BYT766IR.js.map
--- a/package/dist/chunk-BYT766IR.js.map	1970-01-01 09:00:00.000000000 +0900
+++ b/package/dist/chunk-BYT766IR.js.map	1985-10-26 17:15:00.000000000 +0900
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/config/load.ts","../src/config/merge.ts","../src/config/resolve.ts","../src/processor/markdown.ts","../src/vite/vite-plugin-browser.ts","../src/browser.ts","../src/server.ts","../src/vite/vite-plugin-dev-server.ts","../src/processor/compile.ts","../src/output/webbook.ts","../src/processor/html.tsx","../src/output/epub.ts","../src/processor/theme.ts","../src/vite/plugin-util.ts","../src/vite/vite-plugin-static-serve.ts","../src/vite/vite-plugin-viewer.ts"],"sourcesContent":["import fs from 'node:fs';\nimport { createRequire } from 'node:module';\nimport { pathToFileURL } from 'node:url';\nimport upath from 'upath';\nimport * as v from 'valibot';\nimport { Logger } from '../logger.js';\nimport {\n  cwd as defaultRoot,\n  DetailError,\n  parseJsonc,\n  prettifySchemaError,\n} from '../util.js';\nimport {\n  type InlineOptions,\n  type ParsedVivliostyleConfigSchema,\n  VivliostyleConfigSchema,\n} from './schema.js';\n\nconst require = createRequire(import.meta.url);\n\nexport function locateVivliostyleConfig({\n  config,\n  cwd = defaultRoot,\n}: Pick<InlineOptions, 'config' | 'cwd'>) {\n  if (config) {\n    return upath.resolve(cwd, config);\n  }\n  return ['.js', '.mjs', '.cjs', '.json']\n    .map((ext) => upath.join(cwd, `vivliostyle.config${ext}`))\n    .find((p) => fs.existsSync(p));\n}\n\nexport async function loadVivliostyleConfig({\n  config,\n  configData,\n  cwd,\n}: Pick<InlineOptions, 'config' | 'configData' | 'cwd'>): Promise<\n  ParsedVivliostyleConfigSchema | undefined\n> {\n  if (configData) {\n    return v.parse(VivliostyleConfigSchema, configData);\n  }\n\n  const absPath = locateVivliostyleConfig({ config, cwd });\n  if (!absPath) {\n    return;\n  }\n\n  let parsedConfig: unknown;\n  let jsonRaw: string | undefined;\n  try {\n    if (upath.extname(absPath) === '.json') {\n      jsonRaw = fs.readFileSync(absPath, 'utf8');\n      parsedConfig = parseJsonc(jsonRaw);\n    } else {\n      // Clear require cache to reload CJS config files\n      delete require.cache[require.resolve(absPath)];\n      const url = pathToFileURL(absPath);\n      // Invalidate cache for ESM config files\n      // https://github.com/nodejs/node/issues/49442\n      url.search = `version=${Date.now()}`;\n      parsedConfig = (await import(/* @vite-ignore */ url.href)).default;\n      jsonRaw = JSON.stringify(parsedConfig, null, 2);\n    }\n  } catch (error) {\n    const thrownError = error as Error;\n    throw new DetailError(\n      `An error occurred on loading a config file: ${absPath}`,\n      thrownError.stack ?? thrownError.message,\n    );\n  }\n\n  const result = v.safeParse(VivliostyleConfigSchema, parsedConfig);\n  if (result.success) {\n    const { tasks, inlineOptions } = result.output;\n    return {\n      tasks,\n      inlineOptions: {\n        ...inlineOptions,\n        cwd: cwd ?? defaultRoot,\n        config: absPath,\n      },\n    };\n  } else {\n    const errorString = prettifySchemaError(jsonRaw, result.issues);\n    throw new DetailError(\n      `Validation of vivliostyle config failed. Please check the schema: ${config}`,\n      errorString,\n    );\n  }\n}\n\nexport function warnDeprecatedConfig(config: ParsedVivliostyleConfigSchema) {\n  if (config.tasks.some((task) => task.includeAssets)) {\n    Logger.logWarn(\n      \"'includeAssets' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'copyAsset.includes' property instead.\",\n    );\n  }\n\n  if (config.tasks.some((task) => task.tocTitle)) {\n    Logger.logWarn(\n      \"'tocTitle' property of Vivliostyle config was deprecated and will be removed in a future release. Please use 'toc.title' property instead.\",\n    );\n  }\n\n  if (config.tasks.some((task) => task.http)) {\n    Logger.logWarn(\n      \"'http' property of Vivliostyle config was deprecated and will be removed in a future release. This option is enabled by default, and the file protocol is no longer supported.\",\n    );\n  }\n}\n","import type {\n  InlineOptions,\n  ParsedBuildTask,\n  ParsedVivliostyleConfigSchema,\n  ParsedVivliostyleInlineConfig,\n} from './schema.js';\n\nconst pruneObject = <T extends Record<string, unknown>>(obj: T) => {\n  const ret = { ...obj };\n  for (const key in ret) {\n    if (ret[key] === undefined || ret[key] === null) {\n      delete ret[key];\n    }\n  }\n  return ret as { [K in keyof T]: NonNullable<T[K]> };\n};\n\nexport function mergeConfig(\n  base: ParsedVivliostyleConfigSchema,\n  override: Partial<ParsedBuildTask>,\n): ParsedVivliostyleConfigSchema {\n  return {\n    tasks: base.tasks.map((task, i) => ({\n      ...pruneObject(task),\n      ...pruneObject(override),\n    })),\n    inlineOptions: base.inlineOptions,\n  };\n}\n\ntype HasOnlyInlineOptionsProperties<T> =\n  Exclude<keyof T, keyof InlineOptions> extends never ? T : never;\n\nexport function mergeInlineConfig(\n  { tasks, inlineOptions }: ParsedVivliostyleConfigSchema,\n  inlineConfig: ParsedVivliostyleInlineConfig,\n): ParsedVivliostyleConfigSchema {\n  const {\n    theme,\n    size,\n    pressReady,\n    title,\n    author,\n    language,\n    readingProgression,\n    timeout,\n    image,\n    viewer,\n    viewerParam,\n    browser,\n    output,\n    renderMode,\n    preflight,\n    preflightOption,\n    vite,\n    viteConfigFile,\n    host,\n    port,\n    ...overrideInlineOptions\n  } = inlineConfig;\n\n  return {\n    tasks: tasks.map((task) => ({\n      ...pruneObject(task),\n      ...pruneObject({\n        theme,\n        size,\n        pressReady,\n        title,\n        author,\n        language,\n        readingProgression,\n        timeout,\n        image,\n        viewer,\n        viewerParam,\n        browser,\n        vite,\n        viteConfigFile,\n      }),\n      output: (output?.length ? output : task.output)?.map((o) => ({\n        ...pruneObject(o),\n        ...pruneObject({\n          renderMode,\n          preflight,\n          preflightOption,\n        }),\n      })),\n      server: {\n        ...pruneObject(task.server ?? {}),\n        ...pruneObject({ host, port }),\n      },\n    })),\n    inlineOptions: {\n      ...pruneObject(inlineOptions),\n      ...pruneObject({\n        renderMode,\n        preflight,\n        preflightOption,\n      }),\n      ...pruneObject(\n        overrideInlineOptions satisfies HasOnlyInlineOptionsProperties<\n          typeof overrideInlineOptions\n        >,\n      ),\n    },\n  };\n}\n","import {\n  type Metadata,\n  readMetadata,\n  type StringifyMarkdownOptions,\n  VFM,\n} from '@vivliostyle/vfm';\nimport { lookup as mime } from 'mime-types';\nimport fs from 'node:fs';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport npa from 'npm-package-arg';\nimport type { Processor } from 'unified';\nimport upath from 'upath';\nimport type { ResolvedConfig as ResolvedViteConfig, UserConfig } from 'vite';\nimport {\n  ArticleEntryConfig,\n  BrowserType,\n  ContentsEntryConfig,\n  CoverEntryConfig,\n  EntryConfig,\n  type InputFormat,\n  StructuredDocument,\n  StructuredDocumentSection,\n  ThemeConfig,\n} from '../config/schema.js';\nimport {\n  cliVersion,\n  CONTAINER_LOCAL_HOSTNAME,\n  CONTAINER_URL,\n  COVER_HTML_FILENAME,\n  COVER_HTML_IMAGE_ALT,\n  DEFAULT_BROWSER_VERSIONS,\n  EPUB_OUTPUT_VERSION,\n  MANIFEST_FILENAME,\n  TOC_FILENAME,\n  TOC_TITLE,\n} from '../const.js';\nimport { Logger } from '../logger.js';\nimport { readMarkdownMetadata } from '../processor/markdown.js';\nimport {\n  cwd as defaultCwd,\n  detectBrowserPlatform,\n  getEpubRootDir,\n  isInContainer,\n  isValidUri,\n  pathContains,\n  pathEquals,\n  readJSON,\n  statFileSync,\n  touchTmpFile,\n} from '../util.js';\nimport type { InlineOptions, ParsedBuildTask } from './schema.js';\n\nexport type ParsedTheme = UriTheme | FileTheme | PackageTheme;\n\nexport interface UriTheme {\n  type: 'uri';\n  name: string;\n  location: string;\n}\n\nexport interface FileTheme {\n  type: 'file';\n  name: string;\n  source: string;\n  location: string;\n}\n\nexport interface PackageTheme {\n  type: 'package';\n  name: string;\n  specifier: string;\n  location: string;\n  registry: boolean;\n  importPath?: string | string[];\n}\n\nexport type EntrySource = FileEntrySource | UriEntrySource;\n\nexport interface DocumentProcessor {\n  processorFactory: DocumentProcessorFactory;\n  metadataReader: DocumentMetadataReader;\n}\n\nexport interface FileEntrySource {\n  type: 'file';\n  pathname: string;\n  contentType: ManuscriptMediaType;\n  documentProcessor?: DocumentProcessor;\n}\n\nexport interface UriEntrySource {\n  type: 'uri';\n  href: string;\n  rootDir: string;\n}\n\nexport const manuscriptMediaTypes = [\n  'text/markdown',\n  'text/html',\n  'text/plain',\n  'application/xhtml+xml',\n  // a special MIME type indicates that a custom processor is used\n  'text/x-vivliostyle-custom',\n] as const;\nexport type ManuscriptMediaType = (typeof manuscriptMediaTypes)[number];\n\nexport interface ManuscriptEntry {\n  contentType: ManuscriptMediaType;\n  title?: string;\n  themes: ParsedTheme[];\n  source: EntrySource;\n  template?: undefined;\n  target: string;\n  rel?: string | string[];\n}\n\nexport interface ContentsEntry {\n  rel: 'contents';\n  title?: string;\n  themes: ParsedTheme[];\n  source?: undefined;\n  template?: EntrySource;\n  target: string;\n  tocTitle: string;\n  sectionDepth: number;\n  transform: {\n    transformDocumentList:\n      | ((\n          nodeList: StructuredDocument[],\n        ) => (propsList: { children: any }[]) => any)\n      | undefined;\n    transformSectionList:\n      | ((\n          nodeList: StructuredDocumentSection[],\n        ) => (propsList: { children: any }[]) => any)\n      | undefined;\n  };\n  pageBreakBefore?: 'left' | 'right' | 'recto' | 'verso';\n  pageCounterReset?: number;\n}\n\nexport interface CoverEntry {\n  rel: 'cover';\n  title?: string;\n  themes: ParsedTheme[];\n  source?: undefined;\n  template?: EntrySource;\n  target: string;\n  coverImageSrc: string;\n  coverImageAlt: string;\n  pageBreakBefore?: 'left' | 'right' | 'recto' | 'verso';\n}\n\nexport type ParsedEntry = ManuscriptEntry | ContentsEntry | CoverEntry;\n\nexport interface WebPublicationManifestConfig {\n  type: 'webpub';\n  manifestPath: string;\n  needToGenerateManifest: boolean;\n}\n\nexport interface EpubEntryConfig {\n  type: 'epub';\n  epubPath: string;\n  epubTmpOutputDir: string;\n}\n\nexport interface EpubOpfEntryConfig {\n  type: 'epub-opf';\n  epubOpfPath: string;\n}\n\nexport interface WebBookEntryConfig {\n  type: 'webbook';\n  webbookEntryUrl: string;\n  webbookPath: string | undefined;\n}\n\nexport type ViewerInputConfig =\n  | WebPublicationManifestConfig\n  | EpubEntryConfig\n  | EpubOpfEntryConfig\n  | WebBookEntryConfig;\n\nexport interface PdfOutput {\n  format: 'pdf';\n  path: string;\n  renderMode: 'local' | 'docker';\n  preflight: 'press-ready' | 'press-ready-local' | undefined;\n  preflightOption: string[];\n}\n\nexport interface WebPublicationOutput {\n  format: 'webpub';\n  path: string;\n}\n\nexport interface EpubOutput {\n  format: 'epub';\n  path: string;\n  version: '3.0'; // Reserved for future updates\n}\n\nexport type OutputConfig = PdfOutput | WebPublicationOutput | EpubOutput;\n\nexport type PageSize = { format: string } | { width: string; height: string };\n\nexport type DocumentProcessorFactory = (\n  options: StringifyMarkdownOptions,\n  metadata: Metadata,\n) => Processor;\n\nexport type DocumentMetadataReader = (content: string) => Metadata;\n\nexport const UseTemporaryServerRoot = Symbol('UseTemporaryServerRoot');\nexport type UseTemporaryServerRoot = typeof UseTemporaryServerRoot;\n\nexport type ResolvedTaskConfig = {\n  serverRootDir: string | UseTemporaryServerRoot;\n  entryContextDir: string;\n  workspaceDir: string;\n  themesDir: string;\n  entries: ParsedEntry[];\n  input: {\n    format: InputFormat;\n    entry: string;\n  };\n  viewerInput: ViewerInputConfig;\n  outputs: OutputConfig[];\n  themeIndexes: Set<ParsedTheme>;\n  copyAsset: {\n    includes: string[];\n    excludes: string[];\n    fileExtensions: string[];\n  };\n  exportAliases: {\n    source: string;\n    target: string;\n  }[];\n  temporaryFilePrefix: string;\n  size: PageSize | undefined;\n  cropMarks: boolean;\n  bleed: string | undefined;\n  cropOffset: string | undefined;\n  css: string | undefined;\n  customStyle: string | undefined;\n  customUserStyle: string | undefined;\n  singleDoc: boolean;\n  quick: boolean;\n  title: string | undefined;\n  author: string | undefined;\n  language: string | undefined;\n  readingProgression: 'ltr' | 'rtl' | undefined;\n  vfmOptions: {\n    hardLineBreaks: boolean;\n    disableFormatHtml: boolean;\n  };\n  cover:\n    | {\n        src: string;\n        name: string;\n      }\n    | undefined;\n  timeout: number;\n  sandbox: boolean;\n  browser: {\n    type: BrowserType;\n    tag: string;\n    executablePath: string | undefined;\n  };\n  proxy:\n    | {\n        server: string;\n        bypass: string | undefined;\n        username: string | undefined;\n        password: string | undefined;\n      }\n    | undefined;\n  image: string;\n  viewer: string | undefined;\n  viewerParam: string | undefined;\n  logLevel: 'silent' | 'info' | 'verbose' | 'debug';\n  ignoreHttpsErrors: boolean;\n  base: string;\n  server: Required<\n    Pick<\n      ResolvedViteConfig['server'],\n      'host' | 'port' | 'proxy' | 'allowedHosts'\n    >\n  >;\n  static: Record<string, string[]>;\n  rootUrl: string;\n  viteConfig: UserConfig | undefined;\n  viteConfigFile: string | boolean;\n};\n\nconst DEFAULT_ASSET_EXTENSIONS = [\n  'css',\n  'css.map',\n  'png',\n  'jpg',\n  'jpeg',\n  'svg',\n  'gif',\n  'webp',\n  'apng',\n  'ttf',\n  'otf',\n  'woff',\n  'woff2',\n];\n\nfunction isManuscriptMediaType(\n  mediaType: string | false,\n): mediaType is ManuscriptMediaType {\n  return !!(\n    mediaType && manuscriptMediaTypes.includes(mediaType as ManuscriptMediaType)\n  );\n}\n\nconst htmlExtensions = ['.html', '.htm', '.xhtml', '.xht'] as const;\n\n/**\n * Convert non-HTML file extensions to .html\n * HTML/XHTML extensions are preserved as-is\n */\nfunction toHtmlExtension(filename: string): string {\n  const ext = upath.extname(filename).toLowerCase();\n  if (\n    htmlExtensions.includes(\n      // @ts-expect-error check membership\n      ext,\n    )\n  ) {\n    return filename;\n  }\n  return `${filename.slice(0, -ext.length)}.html`;\n}\n\nexport function isWebPubConfig(\n  config: ResolvedTaskConfig,\n): config is ResolvedTaskConfig & {\n  viewerInput: WebPublicationManifestConfig;\n} {\n  return config.viewerInput.type === 'webpub';\n}\n\nexport function isWebbookConfig(\n  config: ResolvedTaskConfig,\n): config is ResolvedTaskConfig & {\n  viewerInput: WebBookEntryConfig;\n} {\n  return config.viewerInput.type === 'webbook';\n}\n\nexport function parsePackageName(\n  specifier: string,\n  cwd: string,\n): npa.Result | null {\n  try {\n    let result = npa(specifier, cwd);\n    // #373: Relative path specifiers may be assumed as shorthand of hosted git\n    // (ex: foo/bar -> github:foo/bar)\n    if (result.type === 'git' && result.saveSpec?.startsWith('github:')) {\n      result = npa(`file:${specifier}`, cwd);\n    }\n    return result;\n  } catch (error) {\n    return null;\n  }\n}\n\n// parse theme locator\nexport function parseTheme({\n  theme,\n  context,\n  workspaceDir,\n  themesDir,\n}: {\n  theme: string | ThemeConfig;\n  context: string;\n  workspaceDir: string;\n  themesDir: string;\n}): ParsedTheme {\n  const { specifier, import: importPath } =\n    typeof theme === 'string' ? { specifier: theme, import: undefined } : theme;\n\n  // url\n  if (isValidUri(specifier)) {\n    return {\n      type: 'uri',\n      name: upath.basename(specifier),\n      location: specifier,\n    };\n  }\n\n  // bare .css file\n  const stylePath = upath.resolve(context, specifier);\n  if (fs.existsSync(stylePath) && stylePath.endsWith('.css')) {\n    const sourceRelPath = upath.relative(context, stylePath);\n    return {\n      type: 'file',\n      name: upath.basename(specifier),\n      source: stylePath,\n      location: upath.resolve(workspaceDir, sourceRelPath),\n    };\n  }\n\n  // node_modules, local pkg\n  const parsed = parsePackageName(specifier, context);\n\n  if (!parsed) {\n    throw new Error(`Invalid package name: ${specifier}`);\n  }\n  // To security reason, Vivliostyle CLI disallow other than npm registry or local file as download source\n  // TODO: Add option that user can allow an unofficial registry explicitly\n  if (!parsed.registry && parsed.type !== 'directory') {\n    throw new Error(`This package specifier is not allowed: ${specifier}`);\n  }\n  let name = parsed.name;\n  let resolvedSpecifier = specifier;\n  if (parsed.type === 'directory' && parsed.fetchSpec) {\n    const pkgJsonPath = upath.join(parsed.fetchSpec, 'package.json');\n    if (fs.existsSync(pkgJsonPath)) {\n      const packageJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));\n      name = packageJson.name;\n      resolvedSpecifier = parsed.fetchSpec;\n    }\n  }\n  if (!name) {\n    throw new Error(`Could not determine the package name: ${specifier}`);\n  }\n  return {\n    type: 'package',\n    name,\n    specifier: resolvedSpecifier,\n    location: upath.join(themesDir, 'node_modules', name),\n    registry: Boolean(parsed.registry),\n    importPath,\n  };\n}\n\nfunction parsePageSize(size: string): PageSize {\n  const [width, height, ...others] = `${size}`.split(',');\n  if (!width || others.length) {\n    throw new Error(`Cannot parse size: ${size}`);\n  } else if (width && height) {\n    return {\n      width,\n      height,\n    };\n  } else {\n    return {\n      format: width,\n    };\n  }\n}\n\nfunction parseFileMetadata({\n  contentType,\n  sourcePath,\n  workspaceDir,\n  themesDir,\n  documentMetadataReader,\n}: {\n  contentType: ManuscriptMediaType;\n  sourcePath: string;\n  workspaceDir: string;\n  themesDir?: string;\n  documentMetadataReader?: DocumentMetadataReader;\n}): { title?: string; themes?: ParsedTheme[] } {\n  const sourceDir = upath.dirname(sourcePath);\n  let title: string | undefined;\n  let themes: ParsedTheme[] | undefined;\n  if (documentMetadataReader) {\n    const metadata = readMarkdownMetadata(sourcePath, documentMetadataReader);\n    title = metadata.title;\n    if (metadata.vfm?.theme && themesDir) {\n      themes = [metadata.vfm.theme]\n        .flat()\n        .filter(\n          (entry) =>\n            !!entry && (typeof entry === 'string' || typeof entry === 'object'),\n        )\n        .map((theme) =>\n          parseTheme({\n            theme,\n            context: sourceDir,\n            workspaceDir,\n            themesDir,\n          }),\n        );\n    }\n  } else if (\n    contentType === 'text/html' ||\n    contentType === 'application/xhtml+xml'\n  ) {\n    const content = fs.readFileSync(sourcePath, 'utf8');\n    title = content.match(/<title>([^<]*)<\\/title>/)?.[1] || undefined;\n  }\n  return { title, themes };\n}\n\nexport function parseCustomStyle({\n  customStyle,\n  entryContextDir,\n}: {\n  customStyle: string;\n  entryContextDir: string;\n}): string {\n  if (isValidUri(customStyle)) {\n    return customStyle;\n  }\n  const stylePath = upath.resolve(entryContextDir, customStyle);\n  if (!pathContains(entryContextDir, stylePath)) {\n    throw Error(\n      `Custom style file ${customStyle} is not in ${entryContextDir}. Make sure the file is located in the context directory or a subdirectory.`,\n    );\n  }\n  if (!fs.existsSync(stylePath)) {\n    throw new Error(`Custom style file not found: ${customStyle}`);\n  }\n  return pathToFileURL(stylePath).href.slice(\n    pathToFileURL(entryContextDir).href.replace(/\\/$/, '').length + 1,\n  );\n}\n\nexport function resolveTaskConfig(\n  config: ParsedBuildTask,\n  options: InlineOptions,\n): ResolvedTaskConfig {\n  const context = options.cwd ?? defaultCwd;\n  Logger.debug('resolveTaskConfig > context %s', context);\n\n  const entryContextDir = config.entryContext\n    ? upath.resolve(context, config.entryContext)\n    : context;\n  const language = config.language;\n  const readingProgression = config.readingProgression;\n  const size = config.size ? parsePageSize(config.size) : undefined;\n  const cropMarks = options.cropMarks ?? false;\n  const bleed = options.bleed;\n  const cropOffset = options.cropOffset;\n  const css = options.css;\n  const singleDoc = options.singleDoc ?? false;\n  const quick = options.quick ?? false;\n  const temporaryFilePrefix =\n    config.temporaryFilePrefix ?? `.vs-${Date.now()}.`;\n\n  const vfmOptions = {\n    ...config?.vfm,\n    hardLineBreaks: config?.vfm?.hardLineBreaks ?? false,\n    disableFormatHtml: config?.vfm?.disableFormatHtml ?? false,\n  };\n\n  const timeout = config.timeout ?? 300_000; // 5 minutes\n  const sandbox = options.sandbox ?? false;\n  const browser = (() => {\n    const type = config.browser?.type ?? 'chrome';\n    const platform = detectBrowserPlatform();\n    return {\n      type,\n      tag:\n        config.browser?.tag ??\n        (platform ? DEFAULT_BROWSER_VERSIONS[type][platform] : 'latest'),\n      executablePath: options.executableBrowser,\n    };\n  })();\n  const proxyServer =\n    options.proxyServer ?? process.env.HTTP_PROXY ?? undefined;\n  const proxy = proxyServer\n    ? {\n        server: proxyServer,\n        bypass: options.proxyBypass ?? process.env.NOPROXY ?? undefined,\n        username: options.proxyUser,\n        password: options.proxyPass,\n      }\n    : undefined;\n  const image = config.image ?? `${CONTAINER_URL}:${cliVersion}`;\n  const viewer = config.viewer ?? undefined;\n  const viewerParam = config.viewerParam ?? undefined;\n  const logLevel = options.logLevel ?? 'silent';\n  const ignoreHttpsErrors = options.ignoreHttpsErrors ?? false;\n  const base = config.base ?? '/vivliostyle';\n  const staticRoutes = config.static ?? {};\n  const viteConfig = config.vite;\n  const viteConfigFile = config.viteConfigFile ?? true;\n\n  const customStyle =\n    (options.style &&\n      parseCustomStyle({ customStyle: options.style, entryContextDir })) ||\n    undefined;\n  const customUserStyle =\n    (options.userStyle &&\n      parseCustomStyle({ customStyle: options.userStyle, entryContextDir })) ||\n    undefined;\n\n  const outputs = ((): OutputConfig[] => {\n    const defaultPdfOptions: Omit<PdfOutput, 'path'> = {\n      format: 'pdf',\n      renderMode: options.renderMode ?? 'local',\n      preflight:\n        options.preflight ?? (config.pressReady ? 'press-ready' : undefined),\n      preflightOption: options.preflightOption ?? [],\n    };\n    if (config.output) {\n      return config.output.map((target): OutputConfig => {\n        const outputPath = upath.resolve(context, target.path);\n        const format = target.format;\n        switch (format) {\n          case 'pdf':\n            return {\n              ...defaultPdfOptions,\n              ...target,\n              format,\n              path: outputPath,\n            };\n          case 'epub':\n            return {\n              ...target,\n              format,\n              path: outputPath,\n              version: EPUB_OUTPUT_VERSION,\n            };\n          case 'webpub':\n            return {\n              ...target,\n              format,\n              path: outputPath,\n            };\n          default:\n            return format satisfies never;\n        }\n      });\n    }\n    // Outputs a pdf file if any output configuration is not set\n    const filename = config.title ? `${config.title}.pdf` : 'output.pdf';\n    return [\n      {\n        ...defaultPdfOptions,\n        path: upath.resolve(context, filename),\n      },\n    ];\n  })();\n\n  const { server, rootUrl } = (() => {\n    let host = config.server?.host ?? false;\n    let allowedHosts = config.server?.allowedHosts || [];\n    const port = config.server?.port ?? 13000;\n    if (\n      outputs.some(\n        (target) => target.format === 'pdf' && target.renderMode === 'docker',\n      ) &&\n      !isInContainer()\n    ) {\n      // Docker render mode requires wildcard host to allow access from the container\n      host = true;\n      if (\n        Array.isArray(allowedHosts) &&\n        !allowedHosts.includes(CONTAINER_LOCAL_HOSTNAME)\n      ) {\n        allowedHosts.push(CONTAINER_LOCAL_HOSTNAME);\n      }\n    }\n    const rootHostname = !host ? 'localhost' : host === true ? '0.0.0.0' : host;\n    return {\n      server: {\n        host,\n        port,\n        proxy: config.server?.proxy ?? {},\n        allowedHosts,\n      } satisfies ResolvedTaskConfig['server'],\n      rootUrl: `http://${rootHostname}:${port}`,\n    };\n  })();\n\n  const cover = config.cover && {\n    src: upath.resolve(entryContextDir, config.cover.src),\n    name: config.cover.name || COVER_HTML_IMAGE_ALT,\n  };\n\n  const copyAsset = {\n    includes: config.copyAsset?.includes ?? config.includeAssets ?? [],\n    excludes: config.copyAsset?.excludes ?? [],\n    fileExtensions: [\n      ...new Set([\n        ...DEFAULT_ASSET_EXTENSIONS,\n        ...(config.copyAsset?.includeFileExtensions ?? []),\n      ]),\n    ].filter(\n      (ext) => !(config.copyAsset?.excludeFileExtensions ?? []).includes(ext),\n    ),\n  };\n\n  const themeIndexes = new Set<ParsedTheme>();\n  const projectConfig =\n    !options.config && options.input\n      ? resolveSingleInputConfig({\n          config,\n          input: options.input!,\n          context,\n          temporaryFilePrefix,\n          themeIndexes,\n          base,\n        })\n      : resolveComposedProjectConfig({\n          config,\n          context,\n          entryContextDir,\n          outputs,\n          temporaryFilePrefix,\n          themeIndexes,\n          cover,\n        });\n\n  // Check overwrites\n  for (const output of outputs) {\n    const relPath = upath.relative(context, output.path);\n    if (\n      pathContains(output.path, entryContextDir) ||\n      pathEquals(output.path, entryContextDir)\n    ) {\n      throw new Error(\n        `The output path is set to \"${relPath}\", but this will overwrite the original manuscript file. Please specify a different path.`,\n      );\n    }\n    if (\n      pathContains(output.path, projectConfig.workspaceDir) ||\n      pathEquals(output.path, projectConfig.workspaceDir)\n    ) {\n      throw new Error(\n        `The output path is set to \"${relPath}\", but this will overwrite the working directory of Vivliostyle. Please specify a different path.`,\n      );\n    }\n  }\n  const { entries, workspaceDir } = projectConfig;\n  const duplicatedTarget = entries.find(\n    (v1, i) => entries.findLastIndex((v2) => v1.target === v2.target) !== i,\n  )?.target;\n  if (duplicatedTarget) {\n    const sourceFile = entries.find(\n      (entry) =>\n        entry.target === duplicatedTarget && entry.source?.type === 'file',\n    )?.source as FileEntrySource | undefined;\n    throw new Error(\n      `The output path \"${upath.relative(workspaceDir, duplicatedTarget)}\" will overwrite existing content.` +\n        (sourceFile\n          ? ` Please choose a different name for the source file: ${sourceFile.pathname}`\n          : ''),\n    );\n  }\n\n  const resolvedConfig = {\n    ...projectConfig,\n    entryContextDir,\n    outputs,\n    themeIndexes,\n    copyAsset,\n    temporaryFilePrefix,\n    size,\n    cropMarks,\n    bleed,\n    cropOffset,\n    css,\n    customStyle,\n    customUserStyle,\n    singleDoc,\n    quick,\n    language,\n    readingProgression,\n    vfmOptions,\n    cover,\n    timeout,\n    sandbox,\n    browser,\n    proxy,\n    image,\n    viewer,\n    viewerParam,\n    logLevel,\n    ignoreHttpsErrors,\n    base,\n    server,\n    static: staticRoutes,\n    rootUrl,\n    viteConfig,\n    viteConfigFile,\n  } satisfies ResolvedTaskConfig;\n  return resolvedConfig;\n}\n\ntype ProjectConfig = Pick<\n  ResolvedTaskConfig,\n  | 'serverRootDir'\n  | 'workspaceDir'\n  | 'themesDir'\n  | 'entries'\n  | 'input'\n  | 'viewerInput'\n  | 'exportAliases'\n  | 'title'\n  | 'author'\n>;\n\nfunction resolveSingleInputConfig({\n  config,\n  input,\n  context,\n  temporaryFilePrefix,\n  themeIndexes,\n  base,\n}: Pick<ResolvedTaskConfig, 'temporaryFilePrefix' | 'themeIndexes' | 'base'> & {\n  config: ParsedBuildTask;\n  input: NonNullable<InlineOptions['input']>;\n  context: string;\n}): ProjectConfig {\n  Logger.debug('entering single entry config mode');\n\n  let serverRootDir: string | UseTemporaryServerRoot;\n  let sourcePath: string;\n  let workspaceDir: string;\n  const inputFormat = input.format;\n  const title = config?.title;\n  const author = config?.author;\n  const entries: ParsedEntry[] = [];\n  const exportAliases: { source: string; target: string }[] = [];\n\n  let isLocalResource = true;\n  if (isValidUri(input.entry)) {\n    const url = new URL(input.entry);\n    if (url.protocol === 'file:') {\n      sourcePath = fileURLToPath(url);\n    } else {\n      isLocalResource = false;\n      sourcePath = input.entry;\n    }\n  } else {\n    sourcePath = upath.resolve(context, input.entry);\n  }\n  if (isLocalResource) {\n    // Check file exists\n    statFileSync(sourcePath);\n    switch (input.format) {\n      case 'webbook':\n      case 'markdown':\n      case 'pub-manifest':\n      case 'epub':\n        workspaceDir = upath.dirname(sourcePath);\n        break;\n      case 'epub-opf': {\n        const rootDir = getEpubRootDir(sourcePath);\n        if (!rootDir) {\n          throw new Error(\n            `Could not determine the EPUB root directory for the OPF file: ${sourcePath}`,\n          );\n        }\n        workspaceDir = rootDir;\n        break;\n      }\n      default:\n        return input.format satisfies never;\n    }\n    serverRootDir = workspaceDir;\n  } else {\n    serverRootDir = UseTemporaryServerRoot;\n    workspaceDir = context;\n  }\n  const themesDir = upath.resolve(workspaceDir, 'themes');\n\n  if (input.format === 'markdown') {\n    // Single input file; create temporary file\n    const contentType = 'text/markdown';\n    const documentProcessor = {\n      processorFactory: config.documentProcessor ?? VFM,\n      metadataReader: config.documentMetadataReader ?? readMetadata,\n    } satisfies DocumentProcessor;\n    const metadata = parseFileMetadata({\n      contentType,\n      sourcePath,\n      workspaceDir,\n      documentMetadataReader: documentProcessor.metadataReader,\n    });\n    const target = toHtmlExtension(\n      upath.resolve(\n        workspaceDir,\n        `${temporaryFilePrefix}${upath.basename(sourcePath)}`,\n      ),\n    );\n    touchTmpFile(target);\n    const themes =\n      metadata.themes ??\n      config.theme?.map((theme) =>\n        parseTheme({\n          theme,\n          context,\n          workspaceDir,\n          themesDir,\n        }),\n      ) ??\n      [];\n    themes.forEach((t) => themeIndexes.add(t));\n    entries.push({\n      contentType,\n      source: {\n        type: 'file',\n        pathname: sourcePath,\n        contentType,\n        documentProcessor,\n      },\n      target,\n      title: metadata.title,\n      themes,\n    });\n    exportAliases.push({\n      source: target,\n      target: upath.resolve(\n        upath.dirname(target),\n        toHtmlExtension(upath.basename(sourcePath)),\n      ),\n    });\n  }\n\n  let fallbackTitle: string | undefined;\n  let viewerInput: ViewerInputConfig;\n\n  if (inputFormat === 'markdown') {\n    // create temporary manifest file\n    const manifestPath = upath.resolve(\n      workspaceDir,\n      `${temporaryFilePrefix}${MANIFEST_FILENAME}`,\n    );\n    touchTmpFile(manifestPath);\n    exportAliases.push({\n      source: manifestPath,\n      target: upath.resolve(workspaceDir, MANIFEST_FILENAME),\n    });\n    fallbackTitle =\n      entries.length === 1 && entries[0].title\n        ? (entries[0].title as string)\n        : upath.basename(sourcePath);\n    viewerInput = {\n      type: 'webpub',\n      manifestPath,\n      needToGenerateManifest: true,\n    };\n  } else if (inputFormat === 'webbook') {\n    let webbookEntryUrl: string;\n    let webbookPath: string | undefined;\n    if (isValidUri(sourcePath)) {\n      const url = new URL(sourcePath);\n      webbookEntryUrl = url.href;\n    } else {\n      const rootFileUrl = pathToFileURL(workspaceDir).href;\n      const urlPath = pathToFileURL(sourcePath).href.slice(rootFileUrl.length);\n      webbookEntryUrl = `${base}${urlPath}`;\n      webbookPath = sourcePath;\n    }\n    viewerInput = { type: 'webbook', webbookEntryUrl, webbookPath };\n  } else if (inputFormat === 'pub-manifest') {\n    viewerInput = {\n      type: 'webpub',\n      manifestPath: sourcePath,\n      needToGenerateManifest: false,\n    };\n  } else if (inputFormat === 'epub-opf') {\n    viewerInput = { type: 'epub-opf', epubOpfPath: sourcePath };\n  } else if (inputFormat === 'epub') {\n    viewerInput = {\n      type: 'epub',\n      epubPath: sourcePath,\n      epubTmpOutputDir: upath.join(\n        sourcePath,\n        `../${temporaryFilePrefix}${upath.basename(sourcePath)}`,\n      ),\n    };\n  } else {\n    return inputFormat satisfies never;\n  }\n\n  return {\n    serverRootDir,\n    workspaceDir,\n    themesDir,\n    entries,\n    input: {\n      format: inputFormat,\n      entry: sourcePath,\n    },\n    viewerInput,\n    exportAliases,\n    title: title || fallbackTitle,\n    author,\n  };\n}\n\nfunction resolveComposedProjectConfig({\n  config,\n  context,\n  entryContextDir,\n  outputs,\n  temporaryFilePrefix,\n  themeIndexes,\n  cover,\n}: Pick<\n  ResolvedTaskConfig,\n  | 'entryContextDir'\n  | 'outputs'\n  | 'temporaryFilePrefix'\n  | 'themeIndexes'\n  | 'cover'\n> & { config: ParsedBuildTask; context: string }): ProjectConfig {\n  Logger.debug('entering composed project config mode');\n\n  const workspaceDir = upath.resolve(\n    context,\n    config.workspaceDir ?? '.vivliostyle',\n  );\n  const themesDir = upath.resolve(workspaceDir, 'themes');\n  const pkgJsonPath = upath.resolve(context, 'package.json');\n  const pkgJson = fs.existsSync(pkgJsonPath)\n    ? readJSON(pkgJsonPath)\n    : undefined;\n  if (pkgJson) {\n    Logger.debug('located package.json path', pkgJsonPath);\n  }\n  const exportAliases: { source: string; target: string }[] = [];\n\n  const rootThemes =\n    config.theme?.map((theme) =>\n      parseTheme({\n        theme,\n        context,\n        workspaceDir,\n        themesDir,\n      }),\n    ) ?? [];\n  rootThemes.forEach((t) => themeIndexes.add(t));\n  const tocConfig = {\n    tocTitle: config.toc?.title ?? config?.tocTitle ?? TOC_TITLE,\n    target: upath.resolve(workspaceDir, config.toc?.htmlPath ?? TOC_FILENAME),\n    sectionDepth: config.toc?.sectionDepth ?? 0,\n    transform: {\n      transformDocumentList: config.toc?.transformDocumentList,\n      transformSectionList: config.toc?.transformSectionList,\n    },\n  };\n  const coverHtml =\n    config.cover &&\n    ('htmlPath' in config.cover && !config.cover.htmlPath\n      ? undefined\n      : upath.resolve(\n          workspaceDir,\n          config.cover?.htmlPath || COVER_HTML_FILENAME,\n        ));\n\n  const ensureCoverImage = (src?: string) => {\n    const absPath = src && upath.resolve(entryContextDir, src);\n    if (absPath) {\n      statFileSync(absPath, {\n        errorMessage: 'Specified cover image does not exist',\n      });\n    }\n    return absPath;\n  };\n\n  const projectTitle: string | undefined = config?.title ?? pkgJson?.name;\n  const projectAuthor: string | undefined = config?.author ?? pkgJson?.author;\n\n  const rootDocumentProcessor = {\n    processorFactory: config.documentProcessor ?? VFM,\n    metadataReader: config.documentMetadataReader ?? readMetadata,\n  } satisfies DocumentProcessor;\n\n  const isContentsEntry = (entry: EntryConfig): entry is ContentsEntryConfig =>\n    entry.rel === 'contents';\n  const isCoverEntry = (entry: EntryConfig): entry is CoverEntryConfig =>\n    entry.rel === 'cover';\n  const isArticleEntry = (entry: EntryConfig): entry is ArticleEntryConfig =>\n    !isContentsEntry(entry) && !isCoverEntry(entry);\n\n  function parseEntry(entry: EntryConfig): ParsedEntry {\n    const getInputInfo = (\n      entryPath: string,\n    ):\n      | (FileEntrySource & { metadata: ReturnType<typeof parseFileMetadata> })\n      | (UriEntrySource & { metadata?: undefined }) => {\n      if (/^https?:/.test(entryPath)) {\n        return {\n          type: 'uri',\n          href: entryPath,\n          rootDir: upath.join(workspaceDir, new URL(entryPath).host),\n        };\n      } else if (entryPath.startsWith('/')) {\n        return {\n          type: 'uri',\n          href: entryPath,\n          rootDir: upath.join(workspaceDir, 'localhost'),\n        };\n      }\n      const pathname = upath.resolve(entryContextDir, entryPath);\n      statFileSync(pathname);\n      const rawContentType = mime(pathname);\n\n      const documentProcessor = {\n        processorFactory:\n          ('documentProcessor' in entry && entry.documentProcessor) ||\n          rootDocumentProcessor.processorFactory,\n        metadataReader:\n          ('documentMetadataReader' in entry && entry.documentMetadataReader) ||\n          rootDocumentProcessor.metadataReader,\n      } satisfies DocumentProcessor;\n      // If custom documentProcessor is provided, allow any text-based content type\n      const hasCustomProcessor = !!(\n        documentProcessor.processorFactory !== VFM ||\n        documentProcessor.metadataReader !== readMetadata\n      );\n      const contentType =\n        hasCustomProcessor && rawContentType !== 'text/markdown'\n          ? 'text/x-vivliostyle-custom'\n          : rawContentType;\n      if (\n        !isManuscriptMediaType(contentType) ||\n        contentType === 'text/plain' // disallow text/plain (for now)\n      ) {\n        throw new Error(\n          `Invalid manuscript type ${rawContentType} detected: ${entry}`,\n        );\n      }\n\n      const useDocumentProcessor =\n        contentType === 'text/markdown' ||\n        contentType === 'text/x-vivliostyle-custom';\n      return {\n        type: 'file',\n        pathname,\n        contentType,\n        metadata: parseFileMetadata({\n          contentType,\n          sourcePath: pathname,\n          workspaceDir,\n          themesDir,\n          documentMetadataReader: useDocumentProcessor\n            ? documentProcessor.metadataReader\n            : undefined,\n        }),\n        ...(useDocumentProcessor && { documentProcessor }),\n      };\n    };\n\n    const getTargetPath = (source: EntrySource) => {\n      switch (source.type) {\n        case 'file':\n          return upath.resolve(\n            workspaceDir,\n            toHtmlExtension(upath.relative(entryContextDir, source.pathname)),\n          );\n        case 'uri': {\n          const url = new URL(source.href, 'a://dummy');\n          let pathname = url.pathname;\n          if (!/\\.\\w+$/.test(pathname)) {\n            pathname = `${pathname.replace(/\\/$/, '')}/index.html`;\n          }\n          return upath.join(source.rootDir, pathname);\n        }\n        default:\n          return source satisfies never;\n      }\n    };\n\n    if ((isContentsEntry(entry) || isCoverEntry(entry)) && entry.path) {\n      const source = upath.resolve(entryContextDir, entry.path);\n      try {\n        statFileSync(source);\n        /* v8 ignore next 10 */\n      } catch (error) {\n        // For backward compatibility, we allow missing files then assume that option as `output` field.\n        Logger.logWarn(\n          `The \"path\" option is set but the file does not exist: ${source}\\nMaybe you want to set the \"output\" field instead.`,\n        );\n        entry.output = entry.path;\n        entry.path = undefined;\n      }\n    }\n\n    if (isContentsEntry(entry)) {\n      const inputInfo = entry.path ? getInputInfo(entry.path) : undefined;\n      const { metadata, ...template } = inputInfo || {};\n      let target = entry.output\n        ? upath.resolve(workspaceDir, entry.output)\n        : inputInfo && getTargetPath(inputInfo);\n      const themes = entry.theme\n        ? [entry.theme].flat().map((theme) =>\n            parseTheme({\n              theme,\n              context,\n              workspaceDir,\n              themesDir,\n            }),\n          )\n        : (metadata?.themes ?? [...rootThemes]);\n      themes.forEach((t) => themeIndexes.add(t));\n      target ??= tocConfig.target;\n      if (\n        inputInfo?.type === 'file' &&\n        pathEquals(inputInfo.pathname, target)\n      ) {\n        const tmpPath = upath.resolve(\n          upath.dirname(target),\n          `${temporaryFilePrefix}${upath.basename(target)}`,\n        );\n        exportAliases.push({ source: tmpPath, target });\n        touchTmpFile(tmpPath);\n        target = tmpPath;\n      }\n      const parsedEntry: ContentsEntry = {\n        rel: 'contents',\n        ...tocConfig,\n        target,\n        title: entry.title ?? metadata?.title ?? projectTitle,\n        themes,\n        pageBreakBefore: entry.pageBreakBefore,\n        pageCounterReset: entry.pageCounterReset,\n        ...('type' in template && { template }),\n      };\n      return parsedEntry;\n    }\n\n    if (isCoverEntry(entry)) {\n      const inputInfo = entry.path ? getInputInfo(entry.path) : undefined;\n      const { metadata, ...template } = inputInfo || {};\n      let target = entry.output\n        ? upath.resolve(workspaceDir, entry.output)\n        : inputInfo && getTargetPath(inputInfo);\n      const themes = entry.theme\n        ? [entry.theme].flat().map((theme) =>\n            parseTheme({\n              theme,\n              context,\n              workspaceDir,\n              themesDir,\n            }),\n          )\n        : (metadata?.themes ?? []); // Don't inherit rootThemes for cover documents\n      themes.forEach((t) => themeIndexes.add(t));\n      const coverImageSrc = ensureCoverImage(entry.imageSrc || cover?.src);\n      if (!coverImageSrc) {\n        throw new Error(\n          `A CoverEntryConfig is set in the entry list but a location of cover file is not set. Please set 'cover' property in your config file.`,\n        );\n      }\n      target ??= upath.resolve(\n        workspaceDir,\n        entry.path || coverHtml || COVER_HTML_FILENAME,\n      );\n      if (\n        inputInfo?.type === 'file' &&\n        pathEquals(inputInfo.pathname, target)\n      ) {\n        const tmpPath = upath.resolve(\n          upath.dirname(target),\n          `${temporaryFilePrefix}${upath.basename(target)}`,\n        );\n        exportAliases.push({ source: tmpPath, target });\n        touchTmpFile(tmpPath);\n        target = tmpPath;\n      }\n      const parsedEntry: CoverEntry = {\n        rel: 'cover',\n        target,\n        title: entry.title ?? metadata?.title ?? projectTitle,\n        themes,\n        coverImageSrc,\n        coverImageAlt: entry.imageAlt || cover?.name || COVER_HTML_IMAGE_ALT,\n        pageBreakBefore: entry.pageBreakBefore,\n        ...('type' in template && { template }),\n      };\n      return parsedEntry;\n    }\n\n    if (isArticleEntry(entry)) {\n      const inputInfo = getInputInfo(entry.path);\n      const { metadata, ...source } = inputInfo;\n      const target = entry.output\n        ? upath.resolve(workspaceDir, entry.output)\n        : getTargetPath(inputInfo);\n      const themes = entry.theme\n        ? [entry.theme]\n            .flat()\n            .map((theme) =>\n              parseTheme({ theme, context, workspaceDir, themesDir }),\n            )\n        : (metadata?.themes ?? [...rootThemes]);\n      themes.forEach((t) => themeIndexes.add(t));\n\n      const parsedEntry: ManuscriptEntry = {\n        contentType:\n          inputInfo.type === 'file' ? inputInfo.contentType : 'text/html',\n        source,\n        target,\n        title: entry.title ?? metadata?.title ?? projectTitle,\n        themes,\n        ...(entry.rel && { rel: entry.rel }),\n      };\n      return parsedEntry;\n    }\n\n    /* v8 ignore next */\n    return entry satisfies never;\n  }\n\n  const entries = config.entry.map(parseEntry);\n\n  let fallbackProjectTitle: string | undefined;\n  if (!projectTitle) {\n    if (entries.length === 1 && entries[0].title) {\n      fallbackProjectTitle = entries[0].title;\n    } else {\n      fallbackProjectTitle = upath.basename(outputs[0].path);\n    }\n  }\n  if (!!config?.toc && !entries.find(({ rel }) => rel === 'contents')) {\n    entries.unshift({\n      rel: 'contents',\n      ...tocConfig,\n      themes: [...rootThemes],\n    });\n  }\n  if (cover && coverHtml && !entries.find(({ rel }) => rel === 'cover')) {\n    entries.unshift({\n      rel: 'cover',\n      target: coverHtml,\n      title: projectTitle,\n      themes: [], // Don't inherit rootThemes for cover documents\n      coverImageSrc: ensureCoverImage(cover.src)!,\n      coverImageAlt: cover.name,\n    });\n  }\n\n  return {\n    serverRootDir: context,\n    workspaceDir,\n    themesDir,\n    entries,\n    input: {\n      format: 'pub-manifest',\n      entry: upath.join(workspaceDir, MANIFEST_FILENAME),\n    },\n    viewerInput: {\n      type: 'webpub',\n      manifestPath: upath.join(workspaceDir, MANIFEST_FILENAME),\n      needToGenerateManifest: true,\n    },\n    exportAliases,\n    title: projectTitle || fallbackProjectTitle,\n    author: projectAuthor,\n  };\n}\n","import type { Metadata, StringifyMarkdownOptions } from '@vivliostyle/vfm';\nimport fs from 'node:fs';\nimport vfile, { type VFile } from 'vfile';\nimport type {\n  DocumentMetadataReader,\n  DocumentProcessorFactory,\n} from '../config/resolve.js';\n\nexport interface VSFile extends VFile {\n  data: {\n    title?: string;\n    theme?: string;\n  };\n}\n\nexport async function processMarkdown(\n  documentProcessorFactory: DocumentProcessorFactory,\n  documentMetadataReader: DocumentMetadataReader,\n  filepath: string,\n  options: StringifyMarkdownOptions = {},\n): Promise<VSFile> {\n  const markdownString = fs.readFileSync(filepath, 'utf8');\n  const processor = documentProcessorFactory(\n    options,\n    documentMetadataReader(markdownString),\n  );\n  const processed = (await processor.process(\n    vfile({ path: filepath, contents: markdownString }),\n  )) as VSFile;\n  return processed;\n}\n\nexport function readMarkdownMetadata(\n  filepath: string,\n  documentMetadataReader: DocumentMetadataReader,\n): Metadata {\n  return documentMetadataReader(fs.readFileSync(filepath, 'utf8'));\n}\n","import * as vite from 'vite';\nimport { launchPreview } from '../browser.js';\nimport type { ResolvedTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { getViewerFullUrl } from '../server.js';\nimport { getOsLocale, runExitHandlers } from '../util.js';\nimport { reloadConfig } from './plugin-util.js';\n\nexport function vsBrowserPlugin({\n  config: _config,\n  inlineConfig,\n}: {\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): vite.Plugin {\n  let config = _config;\n  let server: vite.ViteDevServer | undefined;\n  let closeBrowser: (() => void) | undefined;\n\n  async function handlePageClose() {\n    await server?.close();\n    runExitHandlers();\n  }\n\n  async function openPreviewPage() {\n    const locale = await getOsLocale();\n    const url = await getViewerFullUrl(config);\n    const { page, browser } = await launchPreview({\n      mode: 'preview',\n      url,\n      config,\n      /* v8 ignore next 4 */\n      onPageOpen: async (page) => {\n        // Terminate preview when the previewing page is closed\n        page.on('close', handlePageClose);\n      },\n    });\n\n    // Vivliostyle Viewer uses `i18nextLng` in localStorage for UI language\n    if (!import.meta.env?.VITEST) {\n      /* v8 ignore next 4 */\n      await page.evaluate((locale) => {\n        window.localStorage.setItem('i18nextLng', locale);\n      }, locale);\n    }\n    // Move focus from the address bar to the page\n    await page.bringToFront();\n    // Focus to the URL input box if available\n    if (!import.meta.env?.VITEST) {\n      /* v8 ignore next 6 */\n      await page.evaluate(() => {\n        document\n          .querySelector<HTMLInputElement>('#vivliostyle-input-url')\n          ?.focus();\n      });\n    }\n\n    closeBrowser = () => {\n      page.off('close', handlePageClose);\n      browser.close();\n    };\n  }\n\n  return {\n    name: 'vivliostyle:browser',\n    apply: () => Boolean(inlineConfig.openViewer),\n    configureServer(viteServer) {\n      server = viteServer;\n\n      const _listen = viteServer.listen;\n      viteServer.listen = async (...args) => {\n        const server = await _listen(...args);\n        config = await reloadConfig(config, inlineConfig, server.config);\n        await openPreviewPage();\n        return server;\n      };\n    },\n    closeBundle() {\n      closeBrowser?.();\n    },\n  };\n}\n","import type {\n  InstalledBrowser,\n  Browser as SupportedBrowser,\n} from '@puppeteer/browsers';\nimport fs from 'node:fs';\nimport type {\n  Browser,\n  BrowserContext,\n  LaunchOptions,\n  Page,\n} from 'puppeteer-core';\nimport upath from 'upath';\nimport type { ResolvedTaskConfig } from './config/resolve.js';\nimport type { BrowserType } from './config/schema.js';\nimport { Logger } from './logger.js';\nimport { importNodeModule } from './node-modules.js';\nimport {\n  detectBrowserPlatform,\n  getCacheDir,\n  getDefaultBrowserTag,\n  isInContainer,\n  isRunningOnWSL,\n  registerExitHandler,\n} from './util.js';\n\nconst browserEnumMap = {\n  chrome: 'chrome' as SupportedBrowser.CHROME,\n  chromium: 'chromium' as SupportedBrowser.CHROMIUM,\n  firefox: 'firefox' as SupportedBrowser.FIREFOX,\n} as const satisfies {\n  [key in BrowserType]: SupportedBrowser;\n};\n\nasync function launchBrowser({\n  browserType,\n  proxy,\n  executablePath,\n  headless,\n  noSandbox,\n  disableDevShmUsage,\n  ignoreHttpsErrors,\n}: {\n  browserType: BrowserType;\n  proxy:\n    | {\n        server: string;\n        bypass: string | undefined;\n        username: string | undefined;\n        password: string | undefined;\n      }\n    | undefined;\n  executablePath: string;\n  headless: boolean;\n  noSandbox: boolean;\n  disableDevShmUsage: boolean;\n  ignoreHttpsErrors: boolean;\n}): Promise<{\n  browser: Browser;\n  browserContext: BrowserContext;\n}> {\n  const puppeteer = await importNodeModule('puppeteer-core');\n\n  const args: string[] = [];\n  // https://github.com/microsoft/playwright/blob/35709546cd4210b7744943ceb22b92c1b126d48d/packages/playwright-core/src/server/chromium/chromium.ts\n  if (browserType === 'chrome' || browserType === 'chromium') {\n    args.push(\n      '--disable-field-trial-config',\n      '--disable-back-forward-cache',\n      '--disable-component-update',\n      '--no-default-browser-check',\n      '--disable-features=AcceptCHFrame,AvoidUnnecessaryBeforeUnloadCheckSync,DestroyProfileOnBrowserClose,DialMediaRouteProvider,GlobalMediaControls,HttpsUpgrades,LensOverlay,MediaRouter,PaintHolding,ThirdPartyStoragePartitioning,Translate,AutoDeElevate,RenderDocument',\n      '--enable-features=CDPScreenshotNewSurface',\n      '--no-service-autorun',\n      '--unsafely-disable-devtools-self-xss-warnings',\n      '--edge-skip-compat-layer-relaunch',\n    );\n\n    if (process.platform === 'darwin') {\n      args.push('--enable-unsafe-swiftshader');\n    }\n    if (noSandbox) {\n      args.push('--no-sandbox');\n    }\n    if (headless) {\n      args.push(\n        '--hide-scrollbars',\n        '--mute-audio',\n        '--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4',\n      );\n    }\n    if (proxy?.server) {\n      const proxyURL = new URL(proxy.server);\n      const isSocks = proxyURL.protocol === 'socks5:';\n      if (isSocks) {\n        args.push(\n          `--host-resolver-rules=\"MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}\"`,\n        );\n      }\n      args.push(`--proxy-server=${proxy.server}`);\n      const proxyBypassRules = [];\n      if (proxy.bypass) {\n        proxyBypassRules.push(\n          ...proxy.bypass\n            .split(',')\n            .map((t) => t.trim())\n            .map((t) => (t.startsWith('.') ? '*' + t : t)),\n        );\n      }\n      proxyBypassRules.push('<-loopback>');\n      args.push(`--proxy-bypass-list=${proxyBypassRules.join(';')}`);\n    }\n    // #579: disable web security to allow cross-origin requests\n    args.push('--disable-web-security');\n    if (disableDevShmUsage) {\n      args.push('--disable-dev-shm-usage');\n    }\n    // #357: Set devicePixelRatio=1 otherwise it causes layout issues in HiDPI displays\n    if (headless) {\n      args.push('--force-device-scale-factor=1');\n    }\n    // #565: Add --disable-gpu option when running on WSL\n    if (isRunningOnWSL()) {\n      args.push('--disable-gpu');\n    }\n    // set Chromium language to English to avoid locale-dependent issues\n    args.push('--lang=en');\n    if (!headless && process.platform === 'darwin') {\n      args.push('-AppleLanguages', '(en)');\n    }\n    args.push('--no-startup-window');\n  }\n  // TODO: Investigate appropriate settings on Firefox\n\n  const launchOptions = {\n    executablePath,\n    args,\n    browser: browserType === 'chromium' ? 'chrome' : browserType,\n    headless,\n    acceptInsecureCerts: ignoreHttpsErrors,\n    waitForInitialPage: false,\n  } satisfies LaunchOptions;\n  Logger.debug('launchOptions %O', launchOptions);\n  const browser = await puppeteer.launch({\n    ...launchOptions,\n    env: { ...process.env, LANG: 'en.UTF-8' },\n  });\n  registerExitHandler('Closing browser', () => {\n    browser.close();\n  });\n  const [browserContext] = browser.browserContexts();\n  return { browser, browserContext };\n}\n\nfunction getPuppeteerCacheDir() {\n  if (isInContainer()) {\n    return '/opt/puppeteer';\n  }\n  return upath.join(getCacheDir(), 'browsers');\n}\n\ninterface BuildIdsCache {\n  createdAt: number;\n  buildIds: Record<string, Record<string, string>>;\n}\n\nasync function resolveBuildId({\n  type,\n  tag,\n  browsers,\n}: Pick<ResolvedTaskConfig['browser'], 'type' | 'tag'> & {\n  browsers: typeof import('@puppeteer/browsers');\n}): Promise<string> {\n  // Return cached data to reduce network requests to browser registry\n  // Cache is valid for 24 hours\n  const cacheDataFilename = upath.join(\n    getPuppeteerCacheDir(),\n    'build-ids.json',\n  );\n  let cacheData: BuildIdsCache;\n  try {\n    cacheData = JSON.parse(fs.readFileSync(cacheDataFilename, 'utf-8'));\n    if (Date.now() - cacheData.createdAt > 24 * 60 * 60 * 1000) {\n      cacheData = { createdAt: Date.now(), buildIds: {} };\n    }\n  } catch (_) {\n    cacheData = { createdAt: Date.now(), buildIds: {} };\n  }\n  if (cacheData.buildIds[type]?.[tag]) {\n    return cacheData.buildIds[type][tag];\n  }\n\n  const platform = detectBrowserPlatform();\n  if (!platform) {\n    throw new Error('The current platform is not supported.');\n  }\n  const buildId = await browsers.resolveBuildId(\n    browserEnumMap[type],\n    platform,\n    tag,\n  );\n  (cacheData.buildIds[type] ??= {})[tag] = buildId;\n  fs.mkdirSync(upath.dirname(cacheDataFilename), { recursive: true });\n  fs.writeFileSync(cacheDataFilename, JSON.stringify(cacheData));\n  return buildId;\n}\n\nasync function cleanupOutdatedBrowsers() {\n  for (const browser of Object.values(browserEnumMap)) {\n    const browsersDir = upath.join(getPuppeteerCacheDir(), browser);\n    if (!fs.existsSync(browsersDir)) {\n      continue;\n    }\n    const entries = fs.readdirSync(browsersDir);\n    for (const entry of entries) {\n      const entryPath = upath.join(browsersDir, entry);\n      const stat = fs.statSync(entryPath);\n      // Files that are not directories are temporary files created\n      // during downloads and should be deleted.\n      if (\n        !stat.isDirectory() ||\n        Date.now() - stat.mtimeMs > 7 * 24 * 60 * 60 * 1000\n      ) {\n        Logger.debug(`Removing outdated browser at ${entryPath}`);\n        await fs.promises.rm(entryPath, { recursive: true, force: true });\n      }\n    }\n  }\n}\n\nexport async function getExecutableBrowserPath({\n  type,\n  tag,\n}: ResolvedTaskConfig['browser']): Promise<string> {\n  const browsers = await importNodeModule('@puppeteer/browsers');\n  const buildId = await resolveBuildId({ type, tag, browsers });\n  return browsers.computeExecutablePath({\n    cacheDir: getPuppeteerCacheDir(),\n    browser: browserEnumMap[type],\n    buildId,\n  });\n}\n\nfunction checkBrowserAvailability(path: string): boolean {\n  return fs.existsSync(path);\n}\n\nasync function downloadBrowser({\n  type,\n  tag,\n}: ResolvedTaskConfig['browser']): Promise<string> {\n  const browsers = await importNodeModule('@puppeteer/browsers');\n  const buildId = await resolveBuildId({ type, tag, browsers });\n  let installedBrowser: InstalledBrowser | undefined;\n\n  if (isInContainer()) {\n    const defaultBrowserVersion = getDefaultBrowserTag('chrome');\n    Logger.logWarn(\n      `The container you are using already includes a browser (chrome@${defaultBrowserVersion}); however, the specified browser ${type}@${tag} was not found. Downloading the browser inside the container may take a long time. Consider using a container image that includes the required browser version.`,\n    );\n  }\n  {\n    using _ = Logger.suspendLogging(\n      'Rendering browser is not installed yet. Downloading now.',\n    );\n    installedBrowser = await browsers.install({\n      cacheDir: getPuppeteerCacheDir(),\n      browser: browserEnumMap[type],\n      buildId,\n      downloadProgressCallback: 'default',\n    });\n  }\n  return installedBrowser.executablePath;\n}\n\nexport async function launchPreview({\n  mode,\n  url,\n  onBrowserOpen,\n  onPageOpen,\n  config: { browser: browserConfig, proxy, sandbox, ignoreHttpsErrors },\n}: {\n  mode: 'preview' | 'build';\n  url: string;\n  onBrowserOpen?: (browser: Browser) => void | Promise<void>;\n  onPageOpen?: (page: Page) => void | Promise<void>;\n  config: Pick<\n    ResolvedTaskConfig,\n    'browser' | 'proxy' | 'sandbox' | 'ignoreHttpsErrors'\n  >;\n}) {\n  let executableBrowser = browserConfig.executablePath;\n  Logger.debug(`Specified browser path: ${executableBrowser}`);\n  if (executableBrowser) {\n    if (!checkBrowserAvailability(executableBrowser)) {\n      throw new Error(\n        `Cannot find the browser. Please check the executable browser path: ${executableBrowser}`,\n      );\n    }\n  } else if (\n    detectBrowserPlatform() === 'linux_arm' &&\n    (browserConfig.type === 'chrome' || browserConfig.type === 'chromium')\n  ) {\n    // https://github.com/puppeteer/puppeteer/issues/7740\n    Logger.logInfo(\n      'The official Chrome/Chromium binaries are not available for ARM64 Linux. Using the system-installed Chromium browser instead.',\n    );\n    executableBrowser = '/usr/bin/chromium';\n  } else {\n    executableBrowser = await getExecutableBrowserPath(browserConfig);\n    Logger.debug(`Using default browser: ${executableBrowser}`);\n    if (!checkBrowserAvailability(executableBrowser)) {\n      // The browser isn't downloaded first time starting CLI so try to download it\n      await cleanupOutdatedBrowsers();\n      await downloadBrowser(browserConfig);\n    }\n  }\n\n  const { browser, browserContext } = await launchBrowser({\n    browserType: browserConfig.type,\n    proxy,\n    executablePath: executableBrowser,\n    headless: mode === 'build',\n    noSandbox: !sandbox,\n    disableDevShmUsage: isInContainer(),\n    ignoreHttpsErrors,\n  });\n  await onBrowserOpen?.(browser);\n\n  const page =\n    (await browserContext.pages())[0] ?? (await browserContext.newPage());\n  await page.setViewport(\n    mode === 'build'\n      ? // This viewport size is important to detect headless environment in Vivliostyle viewer\n        // https://github.com/vivliostyle/vivliostyle.js/blob/73bcf323adcad80126b0175630609451ccd09d8a/packages/core/src/vivliostyle/vgen.ts#L2489-L2500\n        { width: 800, height: 600 }\n      : null,\n  );\n  await onPageOpen?.(page);\n\n  // Prevent confirm dialog from being auto-dismissed\n  page.on('dialog', () => {});\n\n  if (proxy?.username && proxy?.password) {\n    await page.authenticate({\n      username: proxy.username,\n      password: proxy.password,\n    });\n  }\n  await page.goto(url);\n\n  return { browser, page };\n}\n","import fs from 'node:fs';\nimport { URL } from 'node:url';\nimport upath from 'upath';\nimport {\n  createServer,\n  type InlineConfig,\n  preview,\n  type PreviewServer,\n  type ResolvedConfig as ResolvedViteConfig,\n  type ViteDevServer,\n} from 'vite';\nimport type { ResolvedTaskConfig } from './config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from './config/schema.js';\nimport { EMPTY_DATA_URI, VIEWER_ROOT_PATH } from './const.js';\nimport { Logger } from './logger.js';\nimport {\n  getDefaultEpubOpfPath,\n  isValidUri,\n  openEpub,\n  registerExitHandler,\n} from './util.js';\nimport { vsBrowserPlugin } from './vite/vite-plugin-browser.js';\nimport { vsDevServerPlugin } from './vite/vite-plugin-dev-server.js';\nimport { vsStaticServePlugin } from './vite/vite-plugin-static-serve.js';\nimport { vsViewerPlugin } from './vite/vite-plugin-viewer.js';\n\nexport type ViewerUrlOption = Pick<\n  ResolvedTaskConfig,\n  | 'size'\n  | 'cropMarks'\n  | 'bleed'\n  | 'cropOffset'\n  | 'css'\n  | 'customStyle'\n  | 'customUserStyle'\n  | 'singleDoc'\n  | 'quick'\n  | 'viewerParam'\n  | 'base'\n>;\n\nexport function getViewerParams(\n  src: string | undefined,\n  {\n    size,\n    cropMarks,\n    bleed,\n    cropOffset,\n    css,\n    customStyle,\n    customUserStyle,\n    singleDoc,\n    quick,\n    viewerParam,\n    base,\n  }: ViewerUrlOption,\n): string {\n  const pageSizeValue =\n    size && ('format' in size ? size.format : `${size.width} ${size.height}`);\n\n  function escapeParam(url: string) {\n    return url.replace(/&/g, '%26');\n  }\n\n  let viewerParams = src ? `src=${escapeParam(src)}` : '';\n  viewerParams += `&bookMode=${!singleDoc}&renderAllPages=${!quick}`;\n\n  if (customStyle) {\n    const param = isValidUri(customStyle)\n      ? customStyle\n      : upath.posix.join(base, customStyle);\n    viewerParams += `&style=${escapeParam(param)}`;\n  }\n\n  if (customUserStyle) {\n    const param = isValidUri(customUserStyle)\n      ? customUserStyle\n      : upath.posix.join(base, customUserStyle);\n    viewerParams += `&userStyle=${escapeParam(param)}`;\n  }\n\n  if (pageSizeValue || cropMarks || bleed || cropOffset || css) {\n    let pageStyle = '@page{';\n    if (pageSizeValue) {\n      pageStyle += `size:${pageSizeValue};`;\n    }\n    if (cropMarks) {\n      pageStyle += `marks:crop cross;`;\n    }\n    if (bleed || cropMarks) {\n      pageStyle += `bleed:${bleed ?? '3mm'};`;\n    }\n    if (cropOffset) {\n      pageStyle += `crop-offset:${cropOffset};`;\n    }\n    pageStyle += '}';\n\n    // The pageStyle settings are put between the `/*<viewer>*/` and `/*</viewer>*/`\n    // in the `&style=data:,â€¦` viewer parameter so that they are reflected in the\n    // Settings menu of the Viewer. Also the custom CSS code is appended after the\n    // `/*</viewer>*/` so that it is shown in the Edit CSS box in the Settings menu.\n    viewerParams += `&style=data:,/*<viewer>*/${encodeURIComponent(\n      pageStyle,\n    )}/*</viewer>*/${encodeURIComponent(css ?? '')}`;\n  }\n\n  if (viewerParam) {\n    // append additional viewer parameters\n    viewerParams += `&${viewerParam}`;\n  }\n\n  return viewerParams;\n}\n\nexport async function getSourceUrl({\n  viewerInput,\n  base,\n  workspaceDir,\n  rootUrl,\n}: Pick<\n  ResolvedTaskConfig,\n  'viewerInput' | 'base' | 'workspaceDir' | 'rootUrl'\n>) {\n  let input: string;\n  switch (viewerInput.type) {\n    case 'webpub':\n      input = viewerInput.manifestPath;\n      break;\n    case 'webbook':\n      input = viewerInput.webbookEntryUrl;\n      break;\n    case 'epub-opf':\n      input = viewerInput.epubOpfPath;\n      break;\n    case 'epub': {\n      if (!fs.existsSync(viewerInput.epubTmpOutputDir)) {\n        await openEpub(viewerInput.epubPath, viewerInput.epubTmpOutputDir);\n      }\n      input = getDefaultEpubOpfPath(viewerInput.epubTmpOutputDir);\n      break;\n    }\n    default:\n      input = viewerInput satisfies never;\n  }\n  return (\n    isValidUri(input)\n      ? new URL(input)\n      : new URL(\n          upath.posix.join(base, upath.relative(workspaceDir, input)),\n          rootUrl,\n        )\n  ).href;\n}\n\nexport async function getViewerFullUrl({\n  viewerInput,\n  base,\n  workspaceDir,\n  rootUrl,\n  viewer,\n  ...config\n}: ViewerUrlOption &\n  Pick<\n    ResolvedTaskConfig,\n    'viewerInput' | 'base' | 'workspaceDir' | 'rootUrl' | 'viewer'\n  >) {\n  const viewerUrl = viewer\n    ? new URL(viewer)\n    : new URL(`${VIEWER_ROOT_PATH}/index.html`, rootUrl);\n  const sourceUrl = await getSourceUrl({\n    viewerInput,\n    base,\n    workspaceDir,\n    rootUrl,\n  });\n  const viewerParams = getViewerParams(\n    sourceUrl === EMPTY_DATA_URI\n      ? undefined // open Viewer start page\n      : sourceUrl,\n    { base, ...config },\n  );\n  viewerUrl.hash = '';\n  return `${viewerUrl.href}#${viewerParams}`;\n}\n\nexport async function createViteServer(args: {\n  config: ResolvedTaskConfig;\n  viteConfig: ResolvedViteConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n  mode: 'preview';\n}): Promise<ViteDevServer>;\nexport async function createViteServer(args: {\n  config: ResolvedTaskConfig;\n  viteConfig: ResolvedViteConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n  mode: 'build';\n}): Promise<PreviewServer>;\nexport async function createViteServer({\n  config,\n  viteConfig,\n  inlineConfig,\n  mode,\n}: {\n  config: ResolvedTaskConfig;\n  viteConfig: ResolvedViteConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n  mode: 'preview' | 'build';\n}) {\n  const viteInlineConfig = {\n    clearScreen: false,\n    configFile: false,\n    appType: 'custom',\n    plugins: [\n      vsDevServerPlugin({ config, inlineConfig }),\n      vsViewerPlugin({ config, inlineConfig }),\n      vsBrowserPlugin({ config, inlineConfig }),\n      vsStaticServePlugin({ config, inlineConfig }),\n    ],\n    server: viteConfig.server,\n    preview: viteConfig.preview,\n    customLogger: viteConfig.customLogger,\n    cacheDir: viteConfig.cacheDir,\n    root: viteConfig.root,\n  } satisfies InlineConfig;\n  Logger.debug('createViteServer > viteInlineConfig %O', viteInlineConfig);\n\n  if (config.serverRootDir === config.workspaceDir) {\n    const { cacheDir } = viteInlineConfig;\n    registerExitHandler('Removing the Vite cacheDir', () => {\n      if (fs.existsSync(cacheDir)) {\n        fs.rmSync(cacheDir, { recursive: true });\n      }\n    });\n  }\n\n  if (mode === 'preview') {\n    return await createServer(viteInlineConfig);\n  } else {\n    return await preview(viteInlineConfig);\n  }\n}\n","import type { NextHandleFunction } from 'connect';\nimport escapeRe from 'escape-string-regexp';\nimport { pathToFileURL } from 'node:url';\nimport sirv, { type RequestHandler } from 'sirv';\nimport upath from 'upath';\nimport * as vite from 'vite';\nimport { locateVivliostyleConfig } from '../config/load.js';\nimport {\n  isWebPubConfig,\n  type ParsedEntry,\n  type ParsedTheme,\n  type ResolvedTaskConfig,\n} from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { Logger } from '../logger.js';\nimport {\n  getAssetMatcher,\n  getWebPubResourceMatcher,\n  GlobMatcher,\n} from '../processor/asset.js';\nimport {\n  generateManifest,\n  prepareThemeDirectory,\n  transformManuscript,\n} from '../processor/compile.js';\nimport {\n  debounce,\n  getFormattedError,\n  pathContains,\n  pathEquals,\n} from '../util.js';\nimport { reloadConfig } from './plugin-util.js';\n\n// Ref: https://github.com/lukeed/sirv\nfunction createEntriesRouteLookup(entries: ParsedEntry[], cwd: string) {\n  const extns = ['', 'html', 'htm'];\n  const toAssume = (uri: string) => {\n    let i = 0,\n      x,\n      len = uri.length - 1;\n    if (uri.charCodeAt(len) === 47) {\n      uri = uri.substring(0, len);\n    }\n    let arr = [],\n      tmp = `${uri}/index`;\n    for (; i < extns.length; i++) {\n      x = extns[i] ? `.${extns[i]}` : '';\n      if (uri) arr.push(uri + x);\n      arr.push(tmp + x);\n    }\n\n    return arr;\n  };\n  const cache = entries.reduce<Record<string, ParsedEntry>>((acc, e) => {\n    acc[`/${upath.relative(cwd, e.target).normalize().replace(/\\\\+/g, '/')}`] =\n      e;\n    return acc;\n  }, {});\n  return (uri: string) => {\n    let i = 0,\n      data,\n      arr = toAssume(uri);\n    for (; i < arr.length; i++) {\n      if ((data = cache[arr[i]])) return [data, arr[i]] as const;\n    }\n  };\n}\n\nfunction getWorkspaceMatcher({\n  workspaceDir,\n  themesDir,\n  viewerInput,\n  themeIndexes,\n  entries,\n  outputs,\n  copyAsset,\n}: ResolvedTaskConfig) {\n  if (viewerInput.type === 'webpub') {\n    return getWebPubResourceMatcher({\n      outputs,\n      themesDir,\n      entries,\n      cwd: workspaceDir,\n      manifestPath: viewerInput.manifestPath,\n      copyAsset,\n    });\n  }\n\n  let entryFiles: string[] = [];\n  switch (viewerInput.type) {\n    case 'epub':\n      entryFiles = [\n        upath.join(\n          upath.relative(workspaceDir, viewerInput.epubTmpOutputDir),\n          '**',\n        ),\n      ];\n      break;\n    case 'epub-opf':\n    case 'webbook':\n      entryFiles = ['**'];\n      break;\n    default:\n      entryFiles = viewerInput satisfies never;\n  }\n\n  return new GlobMatcher([\n    {\n      patterns: entryFiles,\n      ignore: ['node_modules/**'],\n      dot: true,\n      cwd: workspaceDir,\n    },\n  ]);\n}\n\nexport function vsDevServerPlugin({\n  config: _config,\n  inlineConfig,\n}: {\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): vite.Plugin {\n  let config = _config;\n  let server: vite.ViteDevServer | undefined;\n  let program:\n    | {\n        entriesLookup: (\n          uri: string,\n        ) => readonly [ParsedEntry, string] | undefined;\n        urlMatchRe: RegExp;\n        serveWorkspace: RequestHandler;\n        serveWorkspaceMatcher: GlobMatcher;\n        serveAssets: RequestHandler;\n        serveAssetsMatcher: GlobMatcher;\n      }\n    | undefined;\n\n  const transformCache: Map<\n    string,\n    Promise<{ content: string; etag: string } | undefined>\n  > = new Map();\n  let matchProjectDep: (pathname: string) => boolean;\n\n  async function reload(forceUpdate = false) {\n    const prevConfig = config;\n    config = await reloadConfig(prevConfig, inlineConfig, server?.config);\n\n    transformCache.clear();\n    const needToUpdateManifest =\n      forceUpdate ||\n      // FIXME: More precise comparison\n      JSON.stringify(prevConfig) !== JSON.stringify(config);\n    if (\n      isWebPubConfig(config) &&\n      config.viewerInput.needToGenerateManifest &&\n      needToUpdateManifest\n    ) {\n      await generateManifest(config);\n    }\n\n    const localThemePaths = await prepareThemeDirectory(config);\n\n    const entriesLookup = createEntriesRouteLookup(\n      config.entries,\n      config.workspaceDir,\n    );\n    const urlMatchRe = new RegExp(\n      `^${escapeRe(config.base)}(/[^?#]*)([?#].*)?$`,\n    );\n    const serveWorkspace = sirv(config.workspaceDir, {\n      dev: true,\n      etag: false,\n      dotfiles: true,\n      extensions: [],\n    });\n    const serveWorkspaceMatcher = getWorkspaceMatcher(config);\n    const serveAssets = sirv(config.entryContextDir, {\n      dev: true,\n      etag: false,\n      extensions: [],\n    });\n    const serveAssetsMatcher = getAssetMatcher({\n      ...config,\n      cwd: config.entryContextDir,\n    });\n    program = {\n      entriesLookup,\n      urlMatchRe,\n      serveWorkspace,\n      serveWorkspaceMatcher,\n      serveAssets,\n      serveAssetsMatcher,\n    };\n    if (needToUpdateManifest) {\n      Logger.debug(\n        'dev-server > serveWorkspaceMatcher %O',\n        serveWorkspaceMatcher.matcherConfig,\n      );\n      Logger.debug(\n        'dev-server > serveAssetsMatcher %O',\n        serveAssetsMatcher.matcherConfig,\n      );\n    }\n\n    const configPath = locateVivliostyleConfig(inlineConfig);\n    const projectDeps: string[] = [];\n    if (configPath) {\n      projectDeps.push(configPath);\n      server?.watcher.add(configPath);\n    }\n    if (config.viewerInput.type === 'webpub') {\n      projectDeps.push(config.viewerInput.manifestPath);\n      server?.watcher.add(config.viewerInput.manifestPath);\n    }\n\n    const flattenWatchTarget = (themes: Set<ParsedTheme>) =>\n      [...themes].flatMap((theme) => {\n        if (theme.type === 'file') {\n          return [theme.source];\n        }\n        if (theme.type === 'package' && !theme.registry) {\n          return [theme.specifier];\n        }\n        return [];\n      });\n    const prevThemeFiles = flattenWatchTarget(prevConfig.themeIndexes);\n    const themeFiles = flattenWatchTarget(config.themeIndexes);\n    server?.watcher.unwatch(\n      prevThemeFiles.filter((target) => !themeFiles.includes(target)),\n    );\n    server?.watcher.add(themeFiles);\n    server?.watcher.add(localThemePaths);\n    projectDeps.push(...themeFiles, ...localThemePaths);\n    matchProjectDep = (pathname: string) =>\n      projectDeps.some(\n        (dep) => pathEquals(dep, pathname) || pathContains(dep, pathname),\n      );\n  }\n\n  async function transform(entry: ParsedEntry, host: string | undefined) {\n    if (!isWebPubConfig(config)) {\n      return;\n    }\n    // Respect the host header instead of the original rootUrl configuration,\n    // as the dev server may run on a different port through a server other than Vite.\n    const rootUrl = host\n      ? `${server?.config.server.https ? 'https' : 'http'}://${host}`\n      : config.rootUrl;\n    const promise = (async () => {\n      try {\n        const html = await transformManuscript(entry, { ...config, rootUrl });\n        if (!html) {\n          transformCache.delete(entry.target);\n          return;\n        }\n        const etag = `W/\"${Date.now()}\"`;\n        if (entry.source?.type === 'file') {\n          server?.watcher.add(entry.source.pathname);\n        }\n        return { content: html, etag };\n      } catch (error: any) {\n        server?.config.logger.error(getFormattedError(error));\n        transformCache.delete(entry.target);\n        return;\n      }\n    })();\n    transformCache.set(entry.target, promise);\n    return await promise;\n  }\n\n  async function transformAll(host: string | undefined) {\n    const tocEntries: ParsedEntry[] = [];\n    for (const entry of config.entries) {\n      if (entry.rel === 'contents') {\n        // To transpile the table of contents, all dependent content must be transpiled in advance\n        tocEntries.push(entry);\n        continue;\n      }\n      await transform(entry, host);\n    }\n    for (const entry of tocEntries) {\n      await transform(entry, host);\n    }\n  }\n\n  async function invalidate(entry: ParsedEntry) {\n    const cwd = pathToFileURL(config.workspaceDir);\n    const target = pathToFileURL(entry.target);\n    if (target.href.indexOf(cwd.href) !== 0) {\n      return;\n    }\n    transformCache.delete(entry.target);\n    config.entries\n      .filter((entry) => entry.rel === 'contents')\n      .forEach((entry) => {\n        transformCache.delete(entry.target);\n      });\n    server?.ws.send({\n      type: 'full-reload',\n      path: target.href.slice(cwd.href.length),\n    });\n  }\n\n  const devServerMiddleware = async function vivliostyleDevServerMiddleware(\n    req,\n    res,\n    next,\n  ) {\n    if (!program) {\n      return next();\n    }\n    const { entriesLookup, urlMatchRe } = program;\n    const [_, pathname, qs] = decodeURI(req.url!).match(urlMatchRe) ?? [];\n    const match = pathname && entriesLookup(pathname);\n    if (!match) {\n      return next();\n    }\n    const [entry, expected] = match;\n    // Enforce using the actual path to match the full-reload event of the Vite client\n    if (pathname !== expected) {\n      res.statusCode = 301;\n      res.setHeader('Location', `${expected}${qs || ''}`);\n      return res.end();\n    }\n\n    Logger.debug('dev-server > request %s', pathname);\n    const cachePromise = transformCache.get(entry.target);\n    if (cachePromise) {\n      const cached = await cachePromise;\n      if (!cached) {\n        return next();\n      }\n      if (req.headers['if-none-match'] === cached.etag) {\n        res.statusCode = 304;\n        return res.end();\n      } else {\n        res.statusCode = 200;\n        res.setHeader('Content-Type', 'text/html;charset=utf-8');\n        res.setHeader('Cache-Control', 'no-cache');\n        res.setHeader('Etag', cached.etag);\n        return res.end(cached.content);\n      }\n    }\n\n    const { host } = req.headers;\n    if (entry.rel === 'contents') {\n      await transformAll(host);\n    }\n    const result = await transform(entry, host);\n    if (!result) {\n      return next();\n    }\n\n    res.statusCode = 200;\n    res.setHeader('Content-Type', 'text/html;charset=utf-8');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Etag', result.etag);\n    return res.end(result.content);\n  } satisfies NextHandleFunction;\n\n  const serveWorkspaceMiddleware =\n    async function vivliostyleServeWorkspaceMiddleware(req, res, next) {\n      if (!config || !program) {\n        return next();\n      }\n      const {\n        urlMatchRe,\n        serveWorkspace,\n        serveWorkspaceMatcher,\n        serveAssets,\n        serveAssetsMatcher,\n      } = program;\n      const [_, pathname] = decodeURI(req.url!).match(urlMatchRe) ?? [];\n      if (!pathname) {\n        return next();\n      }\n\n      const handleWorkspace = (next: () => void) => {\n        if (!serveWorkspaceMatcher.match(pathname.slice(1))) {\n          return next();\n        }\n        Logger.debug('dev-server > serveWorkspace %s', pathname);\n        const url = req.url!;\n        req.url = req.url!.slice(config.base.length);\n        return serveWorkspace(req, res, () => {\n          req.url = url;\n          next();\n        });\n      };\n\n      const handleAssets = (next: () => void) => {\n        if (!serveAssetsMatcher.match(pathname.slice(1))) {\n          return next();\n        }\n        Logger.debug('dev-server > serveAssets %s', pathname);\n        const url = req.url!;\n        req.url = url!.slice(config.base.length);\n        return serveAssets(req, res, () => {\n          req.url = url;\n          next();\n        });\n      };\n\n      handleWorkspace(() => handleAssets(next));\n    } satisfies NextHandleFunction;\n\n  return {\n    name: 'vivliostyle:dev-server',\n    enforce: 'pre',\n\n    configureServer(viteServer) {\n      server = viteServer;\n      const requestReload = debounce(async () => {\n        await reload();\n        viteServer.ws.send({\n          type: 'full-reload',\n          path: '*',\n        });\n      }, 200);\n      const handleUpdate = (pathname: string) => {\n        if (!matchProjectDep?.(pathname)) {\n          return;\n        }\n        requestReload();\n      };\n      viteServer.watcher.on('add', handleUpdate);\n      viteServer.watcher.on('change', handleUpdate);\n      viteServer.watcher.on('unlink', handleUpdate);\n\n      return () => {\n        viteServer.middlewares.use(devServerMiddleware);\n        viteServer.middlewares.use(serveWorkspaceMiddleware);\n      };\n    },\n    configurePreviewServer(viteServer) {\n      return () => {\n        viteServer.middlewares.use(\n          config.base,\n          sirv(config.workspaceDir, { dev: true, etag: false, extensions: [] }),\n        );\n      };\n    },\n    async buildStart() {\n      await reload(true);\n      await transformAll(undefined);\n    },\n    async handleHotUpdate(ctx) {\n      const entry = config?.entries.find(\n        (e) =>\n          (e.source?.type === 'file' && e.source.pathname === ctx.file) ||\n          (!e.source && e.target === ctx.file),\n      );\n      if (config && entry) {\n        await invalidate(entry);\n      }\n    },\n  };\n}\n","import jsdom, { JSDOM } from '@vivliostyle/jsdom';\nimport { copy, move } from 'fs-extra/esm';\nimport fs from 'node:fs';\nimport upath from 'upath';\nimport serializeToXml from 'w3c-xmlserializer';\nimport MIMEType from 'whatwg-mimetype';\nimport type {\n  ContentsEntry,\n  CoverEntry,\n  ManuscriptEntry,\n  ParsedEntry,\n  ParsedTheme,\n  ResolvedTaskConfig,\n  WebPublicationManifestConfig,\n} from '../config/resolve.js';\nimport type { ArticleEntryConfig } from '../config/schema.js';\nimport { XML_DECLARATION } from '../const.js';\nimport { Logger } from '../logger.js';\nimport { writePublicationManifest } from '../output/webbook.js';\nimport {\n  DetailError,\n  pathContains,\n  pathEquals,\n  registerExitHandler,\n  writeFileIfChanged,\n} from '../util.js';\nimport {\n  createVirtualConsole,\n  generateDefaultCoverHtml,\n  generateDefaultTocHtml,\n  getJsdomFromString,\n  getJsdomFromUrlOrFile,\n  processCoverHtml,\n  processManuscriptHtml,\n  processTocHtml,\n  ResourceLoader,\n} from './html.js';\nimport { processMarkdown } from './markdown.js';\nimport {\n  checkThemeInstallationNecessity,\n  getLocalThemePaths,\n  installThemeDependencies,\n} from './theme.js';\n\nfunction locateThemePath(theme: ParsedTheme, from: string): string | string[] {\n  if (theme.type === 'uri') {\n    return theme.location;\n  }\n  if (theme.type === 'file') {\n    return upath.relative(from, theme.location);\n  }\n  if (theme.importPath) {\n    return [theme.importPath].flat().map((locator) => {\n      const resolvedPath = upath.resolve(theme.location, locator);\n      if (\n        !pathContains(theme.location, resolvedPath) ||\n        !fs.existsSync(resolvedPath)\n      ) {\n        throw new Error(\n          `Could not find a style path ${theme.importPath} for the theme: ${theme.name}.`,\n        );\n      }\n      return upath.relative(from, resolvedPath);\n    });\n  } else {\n    const pkgJsonPath = upath.join(theme.location, 'package.json');\n    const packageJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));\n    const maybeStyle =\n      packageJson?.vivliostyle?.theme?.style ??\n      packageJson.style ??\n      packageJson.main;\n    if (!maybeStyle) {\n      throw new DetailError(\n        `Could not find a style file for the theme: ${theme.name}.`,\n        'Please ensure this package satisfies a `vivliostyle.theme.style` property.',\n      );\n    }\n    return upath.relative(from, upath.join(theme.location, maybeStyle));\n  }\n}\n\nexport async function cleanupWorkspace({\n  entryContextDir,\n  workspaceDir,\n  themesDir,\n  entries,\n}: ResolvedTaskConfig) {\n  if (\n    pathEquals(workspaceDir, entryContextDir) ||\n    pathContains(workspaceDir, entryContextDir) ||\n    entries.some(\n      (entry) =>\n        entry.source?.type === 'file' &&\n        pathContains(workspaceDir, entry.source.pathname),\n    )\n  ) {\n    return;\n  }\n  // workspaceDir is placed on different directory; delete everything excepting theme files\n  Logger.debug('cleanup workspace files', workspaceDir);\n  let movedWorkspacePath: string | undefined;\n  if (pathContains(workspaceDir, themesDir) && fs.existsSync(themesDir)) {\n    movedWorkspacePath = upath.join(\n      upath.dirname(workspaceDir),\n      `.vs-${Date.now()}`,\n    );\n    const movedThemePath = upath.join(\n      movedWorkspacePath,\n      upath.relative(workspaceDir, themesDir),\n    );\n    fs.mkdirSync(upath.dirname(movedThemePath), { recursive: true });\n    registerExitHandler(\n      `Removing the moved workspace directory: ${movedWorkspacePath}`,\n      () => {\n        if (movedWorkspacePath && fs.existsSync(movedWorkspacePath)) {\n          fs.rmSync(movedWorkspacePath, { recursive: true, force: true });\n        }\n      },\n    );\n    await move(themesDir, movedThemePath);\n  }\n  await fs.promises.rm(workspaceDir, { recursive: true, force: true });\n  if (movedWorkspacePath) {\n    await move(movedWorkspacePath, workspaceDir);\n  }\n}\n\nexport async function prepareThemeDirectory({\n  themesDir,\n  themeIndexes,\n}: ResolvedTaskConfig): Promise<string[]> {\n  // Backward compatibility: v8 to v9\n  if (\n    fs.existsSync(upath.join(themesDir, 'packages')) &&\n    !fs.existsSync(upath.join(themesDir, 'node_modules'))\n  ) {\n    fs.renameSync(\n      upath.join(themesDir, 'packages'),\n      upath.join(themesDir, 'node_modules'),\n    );\n  }\n\n  // install theme packages\n  if (await checkThemeInstallationNecessity({ themesDir, themeIndexes })) {\n    Logger.startLogging('Installing theme files');\n    await installThemeDependencies({ themesDir, themeIndexes });\n  }\n\n  // copy theme files\n  for (const theme of themeIndexes) {\n    if (theme.type === 'file' && !pathEquals(theme.source, theme.location)) {\n      fs.mkdirSync(upath.dirname(theme.location), { recursive: true });\n      await copy(theme.source, theme.location);\n    }\n  }\n\n  // Return all local theme paths (symlink targets in node_modules)\n  return getLocalThemePaths({ themesDir });\n}\n\nexport async function transformManuscript(\n  entry: ParsedEntry,\n  {\n    entryContextDir,\n    workspaceDir,\n    viewerInput: { manifestPath },\n    title,\n    entries,\n    language,\n    vfmOptions,\n    rootUrl,\n  }: ResolvedTaskConfig & { viewerInput: WebPublicationManifestConfig },\n): Promise<string | undefined> {\n  const source =\n    entry.rel === 'contents' || entry.rel === 'cover'\n      ? (entry as ContentsEntry | CoverEntry).template\n      : (entry as ManuscriptEntry).source;\n  let content: JSDOM | undefined;\n  let resourceLoader: ResourceLoader | undefined;\n  let resourceUrl: string | undefined;\n\n  // calculate style path\n  const style = entry.themes.flatMap((theme) =>\n    locateThemePath(theme, upath.dirname(entry.target)),\n  );\n\n  if (source?.type === 'file') {\n    if (source.documentProcessor) {\n      // Process with a configured document processor\n      const vfile = await processMarkdown(\n        source.documentProcessor.processorFactory,\n        source.documentProcessor.metadataReader,\n        source.pathname,\n        {\n          ...vfmOptions,\n          style,\n          title: entry.title,\n          language: language ?? undefined,\n        },\n      );\n      content = getJsdomFromString({ html: String(vfile) });\n    } else if (\n      source.contentType === 'text/html' ||\n      source.contentType === 'application/xhtml+xml'\n    ) {\n      content = await getJsdomFromUrlOrFile({ src: source.pathname });\n      content = await processManuscriptHtml(content, {\n        style,\n        title: entry.title,\n        contentType: source.contentType,\n        language,\n      });\n    } else {\n      if (!pathEquals(source.pathname, entry.target)) {\n        await copy(source.pathname, entry.target);\n      }\n    }\n  } else if (source?.type === 'uri') {\n    resourceUrl = /^https?:/.test(source.href)\n      ? source.href\n      : `${rootUrl}${source.href}`;\n    resourceLoader = new ResourceLoader();\n    try {\n      await getJsdomFromUrlOrFile({\n        src: resourceUrl,\n        resourceLoader,\n        virtualConsole: createVirtualConsole((error) => {\n          Logger.logError(`Failed to fetch resources: ${error.detail}`);\n        }),\n      });\n    } catch (error: any) {\n      throw new DetailError(\n        `Failed to fetch the content from ${resourceUrl}`,\n        error.stack ?? error.message,\n      );\n    }\n\n    const contentFetcher = resourceLoader.fetcherMap.get(resourceUrl);\n    if (contentFetcher) {\n      const buffer = await contentFetcher;\n      const contentType = contentFetcher.response?.headers['content-type'];\n      if (!contentType || new MIMEType(contentType).essence !== 'text/html') {\n        throw new Error(`The content is not an HTML document: ${resourceUrl}`);\n      }\n      content = getJsdomFromString({ html: buffer.toString('utf8') });\n      content = await processManuscriptHtml(content, {\n        style,\n        title: entry.title,\n        contentType: 'text/html',\n        language,\n      });\n    }\n  } else if (entry.rel === 'contents') {\n    content = getJsdomFromString({\n      html: generateDefaultTocHtml({\n        language,\n        title,\n      }),\n    });\n    content = await processManuscriptHtml(content, {\n      style,\n      title,\n      contentType: 'text/html',\n      language,\n    });\n  } else if (entry.rel === 'cover') {\n    content = getJsdomFromString({\n      html: generateDefaultCoverHtml({ language, title: entry.title }),\n    });\n    content = await processManuscriptHtml(content, {\n      style,\n      title: entry.title,\n      contentType: 'text/html',\n      language,\n    });\n  }\n\n  if (!content) {\n    return;\n  }\n\n  if (entry.rel === 'contents') {\n    const contentsEntry = entry as ContentsEntry;\n    const manuscriptEntries = entries.filter(\n      (e): e is ManuscriptEntry => 'source' in e,\n    );\n    content = await processTocHtml(content, {\n      entries: manuscriptEntries,\n      manifestPath,\n      distDir: upath.dirname(contentsEntry.target),\n      tocTitle: contentsEntry.tocTitle,\n      sectionDepth: contentsEntry.sectionDepth,\n      styleOptions: contentsEntry,\n      transform: contentsEntry.transform,\n    });\n  }\n\n  if (entry.rel === 'cover') {\n    const coverEntry = entry as CoverEntry;\n    content = await processCoverHtml(content, {\n      imageSrc: upath.relative(\n        upath.join(\n          entryContextDir,\n          upath.relative(workspaceDir, coverEntry.target),\n          '..',\n        ),\n        coverEntry.coverImageSrc,\n      ),\n      imageAlt: coverEntry.coverImageAlt,\n      styleOptions: coverEntry,\n    });\n  }\n\n  let html;\n  if (content.window.document.contentType === 'application/xhtml+xml') {\n    html = `${XML_DECLARATION}\\n${serializeToXml(content.window.document)}`;\n  } else {\n    html = content.serialize();\n  }\n  const htmlBuffer = Buffer.from(html, 'utf8');\n  if (\n    !source ||\n    (source.type === 'file' && !pathEquals(source.pathname, entry.target))\n  ) {\n    writeFileIfChanged(entry.target, htmlBuffer);\n  }\n\n  if (source?.type === 'uri' && resourceLoader && resourceUrl) {\n    const { response } = resourceLoader.fetcherMap.get(resourceUrl)!;\n    const contentFetcher = Promise.resolve(\n      htmlBuffer,\n    ) as jsdom.AbortablePromise<Buffer>;\n    contentFetcher.abort = () => {};\n    contentFetcher.response = response;\n    resourceLoader.fetcherMap.set(resourceUrl, contentFetcher);\n\n    await ResourceLoader.saveFetchedResources({\n      fetcherMap: resourceLoader.fetcherMap,\n      rootUrl: resourceUrl,\n      outputDir: source.rootDir,\n    });\n  }\n\n  return html;\n}\n\nexport async function generateManifest({\n  entryContextDir,\n  workspaceDir,\n  viewerInput: { manifestPath },\n  title,\n  author,\n  entries,\n  language,\n  readingProgression,\n  cover,\n}: ResolvedTaskConfig & { viewerInput: WebPublicationManifestConfig }) {\n  const manifestEntries: ArticleEntryConfig[] = entries.map((entry) => ({\n    title:\n      (entry.rel === 'contents' && (entry as ContentsEntry).tocTitle) ||\n      entry.title,\n    path: upath.relative(workspaceDir, entry.target),\n    encodingFormat:\n      !('contentType' in entry) ||\n      entry.contentType === 'text/markdown' ||\n      entry.contentType === 'text/x-vivliostyle-custom' ||\n      entry.contentType === 'text/html'\n        ? undefined\n        : entry.contentType,\n    rel: entry.rel,\n  }));\n  writePublicationManifest(manifestPath, {\n    title,\n    author,\n    language,\n    readingProgression,\n    cover: cover && {\n      url: upath.relative(entryContextDir, cover.src),\n      name: cover.name,\n    },\n    entries: manifestEntries,\n    modified: new Date().toISOString(),\n  });\n}\n\nexport async function compile(\n  config: ResolvedTaskConfig & { viewerInput: WebPublicationManifestConfig },\n): Promise<void> {\n  const tocEntries: ParsedEntry[] = [];\n  for (const entry of config.entries) {\n    if (entry.rel === 'contents') {\n      // To transpile the table of contents, all dependent entries must be transpiled in advance\n      tocEntries.push(entry);\n      continue;\n    }\n    await transformManuscript(entry, config);\n  }\n  for (const entry of tocEntries) {\n    await transformManuscript(entry, config);\n  }\n\n  // generate manifest\n  if (config.viewerInput.needToGenerateManifest) {\n    await generateManifest(config);\n  }\n}\n","import { copy } from 'fs-extra/esm';\nimport { lookup as mime } from 'mime-types';\nimport fs from 'node:fs';\nimport { pathToFileURL } from 'node:url';\nimport { glob } from 'tinyglobby';\nimport upath from 'upath';\nimport {\n  type EpubOutput,\n  isWebbookConfig,\n  type ResolvedTaskConfig,\n  type WebBookEntryConfig,\n  type WebPublicationOutput,\n} from '../config/resolve.js';\nimport { ArticleEntryConfig } from '../config/schema.js';\nimport { MANIFEST_FILENAME } from '../const.js';\nimport { Logger } from '../logger.js';\nimport {\n  getAssetMatcher,\n  getWebPubResourceMatcher,\n} from '../processor/asset.js';\nimport {\n  createVirtualConsole,\n  fetchLinkedPublicationManifest,\n  getJsdomFromUrlOrFile,\n  ResourceLoader,\n} from '../processor/html.js';\nimport type {\n  PublicationLinks,\n  PublicationManifest,\n  URL as PublicationURL,\n  ResourceCategorization,\n} from '../schema/publication.schema.js';\nimport {\n  assertPubManifestSchema,\n  DetailError,\n  pathEquals,\n  useTmpDirectory,\n} from '../util.js';\nimport { exportEpub } from './epub.js';\n\nfunction sortManifestResources(manifest: PublicationManifest) {\n  if (!Array.isArray(manifest.resources)) {\n    return;\n  }\n  manifest.resources = [...manifest.resources].sort((a, b) =>\n    (typeof a === 'string' ? a : a.url) > (typeof b === 'string' ? b : b.url)\n      ? 1\n      : -1,\n  );\n}\n\nexport async function prepareWebPublicationDirectory({\n  outputDir,\n}: {\n  outputDir: string;\n}): Promise<void> {\n  if (fs.existsSync(outputDir)) {\n    Logger.debug('going to remove existing webpub', outputDir);\n    await fs.promises.rm(outputDir, { force: true, recursive: true });\n  }\n  fs.mkdirSync(outputDir, { recursive: true });\n}\n\nfunction transformPublicationManifest(\n  entity: PublicationManifest,\n  transformer: { url: (str: string) => string },\n): PublicationManifest {\n  const { url: transformUrl } = transformer;\n  const transformUrlOrPublicationLinks = (\n    e: PublicationURL | PublicationLinks,\n  ) => {\n    if (typeof e === 'string') {\n      return transformUrl(e);\n    }\n    const ret = { ...e };\n    ret.url = transformUrl(e.url);\n    return ret;\n  };\n  const ret = { ...entity };\n  for (const [key, tr] of Object.entries({\n    conformsTo: transformUrl,\n    url: transformUrl,\n    readingOrder: transformUrlOrPublicationLinks,\n    resources: transformUrlOrPublicationLinks,\n    links: transformUrlOrPublicationLinks,\n  })) {\n    if (key in ret) {\n      ret[key] = Array.isArray(ret[key])\n        ? ret[key].map(tr)\n        : tr(ret[key] as string);\n    }\n  }\n  return ret;\n}\n\nexport function decodePublicationManifest(input: PublicationManifest) {\n  return transformPublicationManifest(input, {\n    url: decodeURI,\n  });\n}\n\nfunction encodePublicationManifest(input: PublicationManifest) {\n  return transformPublicationManifest(input, {\n    url: encodeURI,\n  });\n}\n\n// https://www.w3.org/TR/pub-manifest/\nexport function writePublicationManifest(\n  output: string,\n  options: {\n    title?: string;\n    author?: string;\n    language?: string;\n    readingProgression?: 'ltr' | 'rtl';\n    modified: string;\n    entries: ArticleEntryConfig[];\n    cover?: {\n      url: string;\n      name: string;\n    };\n    links?: (PublicationURL | PublicationLinks)[];\n    resources?: (PublicationURL | PublicationLinks)[];\n  },\n): PublicationManifest {\n  const entries: PublicationLinks[] = options.entries.map((entry) => ({\n    url: entry.path,\n    ...(entry.title && { name: entry.title }),\n    ...(entry.encodingFormat && { encodingFormat: entry.encodingFormat }),\n    ...(entry.rel && { rel: entry.rel }),\n    ...((entry.rel === 'contents' || entry.rel === 'cover') && {\n      type: 'LinkedResource',\n    }),\n  }));\n  const links: (PublicationURL | PublicationLinks)[] = [\n    options.links || [],\n  ].flat();\n  const resources: (PublicationURL | PublicationLinks)[] = [\n    options.resources || [],\n  ].flat();\n\n  if (options.cover) {\n    const mimeType = mime(options.cover.url);\n    if (mimeType) {\n      resources.push({\n        rel: 'cover',\n        url: options.cover.url,\n        name: options.cover.name,\n        encodingFormat: mimeType,\n      });\n    } else {\n      Logger.logWarn(\n        `Cover image \"${options.cover}\" was set in your configuration but couldnâ€™t detect the image metadata. Please check a valid cover file is placed.`,\n      );\n    }\n  }\n\n  const publication: PublicationManifest = {\n    '@context': ['https://schema.org', 'https://www.w3.org/ns/pub-context'],\n    type: 'Book',\n    conformsTo: 'https://github.com/vivliostyle/vivliostyle-cli',\n    ...(options.title && { name: options.title }),\n    ...(options.author && { author: options.author }),\n    ...(options.language && { inLanguage: options.language }),\n    ...(options.readingProgression && {\n      readingProgression: options.readingProgression,\n    }),\n    dateModified: options.modified,\n    readingOrder: entries,\n    resources,\n    links,\n  };\n\n  const encodedManifest = encodePublicationManifest(publication);\n  Logger.debug(\n    'writePublicationManifest path: %s content: %O',\n    output,\n    encodedManifest,\n  );\n  try {\n    assertPubManifestSchema(encodedManifest);\n  } catch (error) {\n    const thrownError = error as Error | string;\n    throw new DetailError(\n      `Validation of publication manifest failed. Please check the schema: ${output}`,\n      typeof thrownError === 'string'\n        ? thrownError\n        : (thrownError.stack ?? thrownError.message),\n    );\n  }\n  fs.mkdirSync(upath.dirname(output), { recursive: true });\n  fs.writeFileSync(output, JSON.stringify(encodedManifest, null, 2));\n  return publication;\n}\n\nexport async function retrieveWebbookEntry({\n  viewerInput,\n  outputDir,\n}: {\n  viewerInput: WebBookEntryConfig;\n  outputDir: string;\n}): Promise<{\n  entryHtmlFile: string;\n  manifest: PublicationManifest | undefined;\n}> {\n  const webbookEntryUrl = viewerInput.webbookPath\n    ? pathToFileURL(viewerInput.webbookPath).href\n    : viewerInput.webbookEntryUrl;\n  if (/^https?:/i.test(webbookEntryUrl)) {\n    Logger.logUpdate('Fetching remote contents');\n  }\n  const resourceLoader = new ResourceLoader();\n  const dom = await getJsdomFromUrlOrFile({\n    src: webbookEntryUrl,\n    resourceLoader,\n  });\n  const entryHtml = viewerInput.webbookPath\n    ? upath.basename(viewerInput.webbookPath)\n    : decodeURI(dom.window.location.pathname);\n\n  const { manifest, manifestUrl } =\n    (await fetchLinkedPublicationManifest({\n      dom,\n      resourceLoader,\n      baseUrl: webbookEntryUrl,\n    })) || {};\n\n  let pathContains: (url: string) => boolean;\n  if (webbookEntryUrl.startsWith('data:')) {\n    pathContains = (url) => false;\n  } else {\n    const rootUrl = /^https?:/i.test(webbookEntryUrl)\n      ? new URL('/', webbookEntryUrl).href\n      : new URL('.', webbookEntryUrl).href;\n    pathContains = (url: string) =>\n      !upath.relative(rootUrl, url).startsWith('..');\n  }\n  const retriever = new Map(resourceLoader.fetcherMap);\n\n  if (manifest && manifestUrl) {\n    [manifest.resources || []].flat().forEach((v) => {\n      const url = typeof v === 'string' ? v : v.url;\n      const fullUrl = new URL(encodeURI(url), manifestUrl).href;\n      if (!pathContains(fullUrl) || retriever.has(fullUrl)) {\n        return;\n      }\n      const fetchPromise = resourceLoader.fetch(fullUrl);\n      if (fetchPromise && !retriever.has(fullUrl)) {\n        retriever.set(fullUrl, fetchPromise);\n      }\n    });\n    for (const v of [manifest.readingOrder || []].flat()) {\n      const url = typeof v === 'string' ? v : v.url;\n      if (\n        !/\\.html?$/.test(url) &&\n        !(typeof v === 'string' || v.encodingFormat === 'text/html')\n      ) {\n        continue;\n      }\n      const fullUrl = new URL(encodeURI(url), manifestUrl).href;\n      if (!pathContains(fullUrl) || fullUrl === webbookEntryUrl) {\n        continue;\n      }\n      const subpathResourceLoader = new ResourceLoader();\n      await getJsdomFromUrlOrFile({\n        src: fullUrl,\n        resourceLoader: subpathResourceLoader,\n        virtualConsole: createVirtualConsole((error) => {\n          Logger.logError(`Failed to fetch webbook resources: ${error.detail}`);\n        }),\n      });\n      subpathResourceLoader.fetcherMap.forEach(\n        (v, k) => !retriever.has(k) && retriever.set(k, v),\n      );\n    }\n  }\n\n  const fetchedResources = await ResourceLoader.saveFetchedResources({\n    fetcherMap: retriever,\n    rootUrl: webbookEntryUrl,\n    outputDir,\n    /* v8 ignore next 4 */\n    onError: (error) => {\n      Logger.debug(error);\n      Logger.logError(`Failed to fetch webbook resources: ${error}`);\n    },\n  });\n\n  if (manifest) {\n    const referencedContents = [\n      ...[manifest.readingOrder || []].flat(),\n      ...[manifest.resources || []].flat(),\n    ].map((v) => (typeof v === 'string' ? v : v.url));\n    manifest.resources = [\n      ...[manifest.resources || []].flat(),\n      ...fetchedResources.filter(\n        ({ url }) => !referencedContents.includes(url),\n      ),\n    ];\n    sortManifestResources(manifest);\n  }\n\n  Logger.debug(\n    'Saved webbook resources',\n    fetchedResources.map((v) => v.url),\n  );\n  Logger.debug(\n    'Publication manifest from webbook',\n    manifest && JSON.stringify(manifest, null, 2),\n  );\n\n  return {\n    entryHtmlFile: upath.join(\n      outputDir,\n      entryHtml,\n      ...(upath.extname(entryHtml) ? [] : ['index.html']),\n    ),\n    manifest,\n  };\n}\n\nexport async function supplyWebPublicationManifestForWebbook({\n  entryHtmlFile,\n  outputDir,\n  ...config\n}: Pick<\n  ResolvedTaskConfig,\n  'language' | 'title' | 'author' | 'readingProgression'\n> & {\n  entryHtmlFile: string;\n  outputDir: string;\n}): Promise<PublicationManifest> {\n  Logger.debug(`Generating publication manifest from HTML: ${entryHtmlFile}`);\n  const dom = await getJsdomFromUrlOrFile({ src: entryHtmlFile });\n  const { document } = dom.window;\n  const language =\n    config.language || document.documentElement.lang || undefined;\n  const title = config.title || document.title || '';\n  const author =\n    config.author ||\n    document.querySelector('meta[name=\"author\"]')?.getAttribute('content') ||\n    '';\n\n  const entry = upath.relative(outputDir, entryHtmlFile);\n  const allFiles = await glob('**', {\n    cwd: outputDir,\n  });\n\n  const manifest = writePublicationManifest(\n    upath.join(outputDir, MANIFEST_FILENAME),\n    {\n      title,\n      author,\n      language,\n      readingProgression: config.readingProgression,\n      modified: new Date().toISOString(),\n      entries: [{ path: entry }],\n      resources: allFiles.filter((f) => f !== entry),\n    },\n  );\n  sortManifestResources(manifest);\n  const link = document.createElement('link');\n  link.setAttribute('rel', 'publication');\n  link.setAttribute('type', 'application/ld+json');\n  link.setAttribute(\n    'href',\n    upath.relative(\n      upath.dirname(entryHtmlFile),\n      upath.join(outputDir, MANIFEST_FILENAME),\n    ),\n  );\n  document.head.appendChild(link);\n  await fs.promises.writeFile(entryHtmlFile, dom.serialize(), 'utf8');\n\n  Logger.debug(\n    'Generated publication manifest from HTML',\n    JSON.stringify(manifest, null, 2),\n  );\n  return manifest;\n}\n\nexport async function copyWebPublicationAssets({\n  exportAliases,\n  outputs,\n  copyAsset,\n  themesDir,\n  manifestPath,\n  input,\n  outputDir,\n  entries,\n}: Pick<\n  ResolvedTaskConfig,\n  'exportAliases' | 'outputs' | 'copyAsset' | 'themesDir' | 'entries'\n> & {\n  input: string;\n  outputDir: string;\n  manifestPath: string;\n}): Promise<{ manifest: PublicationManifest; actualManifestPath: string }> {\n  const relExportAliases = exportAliases\n    .map(({ source, target }) => ({\n      source: upath.relative(input, source),\n      target: upath.relative(input, target),\n    }))\n    .filter(({ source }) => !source.startsWith('..'));\n  const assetMatcher = getAssetMatcher({\n    copyAsset,\n    cwd: input,\n    outputs,\n    themesDir,\n    entries,\n  });\n  const webResourceMatcher = getWebPubResourceMatcher({\n    cwd: input,\n    outputs,\n    themesDir,\n    entries,\n    manifestPath,\n    copyAsset,\n  });\n  const allFiles = new Set([\n    ...(await assetMatcher.glob()),\n    ...(await webResourceMatcher.glob({\n      // follow symbolic links to copy local theme packages\n      followSymbolicLinks: true,\n    })),\n  ]);\n  // Exclude files that will overwrite alias targets\n  for (const alias of relExportAliases) {\n    allFiles.delete(alias.target);\n  }\n\n  Logger.debug(\n    'webbook files',\n    JSON.stringify(\n      [...allFiles].map((file) => {\n        const alias = relExportAliases.find(({ source }) => source === file);\n        return alias ? `${file} (alias: ${alias.target})` : file;\n      }),\n      null,\n      2,\n    ),\n  );\n  const resources: string[] = [];\n  let actualManifestPath = upath.join(\n    outputDir,\n    upath.relative(input, manifestPath),\n  );\n  for (const file of allFiles) {\n    const alias = relExportAliases.find(({ source }) => source === file);\n    const relTarget = alias?.target || file;\n    resources.push(relTarget);\n    const target = upath.join(outputDir, relTarget);\n    fs.mkdirSync(upath.dirname(target), { recursive: true });\n    await copy(upath.join(input, file), target);\n    if (alias && pathEquals(upath.join(input, alias.source), manifestPath)) {\n      actualManifestPath = target;\n    }\n  }\n\n  Logger.debug('webbook publication.json', actualManifestPath);\n  // Overwrite copied publication.json\n  const manifest = decodePublicationManifest(\n    JSON.parse(fs.readFileSync(actualManifestPath, 'utf8')),\n  );\n  for (const entry of relExportAliases) {\n    const rewriteAliasPath = (e: PublicationLinks | string) => {\n      if (typeof e === 'string') {\n        return pathEquals(e, entry.source) ? entry.source : e;\n      }\n      if (pathEquals(e.url, entry.source)) {\n        e.url = entry.target;\n      }\n      return e;\n    };\n    if (manifest.links) {\n      manifest.links = Array.isArray(manifest.links)\n        ? manifest.links.map(rewriteAliasPath)\n        : rewriteAliasPath(manifest.links);\n    }\n    if (manifest.readingOrder) {\n      manifest.readingOrder = Array.isArray(manifest.readingOrder)\n        ? manifest.readingOrder.map(rewriteAliasPath)\n        : rewriteAliasPath(manifest.readingOrder);\n    }\n    if (manifest.resources) {\n      manifest.resources = Array.isArray(manifest.resources)\n        ? manifest.resources.map(rewriteAliasPath)\n        : rewriteAliasPath(manifest.resources);\n    }\n  }\n\n  // List copied files to resources field\n  const normalizeToUrl = (val?: ResourceCategorization) =>\n    [val || []].flat().map((e) => (typeof e === 'string' ? e : e.url));\n  const preDefinedResources = [\n    ...normalizeToUrl(manifest.links),\n    ...normalizeToUrl(manifest.readingOrder),\n    ...normalizeToUrl(manifest.resources),\n  ];\n  manifest.resources = [\n    ...[manifest.resources || []].flat(),\n    ...resources.flatMap((file) => {\n      if (\n        preDefinedResources.includes(file) ||\n        // Omit publication.json itself\n        pathEquals(file, upath.relative(outputDir, actualManifestPath))\n      ) {\n        return [];\n      }\n      return file;\n    }),\n  ];\n  sortManifestResources(manifest);\n  fs.writeFileSync(\n    actualManifestPath,\n    JSON.stringify(encodePublicationManifest(manifest), null, 2),\n  );\n  return { manifest, actualManifestPath };\n}\n\nexport async function buildWebPublication({\n  target,\n  config,\n}: {\n  target: WebPublicationOutput | EpubOutput;\n  config: ResolvedTaskConfig;\n}): Promise<string> {\n  let outputDir: string;\n  if (target.format === 'webpub') {\n    outputDir = target.path;\n    await prepareWebPublicationDirectory({ outputDir });\n  } else {\n    [outputDir] = await useTmpDirectory();\n  }\n\n  let entryHtmlFile: string | undefined;\n  let manifest: PublicationManifest;\n  let actualManifestPath: string | undefined;\n  if (config.viewerInput.type === 'webpub') {\n    const ret = await copyWebPublicationAssets({\n      ...config,\n      input: config.workspaceDir,\n      outputDir,\n      manifestPath: config.viewerInput.manifestPath,\n    });\n    manifest = ret.manifest;\n    actualManifestPath = ret.actualManifestPath;\n    if (config.input.format === 'markdown') {\n      const entry = [manifest.readingOrder].flat()[0];\n      if (entry) {\n        entryHtmlFile = upath.join(\n          outputDir,\n          typeof entry === 'string' ? entry : entry.url,\n        );\n      }\n    }\n  } else if (isWebbookConfig(config)) {\n    const ret = await retrieveWebbookEntry({\n      viewerInput: config.viewerInput,\n      outputDir,\n    });\n    entryHtmlFile = ret.entryHtmlFile;\n    manifest =\n      ret.manifest ||\n      (await supplyWebPublicationManifestForWebbook({\n        ...config,\n        entryHtmlFile: ret.entryHtmlFile,\n        outputDir,\n      }));\n  } else {\n    throw new Error('No entry specified');\n  }\n\n  if (target.format === 'epub') {\n    await exportEpub({\n      webpubDir: outputDir,\n      entryHtmlFile,\n      manifest,\n      relManifestPath:\n        actualManifestPath && upath.relative(outputDir, actualManifestPath),\n      target: target.path,\n      epubVersion: target.version,\n    });\n  }\n  return target.path;\n}\n","import jsdom, {\n  type AbortablePromise,\n  ResourceLoader as BaseResourceLoader,\n  JSDOM,\n  VirtualConsole,\n} from '@vivliostyle/jsdom';\nimport DOMPurify, { type WindowLike } from 'dompurify';\nimport { toHtml } from 'hast-util-to-html';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport upath from 'upath';\nimport MIMEType from 'whatwg-mimetype';\nimport type { ManuscriptEntry } from '../config/resolve.js';\nimport type {\n  StructuredDocument,\n  StructuredDocumentSection,\n} from '../config/schema.js';\nimport { Logger } from '../logger.js';\nimport { decodePublicationManifest } from '../output/webbook.js';\nimport type { PublicationManifest } from '../schema/publication.schema.js';\nimport {\n  DetailError,\n  assertPubManifestSchema,\n  isValidUri,\n  writeFileIfChanged,\n} from '../util.js';\n\nexport const createVirtualConsole = (onError: (error: DetailError) => void) => {\n  const virtualConsole = new jsdom.VirtualConsole();\n  /* v8 ignore start */\n  virtualConsole.on('error', (message) => {\n    Logger.debug('[JSDOM Console] error:', message);\n  });\n  virtualConsole.on('warn', (message) => {\n    Logger.debug('[JSDOM Console] warn:', message);\n  });\n  virtualConsole.on('log', (message) => {\n    Logger.debug('[JSDOM Console] log:', message);\n  });\n  virtualConsole.on('info', (message) => {\n    Logger.debug('[JSDOM Console] info:', message);\n  });\n  virtualConsole.on('dir', (message) => {\n    Logger.debug('[JSDOM Console] dir:', message);\n  });\n  virtualConsole.on('jsdomError', (error) => {\n    // Most of CSS using Paged media will be failed to run CSS parser of JSDOM.\n    // We just ignore it because we don't use CSS parse results.\n    // https://github.com/jsdom/jsdom/blob/a39e0ec4ce9a8806692d986a7ed0cd565ec7498a/lib/jsdom/living/helpers/stylesheets.js#L33-L44\n    // see also: https://github.com/jsdom/jsdom/issues/2005\n    if (error.message === 'Could not parse CSS stylesheet') {\n      return;\n    }\n    onError(\n      new DetailError(\n        'Error occurred when loading content',\n        error.stack ?? error.message,\n      ),\n    );\n  });\n  /* v8 ignore stop */\n  return virtualConsole;\n};\n\nexport const htmlPurify = DOMPurify(\n  // @ts-expect-error: jsdom.DOMWindow should have trustedTypes property\n  new JSDOM('').window as WindowLike,\n);\n\nexport class ResourceLoader extends BaseResourceLoader {\n  static dataUrlOrigin = 'http://localhost/' as const;\n\n  fetcherMap = new Map<string, jsdom.AbortablePromise<Buffer>>();\n\n  fetch(url: string, options?: jsdom.FetchOptions) {\n    Logger.debug(`[JSDOM] Fetching resource: ${url}`);\n    const fetcher = super.fetch(url, options);\n    if (fetcher) {\n      this.fetcherMap.set(url, fetcher);\n    }\n    return fetcher;\n  }\n\n  static async saveFetchedResources({\n    fetcherMap,\n    rootUrl,\n    outputDir,\n    onError,\n  }: {\n    fetcherMap: Map<string, jsdom.AbortablePromise<Buffer>>;\n    rootUrl: string;\n    outputDir: string;\n    onError?: (error: Error) => void;\n  }) {\n    const rootHref = rootUrl.startsWith('data:')\n      ? ResourceLoader.dataUrlOrigin\n      : /^https?:/i.test(rootUrl)\n        ? new URL('/', rootUrl).href\n        : new URL('.', rootUrl).href;\n\n    const normalizeToLocalPath = (urlString: string, mimeType?: string) => {\n      let url = new URL(urlString);\n      url.hash = '';\n      if (mimeType === 'text/html' && !/\\.html?$/.test(url.pathname)) {\n        url.pathname = `${url.pathname.replace(/\\/$/, '')}/index.html`;\n      }\n      let relTarget = upath.relative(rootHref, url.href);\n      return decodeURI(relTarget);\n    };\n\n    const fetchedResources: { url: string; encodingFormat?: string }[] = [];\n    await Promise.allSettled(\n      [...fetcherMap.entries()].flatMap(async ([url, fetcher]) => {\n        if (!url.startsWith(rootHref)) {\n          return [];\n        }\n        return (\n          fetcher\n            .then(async (buffer) => {\n              let encodingFormat: string | undefined;\n              try {\n                const contentType = fetcher.response?.headers['content-type'];\n                if (contentType) {\n                  encodingFormat = new MIMEType(contentType).essence;\n                }\n                /* v8 ignore next 3 */\n              } catch (e) {\n                /* NOOP */\n              }\n              const relTarget = normalizeToLocalPath(url, encodingFormat);\n              const target = upath.join(outputDir, relTarget);\n              fetchedResources.push({ url: relTarget, encodingFormat });\n              writeFileIfChanged(target, buffer);\n            })\n            /* v8 ignore next */\n            .catch(onError)\n        );\n      }),\n    );\n    return fetchedResources;\n  }\n}\n\nexport async function getJsdomFromUrlOrFile({\n  src,\n  resourceLoader,\n  virtualConsole = createVirtualConsole((error) => {\n    throw error;\n  }),\n}: {\n  src: string;\n  resourceLoader?: ResourceLoader;\n  virtualConsole?: VirtualConsole;\n}) {\n  const url = isValidUri(src) ? new URL(src) : pathToFileURL(src);\n  let dom: JSDOM;\n  if (url.protocol === 'http:' || url.protocol === 'https:') {\n    dom = await JSDOM.fromURL(src, {\n      virtualConsole,\n      resources: resourceLoader,\n    });\n  } else if (url.protocol === 'file:') {\n    if (resourceLoader) {\n      const file = resourceLoader._readFile(fileURLToPath(url));\n      resourceLoader.fetcherMap.set(url.href, file);\n    }\n    dom = await JSDOM.fromFile(fileURLToPath(url), {\n      virtualConsole,\n      resources: resourceLoader,\n      contentType:\n        src.endsWith('.xhtml') || src.endsWith('.xml')\n          ? 'application/xhtml+xml; charset=UTF-8'\n          : 'text/html; charset=UTF-8',\n    });\n  } else if (url.protocol === 'data:') {\n    const [head, body] = url.href.split(',', 2);\n    const data = decodeURIComponent(body);\n    const buffer = Buffer.from(\n      data,\n      /;base64$/i.test(head) ? 'base64' : 'utf8',\n    );\n    const dummyUrl = `${ResourceLoader.dataUrlOrigin}index.html`;\n    if (resourceLoader) {\n      let timeoutId: ReturnType<typeof setTimeout>;\n      const promise = new Promise((resolve) => {\n        timeoutId = setTimeout(resolve, 0, buffer);\n      }) as AbortablePromise<Buffer>;\n      promise.abort = () => {\n        if (timeoutId !== undefined) {\n          clearTimeout(timeoutId);\n        }\n      };\n      resourceLoader.fetcherMap.set(dummyUrl, promise);\n    }\n    dom = new JSDOM(buffer.toString(), {\n      virtualConsole,\n      resources: resourceLoader,\n      contentType: 'text/html; charset=UTF-8',\n      url: dummyUrl,\n    });\n  } else {\n    throw new Error(`Unsupported protocol: ${url.protocol}`);\n  }\n  return dom;\n}\n\nexport function getJsdomFromString({\n  html,\n  virtualConsole = createVirtualConsole((error) => {\n    throw error;\n  }),\n}: {\n  html: string;\n  virtualConsole?: VirtualConsole;\n}) {\n  return new JSDOM(html, {\n    virtualConsole,\n  });\n}\n\nexport async function getStructuredSectionFromHtml(\n  htmlPath: string,\n  href?: string,\n) {\n  const dom = await getJsdomFromUrlOrFile({ src: htmlPath });\n  const { document } = dom.window;\n  const allHeadings = [...document.querySelectorAll('h1, h2, h3, h4, h5, h6')]\n    .filter((el) => {\n      // Exclude headings contained by blockquote\n      // TODO: Make customizable\n      return !el.matches('blockquote *');\n    })\n    .sort((a, b) => {\n      const position = a.compareDocumentPosition(b);\n      return position & 2 /* DOCUMENT_POSITION_PRECEDING */\n        ? 1\n        : position & 4 /* DOCUMENT_POSITION_FOLLOWING */\n          ? -1\n          : 0;\n    });\n\n  function traverse(headers: Element[]): StructuredDocumentSection[] {\n    if (headers.length === 0) {\n      return [];\n    }\n    const [head, ...tail] = headers;\n    const section = head.parentElement!;\n    const id = head.id || section.id;\n    const level = Number(head.tagName.slice(1));\n    let i = tail.findIndex((s) => Number(s.tagName.slice(1)) <= level);\n    i = i === -1 ? tail.length : i;\n    return [\n      {\n        headingHtml: htmlPurify.sanitize(head.innerHTML),\n        headingText: head.textContent?.trim().replace(/\\s+/g, ' ') || '',\n        level,\n        ...(href && id && { href: `${href}#${encodeURIComponent(id)}` }),\n        ...(id && { id }),\n        children: traverse(tail.slice(0, i)),\n      },\n      ...traverse(tail.slice(i)),\n    ];\n  }\n  return traverse(allHeadings);\n}\n\nconst getTocHtmlStyle = ({\n  pageBreakBefore,\n  pageCounterReset,\n}: {\n  pageBreakBefore?: 'recto' | 'verso' | 'left' | 'right';\n  pageCounterReset?: number;\n}) => {\n  if (!pageBreakBefore && typeof pageCounterReset !== 'number') {\n    return null;\n  }\n  return /* css */ `\n${\n  pageBreakBefore\n    ? /* css */ `:root {\n  break-before: ${pageBreakBefore};\n}`\n    : ''\n}\n${\n  // Note: `--vs-document-first-page-counter-reset` is reserved variable name in Vivliostyle base themes\n  typeof pageCounterReset === 'number'\n    ? /* css */ `@page :nth(1) {\n  --vs-document-first-page-counter-reset: page ${Math.floor(pageCounterReset - 1)};\n  counter-reset: var(--vs-document-first-page-counter-reset);\n}`\n    : ''\n}\n`;\n};\n\ntype HastElement = import('hast').ElementContent | import('hast').Root;\n\nexport const defaultTocTransform = {\n  transformDocumentList:\n    (nodeList: StructuredDocument[]) =>\n    (propsList: { children: HastElement | HastElement[] }[]): HastElement => {\n      return (\n        <ol>\n          {nodeList\n            .map((a, i) => [a, propsList[i]] as const)\n            .flatMap(\n              ([{ href, title, sections }, { children, ...otherProps }]) => {\n                // don't display the document title if it has only one top-level H1 heading\n                if (sections?.length === 1 && sections[0].level === 1) {\n                  return [children].flat().flatMap((e) => {\n                    if (e.type === 'element' && e.tagName === 'ol') {\n                      return e.children;\n                    }\n                    return e;\n                  });\n                }\n                return (\n                  <li {...otherProps}>\n                    <a {...{ href }}>{title}</a>\n                    {children}\n                  </li>\n                );\n              },\n            )}\n        </ol>\n      );\n    },\n  transformSectionList:\n    (nodeList: StructuredDocumentSection[]) =>\n    (propsList: { children: HastElement | HastElement[] }[]): HastElement => {\n      return (\n        <ol>\n          {nodeList\n            .map((a, i) => [a, propsList[i]] as const)\n            .map(\n              ([{ headingHtml, href, level }, { children, ...otherProps }]) => {\n                const headingContent = {\n                  type: 'raw',\n                  value: headingHtml,\n                };\n                return (\n                  <li {...otherProps} data-section-level={level}>\n                    {href ? (\n                      <a {...{ href }}>{headingContent}</a>\n                    ) : (\n                      <span>{headingContent}</span>\n                    )}\n                    {children}\n                  </li>\n                );\n              },\n            )}\n        </ol>\n      );\n    },\n};\n\nexport function generateDefaultTocHtml({\n  language,\n  title,\n}: {\n  language?: string;\n  title?: string;\n}) {\n  const toc = (\n    <html lang={language}>\n      <head>\n        <meta charset=\"utf-8\" />\n        <title>{title || ''}</title>\n        <style data-vv-style></style>\n      </head>\n      <body>\n        <h1>{title || ''}</h1>\n        <nav id=\"toc\" role=\"doc-toc\" />\n      </body>\n    </html>\n  );\n  return toHtml(toc);\n}\n\nexport async function generateTocListSection({\n  entries,\n  distDir,\n  sectionDepth,\n  transform = {},\n}: {\n  entries: Pick<ManuscriptEntry, 'target' | 'title'>[];\n  distDir: string;\n  sectionDepth: number;\n  transform?: Partial<typeof defaultTocTransform>;\n}): Promise<string> {\n  const {\n    transformDocumentList = defaultTocTransform.transformDocumentList,\n    transformSectionList = defaultTocTransform.transformSectionList,\n  } = transform;\n\n  const structure = await Promise.all(\n    entries.map(async (entry) => {\n      const href = encodeURI(upath.relative(distDir, entry.target));\n      const sections =\n        sectionDepth >= 1\n          ? await getStructuredSectionFromHtml(entry.target, href)\n          : [];\n      return {\n        title: entry.title || upath.basename(entry.target, '.html'),\n        href: encodeURI(upath.relative(distDir, entry.target)),\n        sections,\n        children: [], // TODO\n      };\n    }),\n  );\n  const docToc = transformDocumentList(structure)(\n    structure.map((doc) => {\n      function renderSectionList(\n        sections: StructuredDocumentSection[],\n      ): HastElement | HastElement[] {\n        const nodeList = sections.flatMap((section) => {\n          if (section.level > sectionDepth) {\n            return [];\n          }\n          return section;\n        });\n        if (nodeList.length === 0) {\n          return [];\n        }\n        return transformSectionList(nodeList)(\n          nodeList.map((node) => ({\n            children: [renderSectionList(node.children || [])].flat(),\n          })),\n        );\n      }\n      return {\n        children: [renderSectionList(doc.sections || [])].flat(),\n      };\n    }),\n  );\n\n  return toHtml(docToc, { allowDangerousHtml: true });\n}\n\nexport async function processTocHtml(\n  dom: JSDOM,\n  {\n    manifestPath,\n    tocTitle,\n    styleOptions = {},\n    entries,\n    distDir,\n    sectionDepth,\n    transform,\n  }: Parameters<typeof generateTocListSection>[0] & {\n    manifestPath: string;\n    tocTitle: string;\n    styleOptions?: Parameters<typeof getTocHtmlStyle>[0];\n  },\n): Promise<JSDOM> {\n  const { document } = dom.window;\n  if (\n    !document.querySelector(\n      'link[rel=\"publication\"][type=\"application/ld+json\"]',\n    )\n  ) {\n    const l = document.createElement('link');\n    l.setAttribute('rel', 'publication');\n    l.setAttribute('type', 'application/ld+json');\n    l.setAttribute('href', encodeURI(upath.relative(distDir, manifestPath)));\n    document.head.appendChild(l);\n  }\n\n  const style = document.querySelector('style[data-vv-style]');\n  if (style) {\n    const textContent = getTocHtmlStyle(styleOptions);\n    if (textContent) {\n      style.textContent = textContent;\n    } else {\n      style.remove();\n    }\n  }\n\n  const nav = document.querySelector('nav, [role=\"doc-toc\"]');\n  if (nav && !nav.hasChildNodes()) {\n    const h2 = document.createElement('h2');\n    h2.textContent = tocTitle;\n    nav.appendChild(h2);\n    nav.innerHTML += await generateTocListSection({\n      entries,\n      distDir,\n      sectionDepth,\n      transform,\n    });\n  }\n  return dom;\n}\n\nconst getCoverHtmlStyle = ({\n  pageBreakBefore,\n}: {\n  pageBreakBefore?: 'recto' | 'verso' | 'left' | 'right';\n}) => /* css */ `\n${\n  pageBreakBefore\n    ? `:root {\n  break-before: ${pageBreakBefore};\n}`\n    : ''\n}\nbody {\n  margin: 0;\n}\n[role=\"doc-cover\"] {\n  display: block;\n  width: 100vw;\n  height: 100vh;\n  object-fit: contain;\n}\n@page {\n  margin: 0;\n}\n`;\n\nexport function generateDefaultCoverHtml({\n  language,\n  title,\n}: {\n  language?: string;\n  title?: string;\n}) {\n  const toc = (\n    <html lang={language}>\n      <head>\n        <meta charset=\"utf-8\" />\n        <title>{title || ''}</title>\n        <style data-vv-style></style>\n      </head>\n      <body>\n        <section role=\"region\" aria-label=\"Cover\">\n          <img role=\"doc-cover\" />\n        </section>\n      </body>\n    </html>\n  );\n  return toHtml(toc);\n}\n\nexport async function processCoverHtml(\n  dom: JSDOM,\n  {\n    imageSrc,\n    imageAlt,\n    styleOptions = {},\n  }: {\n    imageSrc: string;\n    imageAlt: string;\n    styleOptions?: Parameters<typeof getCoverHtmlStyle>[0];\n  },\n): Promise<JSDOM> {\n  const { document } = dom.window;\n  const style = document.querySelector('style[data-vv-style]');\n  if (style) {\n    const textContent = getCoverHtmlStyle(styleOptions);\n    if (textContent) {\n      style.textContent = textContent;\n    } else {\n      style.remove();\n    }\n  }\n\n  const cover = document.querySelector('img[role=\"doc-cover\"]');\n  if (cover && !cover.hasAttribute('src')) {\n    cover.setAttribute('src', encodeURI(imageSrc));\n  }\n  if (cover && !cover.hasAttribute('alt')) {\n    cover.setAttribute('alt', imageAlt);\n  }\n  return dom;\n}\n\nexport async function processManuscriptHtml(\n  dom: JSDOM,\n  {\n    title,\n    style,\n    contentType,\n    language,\n  }: {\n    title?: string;\n    style?: string[];\n    contentType?: 'text/html' | 'application/xhtml+xml';\n    language?: string | null;\n  },\n): Promise<JSDOM> {\n  const { document } = dom.window;\n  if (title) {\n    if (!document.querySelector('title')) {\n      const t = document.createElement('title');\n      document.head.appendChild(t);\n    }\n    document.title = title;\n  }\n  for (const s of style ?? []) {\n    const l = document.createElement('link');\n    l.setAttribute('rel', 'stylesheet');\n    l.setAttribute('type', 'text/css');\n    l.setAttribute('href', encodeURI(s));\n    document.head.appendChild(l);\n  }\n  if (language) {\n    if (contentType === 'application/xhtml+xml') {\n      if (!document.documentElement.getAttribute('xml:lang')) {\n        document.documentElement.setAttribute('lang', language);\n        document.documentElement.setAttribute('xml:lang', language);\n      }\n    } else {\n      if (!document.documentElement.getAttribute('lang')) {\n        document.documentElement.setAttribute('lang', language);\n      }\n    }\n  }\n  return dom;\n}\n\nexport async function fetchLinkedPublicationManifest({\n  dom,\n  resourceLoader,\n  baseUrl,\n}: {\n  dom: JSDOM;\n  resourceLoader: ResourceLoader;\n  baseUrl: string;\n}): Promise<{ manifest: PublicationManifest; manifestUrl: string } | null> {\n  const { document } = dom.window;\n\n  const linkEl = document.querySelector('link[href][rel=\"publication\"]');\n  if (!linkEl) {\n    return null;\n  }\n  const href = linkEl.getAttribute('href')!.trim();\n  let manifest: PublicationManifest;\n  let manifestUrl = baseUrl;\n  if (href.startsWith('#')) {\n    const scriptEl = document.getElementById(href.slice(1));\n    if (scriptEl?.getAttribute('type') !== 'application/ld+json') {\n      return null;\n    }\n    Logger.debug(`Found embedded publication manifest: ${href}`);\n    try {\n      manifest = JSON.parse(scriptEl.innerHTML);\n    } catch (error) {\n      const thrownError = error as Error;\n      throw new DetailError(\n        'Failed to parse manifest data',\n        typeof thrownError.stack,\n      );\n    }\n  } else {\n    Logger.debug(`Found linked publication manifest: ${href}`);\n    const url = new URL(href, baseUrl);\n    manifestUrl = url.href;\n    const buffer = await resourceLoader.fetch(url.href);\n    if (!buffer) {\n      throw new Error(`Failed to fetch manifest JSON file: ${url.href}`);\n    }\n    const manifestJson = buffer.toString();\n    try {\n      manifest = JSON.parse(manifestJson);\n    } catch (error) {\n      const thrownError = error as Error;\n      throw new DetailError(\n        'Failed to parse manifest data',\n        typeof thrownError.stack,\n      );\n    }\n  }\n\n  try {\n    assertPubManifestSchema(manifest);\n  } catch (error) {\n    Logger.logWarn(\n      `Publication manifest validation failed. Processing continues, but some problems may occur.\\n${error}`,\n    );\n  }\n  return {\n    manifest: decodePublicationManifest(manifest),\n    manifestUrl,\n  };\n}\n\nexport type TocResourceTreeItem = {\n  element: HTMLElement;\n  label: HTMLElement;\n  children?: TocResourceTreeItem[];\n};\nexport type TocResourceTreeRoot = {\n  element: HTMLElement;\n  heading?: HTMLElement;\n  children: TocResourceTreeItem[];\n};\n\nexport function parseTocDocument(dom: JSDOM): TocResourceTreeRoot | null {\n  const { document } = dom.window;\n\n  const docTocEl = document.querySelectorAll('[role=\"doc-toc\"]');\n  if (docTocEl.length === 0) {\n    return null;\n  }\n  const tocRoot = docTocEl.item(0);\n\n  const parseTocItem = (element: Element): TocResourceTreeItem | null => {\n    if (element.tagName !== 'LI') {\n      return null;\n    }\n    const label = element.children.item(0);\n    const ol = element.children.item(1);\n    if (!label || (label.tagName !== 'A' && label.tagName !== 'SPAN')) {\n      return null;\n    }\n    if (!ol || ol.tagName !== 'OL') {\n      return { element: element as HTMLElement, label: label as HTMLElement };\n    }\n    const children = Array.from(ol.children).reduce<\n      TocResourceTreeItem[] | null\n    >((acc, val) => {\n      if (!acc) {\n        return acc;\n      }\n      const res = parseTocItem(val);\n      return res && [...acc, res];\n    }, []);\n    return (\n      children && {\n        element: element as HTMLElement,\n        label: label as HTMLElement,\n        children,\n      }\n    );\n  };\n\n  let heading: HTMLElement | undefined;\n  for (let child of Array.from(tocRoot.children)) {\n    if (child.tagName === 'OL') {\n      const children = Array.from(child.children).reduce<\n        TocResourceTreeItem[] | null\n      >((acc, val) => {\n        if (!acc) {\n          return acc;\n        }\n        const res = parseTocItem(val);\n        return res && [...acc, res];\n      }, []);\n      return children && { element: tocRoot as HTMLElement, heading, children };\n    } else if (\n      ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HGROUP'].includes(child.tagName)\n    ) {\n      heading = child as HTMLElement;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\nexport type PageListResourceTreeItem = {\n  element: HTMLElement;\n};\nexport type PageListResourceTreeRoot = {\n  element: HTMLElement;\n  heading?: HTMLElement;\n  children: PageListResourceTreeItem[];\n};\n\nexport function parsePageListDocument(\n  dom: JSDOM,\n): PageListResourceTreeRoot | null {\n  const { document } = dom.window;\n\n  const docPageListEl = document.querySelectorAll('[role=\"doc-pagelist\"]');\n  if (docPageListEl.length === 0) {\n    return null;\n  }\n  const pageListRoot = docPageListEl.item(0);\n\n  let heading: HTMLElement | undefined;\n  for (let child of Array.from(pageListRoot.children)) {\n    if (child.tagName === 'OL') {\n      const children = Array.from(child.children).reduce<\n        PageListResourceTreeItem[] | null\n      >((acc, element) => {\n        return (\n          acc &&\n          (element.tagName === 'LI'\n            ? [...acc, { element: element as HTMLElement }]\n            : null)\n        );\n      }, []);\n      return (\n        children && { element: pageListRoot as HTMLElement, heading, children }\n      );\n    } else if (\n      ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HGROUP'].includes(child.tagName)\n    ) {\n      heading = child as HTMLElement;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n","import type { JSDOM } from '@vivliostyle/jsdom';\nimport archiver from 'archiver';\nimport { lookup as lookupLanguage } from 'bcp-47-match';\nimport { XMLBuilder } from 'fast-xml-parser';\nimport { copy } from 'fs-extra/esm';\nimport GithubSlugger from 'github-slugger';\nimport { lookup as mime } from 'mime-types';\nimport fs from 'node:fs';\nimport { pathToFileURL } from 'node:url';\nimport upath from 'upath';\nimport { v4 as uuid } from 'uuid';\nimport serializeToXml from 'w3c-xmlserializer';\nimport {\n  EPUB_CONTAINER_XML,\n  EPUB_LANDMARKS_COVER_ENTRY,\n  EPUB_LANDMARKS_TITLE,\n  EPUB_LANDMARKS_TOC_ENTRY,\n  EPUB_NS,\n  TOC_TITLE,\n  XML_DECLARATION,\n} from '../const.js';\nimport { Logger } from '../logger.js';\nimport {\n  type PageListResourceTreeRoot,\n  type TocResourceTreeRoot,\n  getJsdomFromUrlOrFile,\n  parsePageListDocument,\n  parseTocDocument,\n} from '../processor/html.js';\nimport type {\n  Contributor,\n  LocalizableStringObject,\n  LocalizableStringOrObject,\n  PublicationLinks,\n  PublicationManifest,\n  ResourceCategorization,\n} from '../schema/publication.schema.js';\nimport { DetailError, useTmpDirectory } from '../util.js';\n\ninterface ManifestEntry {\n  href: string;\n  mediaType: string;\n  properties?: string;\n}\n\ninterface LandmarkEntry {\n  type: string;\n  href: string;\n  text: string;\n}\n\ninterface SpineEntry {\n  href: string;\n}\n\nconst TOC_ID = 'toc';\nconst LANDMARKS_ID = 'landmarks';\nconst PAGELIST_ID = 'page-list';\nconst COVER_IMAGE_MIMETYPES = [\n  'image/gif',\n  'image/jpeg',\n  'image/png',\n  'image/svg+xml',\n  'image/webp',\n];\n\nconst changeExtname = (filepath: string, newExt: string) => {\n  let ext = upath.extname(filepath);\n  return `${filepath.slice(0, -ext.length)}${newExt}`;\n};\n\nconst getRelativeHref = (target: string, baseUrl: string, rootUrl: string) => {\n  const absBasePath = upath.join('/', baseUrl);\n  const absRootPath = upath.join('/', rootUrl);\n  const hrefUrl = new URL(encodeURI(target), pathToFileURL(absBasePath));\n  if (hrefUrl.protocol !== 'file:') {\n    return target;\n  }\n  if (/\\.html?$/.test(hrefUrl.pathname)) {\n    hrefUrl.pathname = changeExtname(hrefUrl.pathname, '.xhtml');\n  }\n  const pathname = upath.posix.relative(\n    pathToFileURL(upath.dirname(absRootPath)).pathname,\n    hrefUrl.pathname,\n  );\n  return `${pathname}${hrefUrl.search}${hrefUrl.hash}`;\n};\n\nconst normalizeLocalizableString = (\n  value: LocalizableStringOrObject | undefined,\n  availableLanguages: string[],\n): string | undefined => {\n  if (!value) {\n    return;\n  }\n  const values = [value]\n    .flat()\n    .map((value) => (typeof value === 'string' ? { value } : value));\n  const localizedValues = values.filter(\n    (v): v is LocalizableStringObject & { language: string } => !!v.language,\n  );\n  const preferredLang = lookupLanguage(\n    localizedValues.map((v) => v.language),\n    availableLanguages,\n  );\n  if (preferredLang) {\n    return localizedValues[\n      localizedValues.findIndex((v) => v.language === preferredLang)\n    ].value;\n  }\n  return values.find((v) => !v.language)?.value;\n};\n\nconst appendManifestProperty = (entry: ManifestEntry, newProperty: string) => {\n  entry.properties = entry.properties\n    ? Array.from(new Set([...entry.properties.split(' '), newProperty])).join(\n        ' ',\n      )\n    : newProperty;\n};\n\nexport async function exportEpub({\n  webpubDir,\n  entryHtmlFile,\n  manifest,\n  relManifestPath,\n  target,\n  epubVersion,\n}: {\n  webpubDir: string;\n  entryHtmlFile?: string;\n  manifest: PublicationManifest;\n  relManifestPath?: string;\n  target: string;\n  epubVersion: '3.0';\n}) {\n  Logger.debug('Export EPUB', {\n    webpubDir,\n    entryHtmlFile,\n    relManifestPath,\n    target,\n    epubVersion,\n  });\n\n  const [tmpDir] = await useTmpDirectory();\n  fs.mkdirSync(upath.join(tmpDir, 'META-INF'), { recursive: true });\n  await copy(webpubDir, upath.join(tmpDir, 'EPUB'));\n\n  const uid = `urn:uuid:${uuid()}`;\n  const entryHtmlRelPath =\n    entryHtmlFile &&\n    upath.relative(webpubDir, upath.resolve(webpubDir, entryHtmlFile));\n\n  const findPublicationLink = (\n    relType: string,\n    list?: ResourceCategorization,\n    filter?: (e: PublicationLinks) => boolean,\n  ) =>\n    [list]\n      .flat()\n      .find(\n        (e): e is PublicationLinks =>\n          typeof e === 'object' && e.rel === relType && (!filter || filter(e)),\n      );\n  const tocResource = findPublicationLink('contents', [\n    ...[manifest.readingOrder || []].flat(),\n    ...[manifest.resources || []].flat(),\n  ]);\n  const pageListResource = findPublicationLink('pagelist', [\n    ...[manifest.readingOrder || []].flat(),\n    ...[manifest.resources || []].flat(),\n  ]);\n  // NOTE: EPUB allows one cover-image item unlike web publication\n  // vivliostyle-cli takes the first cover resource.\n  const pictureCoverResource = findPublicationLink(\n    'cover',\n    manifest.resources,\n    (e) =>\n      COVER_IMAGE_MIMETYPES.includes(e.encodingFormat || mime(e.url) || ''),\n  );\n  const htmlCoverResource = findPublicationLink(\n    'cover',\n    [\n      ...[manifest.readingOrder || []].flat(),\n      ...[manifest.resources || []].flat(),\n    ],\n    (e) => /\\.html?$/.test(e.url),\n  );\n\n  const manifestItem = [\n    ...[manifest.links || []].flat(),\n    ...[manifest.readingOrder || []].flat(),\n    ...[manifest.resources || []].flat(),\n  ].reduce(\n    (acc, val) => {\n      const { url, encodingFormat } =\n        typeof val === 'string' ? ({ url: val } as PublicationLinks) : val;\n      // Only accepts path-like url\n      try {\n        new URL(url);\n        return acc;\n      } catch (e) {\n        /* NOOP */\n      }\n      if (!fs.existsSync(upath.join(tmpDir, 'EPUB', url))) {\n        return acc;\n      }\n      const mediaType = encodingFormat || mime(url) || 'text/plain';\n      acc[url] = {\n        href: url,\n        mediaType,\n      };\n      if (/\\.html?$/.test(url)) {\n        acc[url].href = changeExtname(url, '.xhtml');\n        acc[url].mediaType = 'application/xhtml+xml';\n      }\n      if (url === pictureCoverResource?.url) {\n        acc[url].properties = 'cover-image';\n      }\n      return acc;\n    },\n    {} as Record<string, ManifestEntry>,\n  );\n\n  const htmlFiles = Object.keys(manifestItem).filter((url) =>\n    /\\.html?$/.test(url),\n  );\n  let tocHtml = htmlFiles.find((f) => f === tocResource?.url);\n  const readingOrder = [manifest.readingOrder || entryHtmlRelPath]\n    .flat()\n    .flatMap((v) => (v ? (typeof v === 'string' ? { url: v } : v) : []));\n  if (!tocHtml) {\n    Logger.logWarn(\n      'No table of contents document was found. for EPUB output, we recommend to enable `toc` option in your Vivliostyle config file to generate a table of contents document.',\n    );\n    tocHtml =\n      htmlFiles.find((f) => f === entryHtmlRelPath) || readingOrder[0].url;\n  }\n  const spineItems = readingOrder.map<SpineEntry>(({ url }) => ({\n    href: changeExtname(url, '.xhtml'),\n  }));\n  if (!(tocHtml in manifestItem)) {\n    manifestItem[tocHtml] = {\n      href: changeExtname(tocHtml, '.xhtml'),\n      mediaType: 'application/xhtml+xml',\n    };\n  }\n  appendManifestProperty(manifestItem[tocHtml], 'nav');\n\n  const landmarks: LandmarkEntry[] = [\n    {\n      type: 'toc',\n      href: `${manifestItem[tocHtml].href}#${TOC_ID}`,\n      text: EPUB_LANDMARKS_TOC_ENTRY,\n    },\n  ];\n  if (htmlCoverResource) {\n    landmarks.push({\n      type: 'cover',\n      href: changeExtname(htmlCoverResource.url, '.xhtml'),\n      text: EPUB_LANDMARKS_COVER_ENTRY,\n    });\n  }\n\n  const contextDir = upath.join(tmpDir, 'EPUB');\n  type XhtmlEntry = Resolved<ReturnType<typeof transpileHtmlToXhtml>>;\n  const processHtml = async (target: string) => {\n    let parseResult: XhtmlEntry;\n    try {\n      parseResult = await transpileHtmlToXhtml({\n        target,\n        contextDir,\n      });\n    } catch (error) {\n      const thrownError = error as Error;\n      throw new DetailError(\n        `Failed to transpile document to XHTML: ${target}`,\n        thrownError.stack ?? thrownError.message,\n      );\n    }\n    if (parseResult.hasMathmlContent) {\n      appendManifestProperty(manifestItem[target], 'mathml');\n    }\n    if (parseResult.hasRemoteResources) {\n      appendManifestProperty(manifestItem[target], 'remote-resources');\n    }\n    if (parseResult.hasScriptedContent) {\n      appendManifestProperty(manifestItem[target], 'scripted');\n    }\n    if (parseResult.hasSvgContent) {\n      appendManifestProperty(manifestItem[target], 'svg');\n    }\n    return parseResult;\n  };\n\n  const processResult: Record<string, XhtmlEntry> = {};\n  Logger.debug(`Transpiling ToC HTML to XHTML: ${tocHtml}`);\n  processResult[tocHtml] = await processHtml(tocHtml);\n  for (const target of htmlFiles.filter((f) => f !== tocHtml)) {\n    Logger.debug(`Transpiling HTML to XHTML: ${target}`);\n    processResult[target] = await processHtml(target);\n  }\n\n  // Process ToC document\n  const { document: entryDocument } = processResult[tocHtml].dom.window;\n  const docLanguages = [manifest.inLanguage]\n    .flat()\n    .filter((v): v is string => Boolean(v));\n  if (docLanguages.length === 0) {\n    docLanguages.push(entryDocument.documentElement.lang || 'en');\n  }\n  const docTitle =\n    normalizeLocalizableString(manifest.name, docLanguages) ||\n    entryDocument.title;\n  if (!docTitle) {\n    throw new Error('EPUB must have a title of one or more characters');\n  }\n  const { tocResourceTree } = await processTocDocument({\n    dom: processResult[tocHtml].dom,\n    target: tocHtml,\n    contextDir,\n    readingOrder,\n    docLanguages,\n    landmarks,\n  });\n\n  // Process PageList document\n  const pageListHtml = pageListResource?.url || entryHtmlRelPath;\n  if (pageListHtml && pageListHtml in processResult) {\n    await processPagelistDocument({\n      dom: processResult[pageListHtml].dom,\n      target: pageListHtml,\n      contextDir,\n    });\n  }\n\n  if (relManifestPath) {\n    await fs.promises.rm(upath.join(tmpDir, 'EPUB', relManifestPath), {\n      force: true,\n      recursive: true,\n    });\n    delete manifestItem[relManifestPath];\n  }\n\n  // META-INF/container.xml\n  fs.writeFileSync(\n    upath.join(tmpDir, 'META-INF/container.xml'),\n    EPUB_CONTAINER_XML,\n    'utf8',\n  );\n\n  // EPUB/content.opf\n  Logger.debug(`Generating content.opf`);\n  fs.writeFileSync(\n    upath.join(tmpDir, 'EPUB/content.opf'),\n    buildEpubPackageDocument({\n      epubVersion,\n      uid,\n      docTitle,\n      docLanguages,\n      manifest,\n      spineItems,\n      manifestItems: Object.values(manifestItem),\n    }),\n    'utf8',\n  );\n\n  await compressEpub({ target, sourceDir: tmpDir });\n}\n\nasync function writeAsXhtml(dom: JSDOM, absPath: string) {\n  const xhtml = `${XML_DECLARATION}\\n${serializeToXml(dom.window.document)}`;\n  await fs.promises.writeFile(changeExtname(absPath, '.xhtml'), xhtml, 'utf8');\n}\n\nasync function transpileHtmlToXhtml({\n  target,\n  contextDir,\n}: {\n  target: string;\n  contextDir: string;\n}): Promise<{\n  dom: JSDOM;\n  hasMathmlContent: boolean;\n  hasRemoteResources: boolean;\n  hasScriptedContent: boolean;\n  hasSvgContent: boolean;\n}> {\n  const absPath = upath.join(contextDir, target);\n  const dom = await getJsdomFromUrlOrFile({ src: absPath });\n  const { document } = dom.window;\n  // `xmlns` will be supplied in later serialization process\n  document.documentElement.removeAttribute('xmlns');\n  document.documentElement.setAttribute('xmlns:epub', EPUB_NS);\n\n  document.querySelectorAll('a[href]').forEach((el) => {\n    const href = decodeURI(el.getAttribute('href')!);\n    el.setAttribute('href', getRelativeHref(href, target, target));\n  });\n\n  await writeAsXhtml(dom, absPath);\n  await fs.promises.unlink(absPath);\n  return {\n    dom,\n    // FIXME: Yes, I recognize this implementation is inadequate.\n    hasMathmlContent: !!document.querySelector('math'),\n    hasRemoteResources: !!document.querySelector(\n      '[src^=\"http://\"], [src^=\"https://\"]',\n    ),\n    hasScriptedContent: !!document.querySelector('script, form'),\n    hasSvgContent: !!document.querySelector('svg'),\n  };\n}\n\nfunction replaceWithNavElement(dom: JSDOM, el: Element) {\n  const nav = dom.window.document.createElement('nav');\n  while (el.firstChild) {\n    nav.appendChild(el.firstChild);\n  }\n  for (let i = 0; i < el.attributes.length; i++) {\n    nav.attributes.setNamedItem(el.attributes[i].cloneNode() as Attr);\n  }\n  el.parentNode?.replaceChild(nav, el);\n  return nav;\n}\n\nasync function processTocDocument({\n  dom,\n  target,\n  contextDir,\n  readingOrder,\n  docLanguages,\n  landmarks,\n}: {\n  dom: JSDOM;\n  target: string;\n  contextDir: string;\n  readingOrder: PublicationLinks[];\n  docLanguages: string[];\n  landmarks: LandmarkEntry[];\n}): Promise<{ tocResourceTree: TocResourceTreeRoot | null }> {\n  const { document } = dom.window;\n\n  let tocResourceTree: TocResourceTreeRoot | null = null;\n  if (!document.querySelector('nav[epub:type]')) {\n    tocResourceTree = parseTocDocument(dom);\n    if (tocResourceTree) {\n      const nav = replaceWithNavElement(dom, tocResourceTree.element);\n      nav.setAttribute('id', TOC_ID);\n      nav.setAttribute('epub:type', 'toc');\n    } else {\n      Logger.debug(`Generating toc nav element: ${target}`);\n\n      const nav = document.createElement('nav');\n      nav.setAttribute('id', TOC_ID);\n      nav.setAttribute('role', 'doc-toc');\n      nav.setAttribute('epub:type', 'toc');\n      nav.setAttribute('hidden', '');\n      const h2 = document.createElement('h2');\n      h2.textContent = TOC_TITLE;\n      nav.appendChild(h2);\n      const ol = document.createElement('ol');\n      tocResourceTree = {\n        element: nav,\n        children: [],\n      };\n\n      for (const content of readingOrder) {\n        let name = normalizeLocalizableString(content.name, docLanguages);\n        if (!name) {\n          const dom = await getJsdomFromUrlOrFile({\n            src: upath.join(contextDir, changeExtname(content.url, '.xhtml')),\n          });\n          name = dom.window.document.title;\n        }\n        const li = document.createElement('li');\n        const a = document.createElement('a');\n        a.textContent = name;\n        a.href = getRelativeHref(content.url, '', target);\n        li.appendChild(a);\n        ol.appendChild(li);\n        tocResourceTree.children.push({ element: li, label: a });\n      }\n\n      nav.appendChild(ol);\n      document.body.appendChild(nav);\n      Logger.debug('Generated toc nav element', nav.outerHTML);\n    }\n\n    if (landmarks.length > 0) {\n      Logger.debug(`Generating landmark nav element: ${target}`);\n      const nav = document.createElement('nav');\n      nav.setAttribute('epub:type', 'landmarks');\n      nav.setAttribute('id', LANDMARKS_ID);\n      nav.setAttribute('hidden', '');\n      const h2 = document.createElement('h2');\n      h2.textContent = EPUB_LANDMARKS_TITLE;\n      nav.appendChild(h2);\n      const ol = document.createElement('ol');\n      for (const { type, href, text } of landmarks) {\n        const li = document.createElement('li');\n        const a = document.createElement('a');\n        a.setAttribute('epub:type', type);\n        a.setAttribute('href', getRelativeHref(href, '', target));\n        a.text = text;\n        li.appendChild(a);\n        ol.appendChild(li);\n      }\n      nav.appendChild(ol);\n      document.body.appendChild(nav);\n      Logger.debug('Generated landmark nav element', nav.outerHTML);\n    }\n  }\n\n  // Remove a publication manifest linked to ToC html.\n  // When converting to EPUB, HTML files are converted to XHTML files\n  // and no longer conform to Web publication, so we need to\n  // explicitly remove the publication manifest.\n  const publicationLinkEl = document.querySelector(\n    'link[href][rel=\"publication\"]',\n  );\n  if (publicationLinkEl) {\n    const href = publicationLinkEl.getAttribute('href')!.trim();\n    if (href.startsWith('#')) {\n      const scriptEl = document.getElementById(href.slice(1));\n      if (scriptEl?.getAttribute('type') === 'application/ld+json') {\n        scriptEl.parentNode?.removeChild(scriptEl);\n      }\n    }\n    publicationLinkEl.parentNode?.removeChild(publicationLinkEl);\n  }\n\n  const absPath = upath.join(contextDir, target);\n  await writeAsXhtml(dom, absPath);\n  return { tocResourceTree };\n}\n\nasync function processPagelistDocument({\n  dom,\n  target,\n  contextDir,\n}: {\n  dom: JSDOM;\n  target: string;\n  contextDir: string;\n}): Promise<{ pageListResourceTree: PageListResourceTreeRoot | null }> {\n  const pageListResourceTree = parsePageListDocument(dom);\n  if (pageListResourceTree) {\n    const nav = replaceWithNavElement(dom, pageListResourceTree.element);\n    nav.setAttribute('id', PAGELIST_ID);\n    nav.setAttribute('epub:type', 'page-list');\n  }\n\n  const absPath = upath.join(contextDir, target);\n  await writeAsXhtml(dom, absPath);\n  return { pageListResourceTree };\n}\n\nfunction buildEpubPackageDocument({\n  epubVersion,\n  manifest,\n  uid,\n  docTitle,\n  docLanguages,\n  spineItems,\n  manifestItems,\n}: Pick<Parameters<typeof exportEpub>[0], 'epubVersion'> & {\n  manifest: PublicationManifest;\n  uid: string;\n  docTitle: string;\n  docLanguages: string[];\n  spineItems: SpineEntry[];\n  manifestItems: ManifestEntry[];\n}): string {\n  const slugger = new GithubSlugger();\n  slugger.reset();\n\n  const bookIdentifier = slugger.slug('bookid');\n  const normalizeDate = (value: string | number | undefined) =>\n    value && `${new Date(value).toISOString().split('.')[0]}Z`;\n\n  const transformToGenericTextNode = <T = {}>(value: unknown, attributes?: T) =>\n    [value]\n      .flat()\n      .filter(Boolean)\n      .map((v) => ({ ...(attributes || {}), '#text': `${value}` }));\n  const transformContributor = (\n    contributorMap: Record<string, Contributor | undefined>,\n  ) =>\n    Object.entries(contributorMap).flatMap(([type, contributor]) =>\n      contributor\n        ? [contributor].flat().map((entry, index) => ({\n            _id: slugger.slug(`${type}-${index + 1}`),\n            '#text':\n              typeof entry === 'string'\n                ? entry\n                : normalizeLocalizableString(entry.name, docLanguages),\n          }))\n        : [],\n    );\n\n  const itemIdMap = new Map<string, string>();\n  manifestItems.forEach(({ href }) => {\n    itemIdMap.set(href, slugger.slug(href));\n  });\n\n  const builder = new XMLBuilder({\n    format: true,\n    ignoreAttributes: false,\n    attributeNamePrefix: '_',\n  });\n  return builder.build({\n    '?xml': {\n      _version: '1.0',\n      _encoding: 'UTF-8',\n    },\n    package: {\n      _xmlns: 'http://www.idpf.org/2007/opf',\n      _version: epubVersion,\n      '_unique-identifier': bookIdentifier,\n      '_xml:lang': docLanguages[0],\n      metadata: {\n        '_xmlns:dc': 'http://purl.org/dc/elements/1.1/',\n        'dc:identifier': {\n          _id: bookIdentifier,\n          '#text': uid,\n        },\n        'dc:title': docTitle,\n        'dc:language': docLanguages,\n        'dc:creator': transformContributor({\n          // TODO: Define proper order\n          author: manifest.author,\n          creator: manifest.creator,\n          editor: manifest.editor,\n          artist: manifest.artist,\n          illustrator: manifest.illustrator,\n          colorist: manifest.colorist,\n          penciler: manifest.penciler,\n          inker: manifest.inker,\n          letterer: manifest.letterer,\n          translator: manifest.translator,\n          readBy: manifest.readBy,\n        }),\n        'dc:publisher': transformContributor({\n          publisher: manifest.publisher,\n        }),\n        'dc:contributor': transformContributor({\n          contributor: manifest.contributor,\n        }),\n        'dc:date': transformToGenericTextNode(\n          normalizeDate(manifest.datePublished),\n        ),\n        'dc:rights': transformToGenericTextNode(\n          manifest.copyrightHolder &&\n            `Â© ${manifest.copyrightYear ? `${manifest.copyrightYear} ` : ''}${\n              manifest.copyrightHolder\n            }`,\n        ),\n        'dc:subject': transformToGenericTextNode(\n          manifest['dc:subject'] || manifest.subject,\n        ),\n        meta: [\n          ...transformToGenericTextNode(\n            normalizeDate(manifest.dateModified || Date.now()),\n            {\n              _property: 'dcterms:modified',\n            },\n          ),\n          ...(() => {\n            const coverImage = manifestItems.find(\n              (it) => it.properties === 'cover-image',\n            );\n            return coverImage\n              ? [{ _name: 'cover', _content: itemIdMap.get(coverImage.href) }]\n              : [];\n          })(),\n        ],\n      },\n      manifest: {\n        item: manifestItems.map(({ href, mediaType, properties }) => ({\n          _id: itemIdMap.get(href),\n          _href: encodeURI(href),\n          '_media-type': mediaType,\n          ...(properties ? { _properties: properties } : {}),\n        })),\n      },\n      spine: {\n        ...(manifest.readingProgression\n          ? { '_page-progression-direction': manifest.readingProgression }\n          : {}),\n        itemref: [\n          ...spineItems.map(({ href }) => ({\n            _idref: itemIdMap.get(href),\n          })),\n        ],\n      },\n    },\n  });\n}\n\nasync function compressEpub({\n  target,\n  sourceDir,\n}: {\n  target: string;\n  sourceDir: string;\n}): Promise<void> {\n  Logger.debug(`Compressing EPUB: ${target}`);\n  const output = fs.createWriteStream(target);\n  const archive = archiver('zip', {\n    zlib: { level: 9 }, // Compression level\n  });\n  return new Promise((resolve, reject) => {\n    output.on('close', () => {\n      Logger.debug(`Compressed EPUB: ${target}`);\n      resolve();\n    });\n    output.on('error', reject);\n    archive.on('warning', reject);\n    archive.on('error', reject);\n    archive.pipe(output);\n\n    archive.append('application/epub+zip', {\n      name: 'mimetype',\n      // mimetype should not be compressed\n      // https://www.w3.org/TR/epub-33/#sec-zip-container-mime\n      store: true,\n    });\n    archive.directory(upath.join(sourceDir, 'META-INF'), 'META-INF');\n    archive.directory(upath.join(sourceDir, 'EPUB'), 'EPUB');\n    archive.finalize();\n  });\n}\n","import Arborist from '@npmcli/arborist';\nimport fs from 'node:fs';\nimport upath from 'upath';\nimport type { ResolvedTaskConfig } from '../config/resolve.js';\nimport { DetailError } from '../util.js';\n\nexport async function checkThemeInstallationNecessity({\n  themesDir,\n  themeIndexes,\n}: Pick<ResolvedTaskConfig, 'themesDir' | 'themeIndexes'>): Promise<boolean> {\n  if (!fs.existsSync(themesDir)) {\n    return [...themeIndexes].some((theme) => theme.type === 'package');\n  }\n\n  const commonOpt = {\n    path: themesDir,\n    lockfileVersion: 3,\n    installLinks: true,\n  };\n  const arb = new Arborist(commonOpt);\n  const tree = await arb.loadActual();\n  const pkgs = Array.from(tree.children.keys());\n  return [...themeIndexes].some(\n    (theme) => theme.type === 'package' && !pkgs.includes(theme.name),\n  );\n}\n\nexport function getLocalThemePaths({\n  themesDir,\n}: Pick<ResolvedTaskConfig, 'themesDir'>): string[] {\n  const nodeModulesDir = upath.join(themesDir, 'node_modules');\n  if (!fs.existsSync(nodeModulesDir)) {\n    return [];\n  }\n  const localPaths: string[] = [];\n  for (const entry of fs.readdirSync(nodeModulesDir, { withFileTypes: true })) {\n    if (entry.isSymbolicLink()) {\n      const linkPath = upath.join(nodeModulesDir, entry.name);\n      const target = fs.readlinkSync(linkPath);\n      const absoluteTarget = upath.resolve(nodeModulesDir, target);\n      localPaths.push(absoluteTarget);\n    }\n  }\n  return localPaths;\n}\n\nexport async function installThemeDependencies({\n  themesDir,\n  themeIndexes,\n}: Pick<ResolvedTaskConfig, 'themesDir' | 'themeIndexes'>): Promise<void> {\n  fs.mkdirSync(themesDir, { recursive: true });\n\n  try {\n    const commonOpt = {\n      path: themesDir,\n      lockfileVersion: 3,\n      installLinks: true,\n    };\n    const tree = await new Arborist(commonOpt).buildIdealTree();\n    const existing = Array.from(tree.children.keys());\n    const add = [\n      ...new Set(\n        [...themeIndexes].flatMap((theme) =>\n          theme.type === 'package' ? [theme.specifier] : [],\n        ),\n      ),\n    ];\n    const rm = existing.filter((v) => !add.includes(v));\n\n    // Install dependencies\n    const opt = { ...commonOpt, rm, add };\n    const arb = new Arborist(opt);\n    const actualTree = await arb.reify(opt);\n\n    // Replace all local package directories with symlinks for hot reload support\n    for (const child of actualTree.children.values()) {\n      if (child.resolved?.startsWith('file:')) {\n        const sourcePath = upath.resolve(themesDir, child.resolved.slice(5));\n        if (fs.existsSync(child.path)) {\n          fs.rmSync(child.path, { recursive: true });\n        }\n        const relPath = upath.relative(upath.dirname(child.path), sourcePath);\n        fs.symlinkSync(relPath, child.path, 'junction');\n      }\n    }\n  } catch (error) {\n    const thrownError = error as Error;\n    throw new DetailError(\n      'An error occurred during the installation of the theme',\n      thrownError.stack ?? thrownError.message,\n    );\n  }\n}\n","import type { ResolvedConfig as ResolvedViteConfig } from 'vite';\nimport { setupConfigFromFlags } from '../commands/cli-flags.js';\nimport { loadVivliostyleConfig } from '../config/load.js';\nimport { mergeConfig, mergeInlineConfig } from '../config/merge.js';\nimport {\n  type ResolvedTaskConfig,\n  resolveTaskConfig,\n} from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\n\nconst headStartTagRe = /<head[^>]*>/i;\nexport const prependToHead = (html: string, content: string) =>\n  html.replace(headStartTagRe, (match) => `${match}\\n${content}`);\n\nexport async function reloadConfig(\n  prevConfig: ResolvedTaskConfig,\n  inlineConfig: ParsedVivliostyleInlineConfig,\n  resolvedViteConfig?: ResolvedViteConfig,\n) {\n  let config =\n    (await loadVivliostyleConfig(inlineConfig)) ??\n    setupConfigFromFlags(inlineConfig);\n  config = mergeInlineConfig(config, inlineConfig);\n  config = mergeConfig(config, {\n    temporaryFilePrefix: prevConfig.temporaryFilePrefix,\n    server: resolvedViteConfig?.server,\n  });\n  const taskConfig = resolveTaskConfig(config.tasks[0], config.inlineOptions);\n  return taskConfig;\n}\n","import sirv from 'sirv';\nimport upath from 'upath';\nimport * as vite from 'vite';\nimport type { ResolvedTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\n\nexport function vsStaticServePlugin({\n  config: _config,\n  inlineConfig,\n}: {\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): vite.Plugin {\n  let config = _config;\n\n  const createMiddlewares = () => {\n    if (typeof config.serverRootDir !== 'string') {\n      return [];\n    }\n    return Object.entries(config.static).flatMap(([base, dirs]) =>\n      dirs.map(\n        (dir) =>\n          [\n            base,\n            sirv(upath.resolve(config.serverRootDir, dir), {\n              dev: true,\n              etag: false,\n            }),\n          ] as const,\n      ),\n    );\n  };\n\n  return {\n    name: 'vivliostyle:static-serve',\n    apply: () => Boolean(inlineConfig.enableStaticServe),\n    configureServer(viteServer) {\n      return () => {\n        createMiddlewares().forEach(([base, middleware]) => {\n          viteServer.middlewares.use(base, middleware);\n        });\n      };\n    },\n\n    configurePreviewServer(viteServer) {\n      return () => {\n        createMiddlewares().forEach(([base, middleware]) => {\n          viteServer.middlewares.use(base, middleware);\n        });\n      };\n    },\n  };\n}\n","import type { NextHandleFunction } from 'connect';\nimport fs from 'node:fs';\nimport sirv from 'sirv';\nimport upath from 'upath';\nimport * as vite from 'vite';\nimport type { ResolvedTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { VIEWER_ROOT_PATH, viewerRoot } from '../const.js';\nimport { prependToHead } from './plugin-util.js';\n\nconst viewerClientId = '@vivliostyle:viewer:client';\nconst viewerClientRequestPath = `/${viewerClientId}`;\nconst viewerClientContent = /* js */ `\nif (import.meta.hot) {\n  import.meta.hot.on('vite:beforeFullReload', (e) => {\n    location.reload();\n  });\n}`;\n\nexport function vsViewerPlugin(_: {\n  config: ResolvedTaskConfig;\n  inlineConfig: ParsedVivliostyleInlineConfig;\n}): vite.Plugin {\n  const serveRootDir = upath.join(viewerRoot, 'lib');\n  const serve = sirv(serveRootDir, { dev: false, etag: true });\n  let cachedIndexHtml: string;\n\n  const middleware = async function vivliostyleViewerMiddleware(\n    req,\n    res,\n    next,\n  ) {\n    if (req.url === '/' || req.url === '/index.html') {\n      cachedIndexHtml ??= prependToHead(\n        fs.readFileSync(upath.join(serveRootDir, 'index.html'), 'utf-8'),\n        `<script type=\"module\" src=\"${viewerClientRequestPath}\"></script>`,\n      );\n      res.statusCode = 200;\n      res.setHeader('Content-Type', 'text/html;charset=utf-8');\n      res.setHeader('Cache-Control', 'no-cache');\n      return res.end(cachedIndexHtml);\n    } else {\n      return serve(req, res, next);\n    }\n  } satisfies NextHandleFunction;\n\n  return {\n    name: 'vivliostyle:viewer',\n    config() {\n      return {\n        optimizeDeps: {\n          exclude: ['@vivliostyle/viewer'],\n        },\n      } satisfies vite.UserConfig;\n    },\n    configureServer(viteServer) {\n      viteServer.middlewares.use(VIEWER_ROOT_PATH, middleware);\n    },\n    configurePreviewServer(viteServer) {\n      viteServer.middlewares.use(VIEWER_ROOT_PATH, serve);\n    },\n    load(id) {\n      if (id === viewerClientRequestPath) {\n        return viewerClientContent;\n      }\n    },\n  };\n}\n"],"mappings":"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","names":["require","cwd","vite","fs","pathToFileURL","upath","fs","upath","cwd","fs","pathToFileURL","fs","upath","upath","fs","_","fs","URL","upath","pathToFileURL","upath","copy","fs","upath","serializeToXml","MIMEType","copy","mime","fs","pathToFileURL","upath","fileURLToPath","pathToFileURL","upath","upath","pathToFileURL","fileURLToPath","document","mime","fs","pathToFileURL","upath","upath","pathToFileURL","value","v","fs","mime","target","document","dom","fs","ret","mime","upath","pathToFileURL","pathContains","v","document","copy","fs","upath","fs","upath","v","upath","fs","copy","vfile","MIMEType","serializeToXml","cwd","upath","pathToFileURL","entry","next","sirv","upath","fs","sirv","upath","upath","sirv","fs","upath","fs","URL","page","locale","server"]}
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-HG3ZYWGO.js b/package/dist/chunk-HG3ZYWGO.js
--- a/package/dist/chunk-HG3ZYWGO.js	1970-01-01 09:00:00.000000000 +0900
+++ b/package/dist/chunk-HG3ZYWGO.js	1985-10-26 17:15:00.000000000 +0900
@@ -0,0 +1,87 @@
+import {
+  resolveViteConfig
+} from "./chunk-XMCTTVR7.js";
+import {
+  createViteServer,
+  getViewerFullUrl,
+  loadVivliostyleConfig,
+  mergeConfig,
+  mergeInlineConfig,
+  resolveTaskConfig,
+  warnDeprecatedConfig
+} from "./chunk-BYT766IR.js";
+import {
+  Logger,
+  isUnicodeSupported,
+  randomBookSymbol,
+  setupConfigFromFlags
+} from "./chunk-T2VWLU2I.js";
+import {
+  cliVersion
+} from "./chunk-ZEBXHUJX.js";
+import {
+  __callDispose,
+  __using
+} from "./chunk-I7BWSAN6.js";
+
+// src/core/preview.ts
+import terminalLink from "terminal-link";
+import { blueBright, cyan, dim } from "yoctocolors";
+async function preview(inlineConfig) {
+  Logger.setLogOptions(inlineConfig);
+  Logger.debug("preview > inlineConfig %O", inlineConfig);
+  let vivliostyleConfig = await loadVivliostyleConfig(inlineConfig) ?? setupConfigFromFlags(inlineConfig);
+  warnDeprecatedConfig(vivliostyleConfig);
+  vivliostyleConfig = mergeInlineConfig(vivliostyleConfig, inlineConfig);
+  const { tasks, inlineOptions } = vivliostyleConfig;
+  Logger.debug("preview > vivliostyleConfig %O", vivliostyleConfig);
+  let config = resolveTaskConfig(tasks[0], inlineOptions);
+  Logger.debug("preview > config %O", config);
+  let server;
+  let url;
+  {
+    var _stack = [];
+    try {
+      const _2 = __using(_stack, Logger.startLogging("Start preview"));
+      const viteConfig = await resolveViteConfig({
+        ...config,
+        mode: "preview"
+      });
+      server = await createViteServer({
+        config,
+        viteConfig,
+        inlineConfig,
+        mode: "preview"
+      });
+      if (server.httpServer) {
+        await server.listen();
+        vivliostyleConfig = mergeConfig(vivliostyleConfig, {
+          temporaryFilePrefix: config.temporaryFilePrefix,
+          server: server.config.server
+        });
+        config = resolveTaskConfig(
+          vivliostyleConfig.tasks[0],
+          vivliostyleConfig.inlineOptions
+        );
+      }
+      url = await getViewerFullUrl(config);
+    } catch (_) {
+      var _error = _, _hasError = true;
+    } finally {
+      __callDispose(_stack, _error, _hasError);
+    }
+  }
+  if (server.httpServer) {
+    Logger.log(`
+${cyan(`Vivliostyle CLI v${cliVersion}`)}
+${blueBright("\u2551")} ${isUnicodeSupported ? `${randomBookSymbol} ` : ""}Up and running (press Ctrl+C to quit)
+${blueBright("\u2559\u2500")} ${dim(`Preview URL: ${terminalLink(url, url, { fallback: () => url })}`)}
+`);
+  }
+  return server;
+}
+
+export {
+  preview
+};
+//# sourceMappingURL=chunk-HG3ZYWGO.js.map
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-HG3ZYWGO.js.map b/package/dist/chunk-HG3ZYWGO.js.map
--- a/package/dist/chunk-HG3ZYWGO.js.map	1970-01-01 09:00:00.000000000 +0900
+++ b/package/dist/chunk-HG3ZYWGO.js.map	1985-10-26 17:15:00.000000000 +0900
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/core/preview.ts"],"sourcesContent":["import terminalLink from 'terminal-link';\nimport type { ViteDevServer } from 'vite';\nimport { blueBright, cyan, dim } from 'yoctocolors';\nimport { setupConfigFromFlags } from '../commands/cli-flags.js';\nimport { loadVivliostyleConfig, warnDeprecatedConfig } from '../config/load.js';\nimport { mergeConfig, mergeInlineConfig } from '../config/merge.js';\nimport { resolveTaskConfig } from '../config/resolve.js';\nimport type { ParsedVivliostyleInlineConfig } from '../config/schema.js';\nimport { resolveViteConfig } from '../config/vite.js';\nimport { cliVersion } from '../const.js';\nimport { isUnicodeSupported, Logger, randomBookSymbol } from '../logger.js';\nimport { createViteServer, getViewerFullUrl } from '../server.js';\n\nexport async function preview(inlineConfig: ParsedVivliostyleInlineConfig) {\n  Logger.setLogOptions(inlineConfig);\n  Logger.debug('preview > inlineConfig %O', inlineConfig);\n\n  let vivliostyleConfig =\n    (await loadVivliostyleConfig(inlineConfig)) ??\n    setupConfigFromFlags(inlineConfig);\n  warnDeprecatedConfig(vivliostyleConfig);\n  vivliostyleConfig = mergeInlineConfig(vivliostyleConfig, inlineConfig);\n  const { tasks, inlineOptions } = vivliostyleConfig;\n  Logger.debug('preview > vivliostyleConfig %O', vivliostyleConfig);\n\n  // Only show preview of first entry\n  let config = resolveTaskConfig(tasks[0], inlineOptions);\n  Logger.debug('preview > config %O', config);\n\n  let server: ViteDevServer;\n  let url: string;\n  {\n    using _ = Logger.startLogging('Start preview');\n    const viteConfig = await resolveViteConfig({\n      ...config,\n      mode: 'preview',\n    });\n    server = await createViteServer({\n      config,\n      viteConfig,\n      inlineConfig,\n      mode: 'preview',\n    });\n    if (server.httpServer) {\n      await server.listen();\n      vivliostyleConfig = mergeConfig(vivliostyleConfig, {\n        temporaryFilePrefix: config.temporaryFilePrefix,\n        server: server.config.server,\n      });\n      config = resolveTaskConfig(\n        vivliostyleConfig.tasks[0],\n        vivliostyleConfig.inlineOptions,\n      );\n    }\n    url = await getViewerFullUrl(config);\n  }\n\n  if (server.httpServer) {\n    Logger.log(`\n${cyan(`Vivliostyle CLI v${cliVersion}`)}\n${blueBright('â•‘')} ${isUnicodeSupported ? `${randomBookSymbol} ` : ''}Up and running (press Ctrl+C to quit)\n${blueBright('â•™â”€')} ${dim(`Preview URL: ${terminalLink(url, url, { fallback: () => url })}`)}\n`);\n  }\n  return server;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,kBAAkB;AAEzB,SAAS,YAAY,MAAM,WAAW;AAWtC,eAAsB,QAAQ,cAA6C;AACzE,SAAO,cAAc,YAAY;AACjC,SAAO,MAAM,6BAA6B,YAAY;AAEtD,MAAI,oBACD,MAAM,sBAAsB,YAAY,KACzC,qBAAqB,YAAY;AACnC,uBAAqB,iBAAiB;AACtC,sBAAoB,kBAAkB,mBAAmB,YAAY;AACrE,QAAM,EAAE,OAAO,cAAc,IAAI;AACjC,SAAO,MAAM,kCAAkC,iBAAiB;AAGhE,MAAI,SAAS,kBAAkB,MAAM,CAAC,GAAG,aAAa;AACtD,SAAO,MAAM,uBAAuB,MAAM;AAE1C,MAAI;AACJ,MAAI;AACJ;AACE;AAAA;AAAA,YAAMA,KAAI,uBAAO,aAAa,eAAe;AAC7C,YAAM,aAAa,MAAM,kBAAkB;AAAA,QACzC,GAAG;AAAA,QACH,MAAM;AAAA,MACR,CAAC;AACD,eAAS,MAAM,iBAAiB;AAAA,QAC9B;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM;AAAA,MACR,CAAC;AACD,UAAI,OAAO,YAAY;AACrB,cAAM,OAAO,OAAO;AACpB,4BAAoB,YAAY,mBAAmB;AAAA,UACjD,qBAAqB,OAAO;AAAA,UAC5B,QAAQ,OAAO,OAAO;AAAA,QACxB,CAAC;AACD,iBAAS;AAAA,UACP,kBAAkB,MAAM,CAAC;AAAA,UACzB,kBAAkB;AAAA,QACpB;AAAA,MACF;AACA,YAAM,MAAM,iBAAiB,MAAM;AAAA,aAtBnC;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBF;AAEA,MAAI,OAAO,YAAY;AACrB,WAAO,IAAI;AAAA,EACb,KAAK,oBAAoB,UAAU,EAAE,CAAC;AAAA,EACtC,WAAW,QAAG,CAAC,IAAI,qBAAqB,GAAG,gBAAgB,MAAM,EAAE;AAAA,EACnE,WAAW,cAAI,CAAC,IAAI,IAAI,gBAAgB,aAAa,KAAK,KAAK,EAAE,UAAU,MAAM,IAAI,CAAC,CAAC,EAAE,CAAC;AAAA,CAC3F;AAAA,EACC;AACA,SAAO;AACT;","names":["_"]}
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-LDAP47TK.js b/package/dist/chunk-LDAP47TK.js
--- a/package/dist/chunk-LDAP47TK.js	1970-01-01 09:00:00.000000000 +0900
+++ b/package/dist/chunk-LDAP47TK.js	1985-10-26 17:15:00.000000000 +0900
@@ -0,0 +1,56 @@
+import {
+  loadVivliostyleConfig,
+  mergeInlineConfig,
+  resolveTaskConfig,
+  vsBrowserPlugin,
+  vsDevServerPlugin,
+  vsStaticServePlugin,
+  vsViewerPlugin,
+  warnDeprecatedConfig
+} from "./chunk-BYT766IR.js";
+import {
+  Logger,
+  setupConfigFromFlags
+} from "./chunk-T2VWLU2I.js";
+import {
+  VivliostyleInlineConfig
+} from "./chunk-CKXFRCPH.js";
+
+// src/vite-adapter.ts
+import * as v from "valibot";
+import * as vite from "vite";
+async function createVitePlugin(inlineConfig = {}) {
+  const parsedInlineConfig = v.parse(VivliostyleInlineConfig, inlineConfig);
+  let viteLogger;
+  Logger.setLogOptions({
+    ...parsedInlineConfig,
+    logger: parsedInlineConfig.logger ?? {
+      info: (msg) => viteLogger?.info(msg, { timestamp: true }),
+      warn: (msg) => viteLogger?.warn(msg, { timestamp: true }),
+      error: (msg) => viteLogger?.error(msg, { timestamp: true })
+    }
+  });
+  viteLogger = vite.createLogger("info", {
+    prefix: "[vivliostyle]"
+  });
+  Logger.debug("inlineConfig %O", parsedInlineConfig);
+  const vivliostyleConfig = await loadVivliostyleConfig(parsedInlineConfig) ?? setupConfigFromFlags(parsedInlineConfig);
+  warnDeprecatedConfig(vivliostyleConfig);
+  const { tasks, inlineOptions } = mergeInlineConfig(
+    vivliostyleConfig,
+    parsedInlineConfig
+  );
+  const config = resolveTaskConfig(tasks[0], inlineOptions);
+  Logger.debug("config %O", config);
+  return [
+    vsDevServerPlugin({ config, inlineConfig: parsedInlineConfig }),
+    vsViewerPlugin({ config, inlineConfig: parsedInlineConfig }),
+    vsBrowserPlugin({ config, inlineConfig: parsedInlineConfig }),
+    vsStaticServePlugin({ config, inlineConfig: parsedInlineConfig })
+  ];
+}
+
+export {
+  createVitePlugin
+};
+//# sourceMappingURL=chunk-LDAP47TK.js.map
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/chunk-LDAP47TK.js.map b/package/dist/chunk-LDAP47TK.js.map
--- a/package/dist/chunk-LDAP47TK.js.map	1970-01-01 09:00:00.000000000 +0900
+++ b/package/dist/chunk-LDAP47TK.js.map	1985-10-26 17:15:00.000000000 +0900
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/vite-adapter.ts"],"sourcesContent":["import * as v from 'valibot';\nimport * as vite from 'vite';\nimport { setupConfigFromFlags } from './commands/cli-flags.js';\nimport { loadVivliostyleConfig, warnDeprecatedConfig } from './config/load.js';\nimport { mergeInlineConfig } from './config/merge.js';\nimport { resolveTaskConfig } from './config/resolve.js';\nimport { VivliostyleInlineConfig } from './config/schema.js';\nimport { Logger } from './logger.js';\nimport { vsBrowserPlugin } from './vite/vite-plugin-browser.js';\nimport { vsDevServerPlugin } from './vite/vite-plugin-dev-server.js';\nimport { vsStaticServePlugin } from './vite/vite-plugin-static-serve.js';\nimport { vsViewerPlugin } from './vite/vite-plugin-viewer.js';\n\nexport async function createVitePlugin(\n  inlineConfig: VivliostyleInlineConfig = {},\n): Promise<vite.Plugin[]> {\n  const parsedInlineConfig = v.parse(VivliostyleInlineConfig, inlineConfig);\n  let viteLogger: ReturnType<typeof vite.createLogger>;\n  Logger.setLogOptions({\n    ...parsedInlineConfig,\n    logger: parsedInlineConfig.logger ?? {\n      info: (msg) => viteLogger?.info(msg, { timestamp: true }),\n      warn: (msg) => viteLogger?.warn(msg, { timestamp: true }),\n      error: (msg) => viteLogger?.error(msg, { timestamp: true }),\n    },\n  });\n  viteLogger = vite.createLogger('info', {\n    prefix: '[vivliostyle]',\n  });\n  Logger.debug('inlineConfig %O', parsedInlineConfig);\n  const vivliostyleConfig =\n    (await loadVivliostyleConfig(parsedInlineConfig)) ??\n    setupConfigFromFlags(parsedInlineConfig);\n  warnDeprecatedConfig(vivliostyleConfig);\n  const { tasks, inlineOptions } = mergeInlineConfig(\n    vivliostyleConfig,\n    parsedInlineConfig,\n  );\n  const config = resolveTaskConfig(tasks[0], inlineOptions);\n  Logger.debug('config %O', config);\n\n  return [\n    vsDevServerPlugin({ config, inlineConfig: parsedInlineConfig }),\n    vsViewerPlugin({ config, inlineConfig: parsedInlineConfig }),\n    vsBrowserPlugin({ config, inlineConfig: parsedInlineConfig }),\n    vsStaticServePlugin({ config, inlineConfig: parsedInlineConfig }),\n  ];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,YAAY,OAAO;AACnB,YAAY,UAAU;AAYtB,eAAsB,iBACpB,eAAwC,CAAC,GACjB;AACxB,QAAM,qBAAuB,QAAM,yBAAyB,YAAY;AACxE,MAAI;AACJ,SAAO,cAAc;AAAA,IACnB,GAAG;AAAA,IACH,QAAQ,mBAAmB,UAAU;AAAA,MACnC,MAAM,CAAC,QAAQ,YAAY,KAAK,KAAK,EAAE,WAAW,KAAK,CAAC;AAAA,MACxD,MAAM,CAAC,QAAQ,YAAY,KAAK,KAAK,EAAE,WAAW,KAAK,CAAC;AAAA,MACxD,OAAO,CAAC,QAAQ,YAAY,MAAM,KAAK,EAAE,WAAW,KAAK,CAAC;AAAA,IAC5D;AAAA,EACF,CAAC;AACD,eAAkB,kBAAa,QAAQ;AAAA,IACrC,QAAQ;AAAA,EACV,CAAC;AACD,SAAO,MAAM,mBAAmB,kBAAkB;AAClD,QAAM,oBACH,MAAM,sBAAsB,kBAAkB,KAC/C,qBAAqB,kBAAkB;AACzC,uBAAqB,iBAAiB;AACtC,QAAM,EAAE,OAAO,cAAc,IAAI;AAAA,IAC/B;AAAA,IACA;AAAA,EACF;AACA,QAAM,SAAS,kBAAkB,MAAM,CAAC,GAAG,aAAa;AACxD,SAAO,MAAM,aAAa,MAAM;AAEhC,SAAO;AAAA,IACL,kBAAkB,EAAE,QAAQ,cAAc,mBAAmB,CAAC;AAAA,IAC9D,eAAe,EAAE,QAAQ,cAAc,mBAAmB,CAAC;AAAA,IAC3D,gBAAgB,EAAE,QAAQ,cAAc,mBAAmB,CAAC;AAAA,IAC5D,oBAAoB,EAAE,QAAQ,cAAc,mBAAmB,CAAC;AAAA,EAClE;AACF;","names":[]}
\ No newline at end of file
diff --recursive --unified --new-file a/package/dist/commands/build.js b/package/dist/commands/build.js
--- a/package/dist/commands/build.js	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/commands/build.js	1985-10-26 17:15:00.000000000 +0900
@@ -1,8 +1,8 @@
 import {
   build
-} from "../chunk-5MEUINC4.js";
+} from "../chunk-5JTKT7VK.js";
 import "../chunk-XMCTTVR7.js";
-import "../chunk-BR2V7MHE.js";
+import "../chunk-BYT766IR.js";
 import "../chunk-E6QVHS6D.js";
 import {
   Logger,
diff --recursive --unified --new-file a/package/dist/commands/preview.js b/package/dist/commands/preview.js
--- a/package/dist/commands/preview.js	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/commands/preview.js	1985-10-26 17:15:00.000000000 +0900
@@ -1,8 +1,8 @@
 import {
   preview
-} from "../chunk-37OLZSNI.js";
+} from "../chunk-HG3ZYWGO.js";
 import "../chunk-XMCTTVR7.js";
-import "../chunk-BR2V7MHE.js";
+import "../chunk-BYT766IR.js";
 import "../chunk-E6QVHS6D.js";
 import {
   createParserProgram,
diff --recursive --unified --new-file a/package/dist/index.js b/package/dist/index.js
--- a/package/dist/index.js	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/index.js	1985-10-26 17:15:00.000000000 +0900
@@ -1,17 +1,17 @@
 import {
   createVitePlugin
-} from "./chunk-62AC6XGJ.js";
+} from "./chunk-LDAP47TK.js";
 import {
   build
-} from "./chunk-5MEUINC4.js";
+} from "./chunk-5JTKT7VK.js";
 import {
   create
 } from "./chunk-O3CBPX4R.js";
 import {
   preview
-} from "./chunk-37OLZSNI.js";
+} from "./chunk-HG3ZYWGO.js";
 import "./chunk-XMCTTVR7.js";
-import "./chunk-BR2V7MHE.js";
+import "./chunk-BYT766IR.js";
 import "./chunk-E6QVHS6D.js";
 import "./chunk-T2VWLU2I.js";
 import {
diff --recursive --unified --new-file a/package/dist/vite-adapter.js b/package/dist/vite-adapter.js
--- a/package/dist/vite-adapter.js	1985-10-26 17:15:00.000000000 +0900
+++ b/package/dist/vite-adapter.js	1985-10-26 17:15:00.000000000 +0900
@@ -1,7 +1,7 @@
 import {
   createVitePlugin
-} from "./chunk-62AC6XGJ.js";
-import "./chunk-BR2V7MHE.js";
+} from "./chunk-LDAP47TK.js";
+import "./chunk-BYT766IR.js";
 import "./chunk-E6QVHS6D.js";
 import "./chunk-T2VWLU2I.js";
 import "./chunk-CKXFRCPH.js";
